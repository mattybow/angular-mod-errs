// underscore and jquery are implicitly available for all modules

/**
 * Base module of the application
 * @namespace stride
 */

angular.module('stride', [
  'ngAnimate',
  'ngSanitize',
  'ui',
  'routes',
  'config',
  'translate',
  'common',
  'snackbar',
  'headroom',
  'analytics.mixpanel',
  'modal'
  ])

  .config(['$httpProvider', '$compileProvider', function($httpProvider, $compileProvider){
    $httpProvider.interceptors.push('stride.version');

    if ('localhost' !== 'dev'){
      $compileProvider.debugInfoEnabled(false);
    }
  }])

/**
 * rootScope of the application
 * @name stride.rootScope
 * @augments {ng.$scope}
 * @property {ui.router.state.$state} $state
 * @property {ui.router.state.$stateParams} $stateParams
 * @property {ng.$location} $location
 * @property {string} partials the configured path to the partials directory
 */

  .run([
    '$rootScope',
    '$window',
    '$state',
    '$timeout',
    '$stateParams',
    '$location',
    'config',
    'services.htmlClass',
    'services.tracking',
    'utils',
    'common.extensions._',
    'common.extensions.router',
    function($rootScope, $window, $state, $timeout, $stateParams, $location, config, htmlClassService, trackingService, utils, underscoreExt, routerExt){
      $rootScope.$state       = $state;
      $rootScope.$stateParams = $stateParams;
      $rootScope.$location    = $location;
      $rootScope.partials     = config.paths.partials;
      $rootScope.config       = config;
      $rootScope.utils        = utils;
      $rootScope.today        = new Date();

      $rootScope.globals      = {};

      $($window).on('resize', _.debounce(function(){
        $rootScope.$broadcast('delayed-resize');
      }));

      var pageViewTimeout = null;
      $window.optimizely = $window.optimizely || [];

      // use debounce to activate after all content is loaded, to make sure elements are
      // present when experiment runs
      var activator = _.debounce(function(unbind){
        $window.optimizely.push(['activate']);
        unbind();
      }, 50);

      // run the experiment as soon as location changes,
      // to run any initialization code used for experiment wide js/css such as hiding content
      $rootScope.$on('$locationChangeSuccess', function(){
        $window.optimizely.push(['activate']);
      });

      $rootScope.$on('$stateChangeSuccess', function(){
        $timeout.cancel(pageViewTimeout);
        pageViewTimeout = $timeout(trackingService.virtualPageView, 200);

        // bind once each state change
        var unbind = $rootScope.$on('$viewContentLoaded', function(){
          // activator fn is debounced, since this event fires each time a nested view is rendered
          // listener is unbound after debounced activator executes
          activator(unbind);
        });
      });

      htmlClassService.checkFooter();

      $(document).on('mousedown touchstart', function($event){
        $rootScope.$broadcast('doc-click', $event);
      });

      if ($window.FastClick){
        $($window).on('load', function() {
          $window.FastClick.attach(document.body);
        });
      }
    }
  ])


  .factory('stride.version', ['config', 'snackbar.service', function(config, snackbarService){

    var hasSeenVersionMessage = false;

    return {
      response: function(response){

        var versionHeader = response.headers()['x-client-version'];
        if (!_.isString(versionHeader) || config.version === versionHeader) {
          return response;
        }

        var desiredVersion = versionHeader.split('.');

        _.some(config.version.split('.'), function(version, index){
          if (version !== desiredVersion[index]){
            // don't do anything if the client version is newer than what the server is expecting
            if (parseInt(version) > parseInt(desiredVersion[index])){
              return true;
            }

            // major and minor versions will force a refresh and kill this loop
            //if (index < 2){
            //  window.location.href = window.location.href;
            //}
            // hotfix versions will show a snackbar notification

            if (!hasSeenVersionMessage) {
              hasSeenVersionMessage = true;
              snackbarService.push({ key: 'shared.version.warn', duration: -1 });
            }
          }
        });

        return response;
      }
    };
  }]);
/**
 * @namespace common
 * @description This contains basic services and directives that are not specific to a component
 */
angular.module('common', ['common.class', 'common.services', 'common.directives', 'common.extensions', 'constants']);
/**
 * @module routes
 * @namespace routes
 */

angular.module('routes', [
    'ui.router',
    'user',
    'config',
    'common',
    'scrollTo',
    'sidebar',
    'application',
    'health',
    'finance',
    // add page routes here
    'routes.user',
    'routes.partner',
    'routes.purchase',
    'routes.home',
    'routes.about',
    'routes.profile',
    'routes.ob',
    'routes.plan',
    'routes.buy',
    'routes.cms',
    'routes.error',
    'routes.alex',
    'routes.subsidy',
    'routes.ffm',
    'routes.dashboard',
    'routes.drug',
    'routes.doctor',
    'routes.bor',
    // 'routes.financeTracker',
    'routes.visit.plan',
    'routes.marketing',
    'routes.dental',
    'routes.cart',
    'routes.getStarted',
    'routes.drive',
    'routes.borPreFunnel',
    'routes.borFunnel',
    'routes.checkout'
  ])
  .run([
    '$rootScope',
    '$state',
    '$injector',
    function ($rootScope, $state, $injector) {
      // https://github.com/angular-ui/ui-router/issues/1235
      $rootScope.$on('$stateChangeStart', function (event, toState, toParams) {
        var redirect = toState.redirectTo;

        if (!redirect) {
          return;
        }

        if (_.isFunction(toState.transformRedirectParams)){
          toParams = toState.transformRedirectParams(toParams);
        }

        if (_.isString(redirect)) {
          event.preventDefault();
          $state.go(redirect, toParams);
        }
        else {
          var newState = $injector.invoke(redirect, null, {toState: toState, toParams: toParams});
          if (newState) {
            if (_.isString(newState)) {
              event.preventDefault();
              $state.go(newState);
            }
            else if (newState.state) {
              event.preventDefault();
              $state.go(newState.state, newState.params);
            }
          }
        }
      });
    }
  ])

  .config([
    '$locationProvider',
    '$urlRouterProvider',
    '$stateProvider',
    'config.paths',
    function ($locationProvider, $urlRouterProvider, $stateProvider, paths) {

      if (window.history && history.pushState) {
        $locationProvider.html5Mode(true).hashPrefix('!');
      }

      $urlRouterProvider.otherwise("/");

//      $urlRouterProvider.when('', '/');
//      $urlRouterProvider.rule(function ($injector, $location) {
//        var path = $location.url();
//
//        // check to see if the path has a trailing slash
//        if ('/' === path[path.length - 1]) {
//          return path.replace(/\/$/, '');
//        }
//
//        if (path.indexOf('/?') > 0) {
//          return path.replace('/?', '?');
//        }
//
//        return false;
//      });

      $stateProvider
        .state('base', {
          abstract: true,
          templateUrl: paths.partials + '/routes/base.html',
          controller: 'routes.base.controller as base',
          resolve: {
            baseUser: [
              '$state',
              '$window',
              'user.service',
              'config.service',
              'services.promo',
              'user.model',
              function ($state, $window, userService, configService, promoService, userModel) {
                return userService.get()
                  .then(function (data) {

                    userModel.fromServer(data.user);
                    //return promoService.logVisit();

                    return userModel.setTrackingVars();

                  }, function (response) {
                    // For now, the only time a user request responds with 403 is for
                    // unverified users on partner site
                    if (response.status === 403) {
                      $window.location.href = $state.href('partnerUnverified');
                    }
                  });
              }
            ],

            baseHealthApp: [
              'application.service',
              'application.model',
              'baseUser',
              // 'finance.service',
              /**
               * @param {application.service} applicationService
               * @param {application.model} applicationModel
               * @param {user.model} userModel
               * @returns {HttpPromise<health.app>}
               */
              function (applicationService, applicationModel, userModel, financeService) {
                return applicationService.getWorking(userModel, 'health')
                  .then(function(ifp_app){
                    applicationModel.setFromDb(ifp_app);
                    return applicationModel;
                  });
              }
            ],

            //activeHealthApp: [
            //  'application.service',
            //  'health.app',
            //  'baseUser',
            //  'baseHealthApp',
            //  // wait for user and current health app to finish to avoid race conditions
            //  /**
            //   * @param {application.service} applicationService
            //   * @param {health.app} HealthApp
            //   * @param {user.model} userModel
            //   * @param {application.model} currentHealthApp
            //   * @returns {*}
            //   */
            //  function (applicationService, HealthApp, userModel, currentHealthApp) {
            //    var activeApp = new HealthApp();
            //    return applicationService.getActive(userModel, 'health')
            //      .then(function(ifp_app){
            //        return activeApp.setFromDb(ifp_app);
            //      });
            //  }
            //],

            userDrugModel: [
              'baseUser',
              'baseHealthApp',
              'drug.user.model',
              function (userModel, healthApp, userDrugModel) {
                userDrugModel.setUser(userModel);
                userDrugModel.setHealthApp(healthApp);
                return userDrugModel;
              }
            ]
          }
        })
        .state('sidebar', {
          abstract: true,
          parent: 'base',
          templateUrl: paths.partials + '/components/sidebar/sidebar-page.html',
          controllerAs: 'sidebar',
          controller: 'sidebar.controller'
        })
        // this is just here as a placeholder for now
        // currently some dashboard notifications pop a chat window
        // the notification needs a linkURL, which points to this route
        // the dashboard controller prevents state change to this route
        // and pops zendesk chat window
        .state('chat', {
          url: '/chat',
          template: '',
          controller: ['$state', function($state){
            $state.replace('home');
          }]
        });
    }
  ]);
angular.module('routes')
  .controller('routes.base.controller', [
    '$rootScope',
    '$window',
    '$timeout',
    'baseUser',
    'services.auth',
    'config.service',
    'baseHealthApp',
    //'activeHealthApp',
    'services.tracking',
    'finance.service',
    function($rootScope, $window, $timeout, userModel, authService, configService, currentHealthApp, trackingService, financeService){
      $rootScope.userModel = userModel;
      $rootScope.applicationModel = currentHealthApp;
      //$rootScope.activeHealthApp = activeHealthApp;

      window.memberFinance = financeService;
      console.warn('TESTING FINANCE SERVICE %c remove for prod ', 'background:red; color:white')

      // see if we need to redirect on the initial page load since $stateChangeStart has already occurred
      authService.performChecks();
      $rootScope.$on('$stateChangeStart', authService.performChecks);

      // handle site wide stateChangeSuccess here
      $rootScope.$on('$stateChangeSuccess', function($event, $toState){
        var toData = $toState.data;

        // is there a better place for this??
        if (toData && toData.scrollTop){
          $window.scrollTo(0, 0);
        }
      });

      // This was only needed for the time when users could still have an
      // active session from prior to our mixpanel implementation.
      // This was over a year ago, so it's no longer a use case
      //trackingService.mixpanel.ready
      //  .then(function(){
      //    trackingService.tryAlias(userModel);
      //  });

      //// create the user geo from the application address if need be
      //// TODO: consider updating this in databases
      //if (!userModel.getGeo() && currentHealthApp.hasAddress()){
      //  userModel.geo = angular.copy(currentHealthApp.getAddress());
      //}

      $rootScope.renderApp = true;
    }
  ]);
/**
 * @namespace common.class
 * @memberOf common
 * @description This contains the basic classes that are used/extended from throughout the application
 */
angular.module('common.class', []);
(function(){

  /**
   * @name Builder
   * @constructor
   */
  function Builder(){
    /**
     * @type {Object}
     */
    this.data = {};
    this.initialData = {};
  }

  /**
   * @name Builder.getValue
   * @methodOf Builder
   * @param {string} key
   * @returns {*}
   */
  Builder.prototype.getValue = function(key){
    return this.data[key];
  };


  /**
   * @name Builder.setValue
   * @methodOf Builder
   * @param {string} key
   * @param {*} value
   * @returns {Builder}
   */
  Builder.prototype.setValue = function(key, value){
    this.data[key] = value;
    return this;
  };


  /**
   * @name Builder.setValues
   * @methodOf Builder
   * @param {Object} obj key value pairs
   * @returns {Builder}
   */
  Builder.prototype.setValues = function(obj){
    _.extend(this.data, obj);
    return this;
  };

  /**
   * @name Builder.start
   * @methodOf Builder
   * @param {Object} [data]
   * @returns {Builder}
   */
  Builder.prototype.start = function(data){
    this.data = _.extend({ started: true }, data || {});
    this.initialData = angular.copy(this.data);
    return this;
  };

  /**
   * @name Builder.changed
   * @methodOf Builder
   * @returns {boolean}
   */
  Builder.prototype.changed = function(){
    return !_.isEqual(this.data, this.initialData);
  };

  /**
   * @name Builder.finish
   * @methodOf Builder
   * @returns {*}
   */
  Builder.prototype.finish = function(){
    console.error('Builder finish not overridden');
  };

  angular.module('common.class')
    .factory('common.class.builder', function(){
      return Builder;
    });
}());
/**
 * @namespace constants
 */
angular.module('constants', []);
angular.module('constants')

/**
 * @name constants.illnesses
 * @type {{ id: number, name: string }[]}
 */
  .constant('constants.illnesses', [
    {
      id: 2,
      name: "adhd"
    },
    {
      id: 3,
      name: "art"
    },
    {
      id: 4,
      name: "ast"
    },
    {
      id: 5,
      name: "cold"
    },
    {
      id: 6,
      name: "copd"
    },
    {
      id: 7,
      name: "dep"
    },
    {
      id: 8,
      name: "dia"
    },
    {
      id: 9,
      name: "hd"
    },
    {
      id: 10,
      name: "bp"
    }
  ]);
angular.module('common.extensions', ['ui.router']);
(function(){



  /**
   * @name common.extensions.router
   * @param {ng.$location} $location
   * @param {ui.router.state.$state} $state
   */
  function Svc($location, $state){

    /**
     * @name ui.router.state.$state.fromUrl
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to resolve a state and its parameters from a given URL
     *
     * @returns {Object<{ state: Object, stateArgs: Object }>} Returns a state that matches the given URL, or null
     */
    $state.fromUrl = function(url) {
      var result = null;

      if(!_.isString(url)) {
        return result;
      }

      var split = url.split('?');
      var path = split[0];
      var qs = split.length > 1 ? parseKeyValue(split[1]) : {};

      _.find($state.get(), function(state){
        // some abstract states don't get a $$state function
        if (!_.isFunction(state.$$state)){
          return false;
        }

        var internalState = state.$$state();
        // some abstract states don't have urls
        var stateArgs = internalState.url && internalState.url.exec(path, qs) || false;
        //If the state's URL does not match then stateArgs will be false
        if (!!stateArgs){
          result = {
            state: state,
            stateArgs: stateArgs
          };
        }

        return !!stateArgs;
      });

      return result;
    };

    /**
     * @name ui.router.state.$state.replace
     * @methodOf ui.router.state.$state
     * @param {Object|string} state
     * @param {Object} [params]
     * @returns {Promise<any>|*|promise|void}
     */
    $state.replace = function(state, params){
      //return $timeout(function(){
      return $state.go(state, params || null, { location: 'replace' });
      //});
    };

    /**
     * Safe way to access current state data
     * @name ui.router.state.$state.getData
     * @methodOf ui.router.state.$state
     * @returns {*}
     */
    $state.getData = function(){
      return $state.current.data || {};
    };

    /**
     * Go to the next state defined on the current state data
     * @name ui.router.state.$state.goNext
     * @param {string} [fallback] State to go to if no next specified in data
     * @methodOf ui.router.state.$state
     */
    $state.goNext = function(fallback){
      $state.go($state.getData().next || fallback);
    };

    // this is internal to angular
    /**
     * Parses an escaped url query string into key-value pairs.
     * @returns {Object.<string,boolean|Array>}
     */
    function parseKeyValue(/**string*/keyValue) {
      var obj = {};
      _.each((keyValue || "").split('&'), function(keyValue) {
        var splitPoint, key, val;
        if (keyValue) {
          key = keyValue = keyValue.replace(/\+/g,'%20');
          splitPoint = keyValue.indexOf('=');
          if (splitPoint !== -1) {
            key = keyValue.substring(0, splitPoint);
            val = keyValue.substring(splitPoint + 1);
          }
          key = tryDecodeURIComponent(key);
          if (!_.isUndefined(key)) {
            val = !_.isUndefined(val) ? tryDecodeURIComponent(val) : true;
            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
              obj[key] = val;
            } else if (_.isArray(obj[key])) {
              obj[key].push(val);
            } else {
              obj[key] = [obj[key],val];
            }
          }
        }
      });
      return obj;
    }

    /**
     * Tries to decode the URI component without throwing an exception.
     *
     * @private
     * @param {string} str value potential URI component to check.
     * @returns {string} True if `value` can be decoded
     * with the decodeURIComponent function.
     */
    function tryDecodeURIComponent(str) {
      try {
        return decodeURIComponent(str);
      } catch (e) {
        // Ignore any invalid uri component
      }
    }
  }
  Svc.$inject = ['$location', '$state'];

  angular.module('common.extensions')
    // from here: http://stackoverflow.com/questions/29892353/angular-ui-router-resolve-state-from-url/30926025#30926025
    .config(['$stateProvider', function($stateProvider){
      $stateProvider.decorator('parent', function (internalStateObj, parentFn) {
        // This fn is called by StateBuilder each time a state is registered
        // The first arg is the internal state. Capture it and add an accessor to public state object.
        internalStateObj.self.$$state = function() { return internalStateObj; };

        // pass through to default .parent() function
        return parentFn(internalStateObj);
      });
    }])
    .service('common.extensions.router', Svc);
}());
/**
 * This file adds some commonly used methods from lodash
 * to the global underscore object
 *
 * Keep the loose (in)equality to null throughout so
 * that null == undefined
 */

(function(){

  function Ext(){

    /** Used to detect unsigned integer values. */
    //var reIsUint = /^(?:0|[1-9]\d*)$/;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;
    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /** Used as references for various `Number` constants. */
    //var INFINITY = 1 / 0,
    //  MAX_SAFE_INTEGER = 9007199254740991,
    //  MAX_INTEGER = 1.7976931348623157e+308,
    //  NAN = 0 / 0;

    //var hasOwnProperty = Object.prototype.hasOwnProperty;
    //
    ///**
    // * Checks if `value` is a valid array-like length.
    // *
    // * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
    // *
    // * @static
    // * @memberOf _
    // * @category Lang
    // * @param {*} value The value to check.
    // * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
    // * @example
    // *
    // * _.isLength(3);
    // * // => true
    // *
    // * _.isLength(Number.MIN_VALUE);
    // * // => false
    // *
    // * _.isLength(Infinity);
    // * // => false
    // *
    // * _.isLength('3');
    // * // => false
    // */
    //function isLength(value) {
    //  return typeof value === 'number' &&
    //    value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
    //}
    //
    ///**
    // * Checks if `value` is a valid array-like index.
    // *
    // * @private
    // * @param {*} value The value to check.
    // * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
    // * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
    // */
    //function isIndex(value, length) {
    //  value = (typeof value === 'number' || reIsUint.test(value)) ? +value : -1;
    //  length = length == null ? MAX_SAFE_INTEGER : length;
    //  return value > -1 && value % 1 === 0 && value < length;
    //}
    //
    ///**
    // * The base implementation of `_.slice` without an iteratee call guard.
    // *
    // * @private
    // * @param {Array} array The array to slice.
    // * @param {number} [start=0] The start position.
    // * @param {number} [end=array.length] The end position.
    // * @returns {Array} Returns the slice of `array`.
    // */
    //function baseSlice(array, start, end) {
    //  var index = -1,
    //    length = array.length;
    //
    //  if (start < 0) {
    //    start = -start > length ? 0 : (length + start);
    //  }
    //  end = end > length ? length : end;
    //  if (end < 0) {
    //    end += length;
    //  }
    //  length = start > end ? 0 : ((end - start) >>> 0);
    //  start >>>= 0;
    //
    //  var result = Array(length);
    //  while (++index < length) {
    //    result[index] = array[index + start];
    //  }
    //  return result;
    //}
    //
    ///**
    // * Gets the last element of `array`.
    // *
    // * @static
    // * @memberOf _
    // * @category Array
    // * @param {Array} array The array to query.
    // * @returns {*} Returns the last element of `array`.
    // * @example
    // *
    // * _.last([1, 2, 3]);
    // * // => 3
    // */
    //function last(array) {
    //  var length = array ? array.length : 0;
    //  return length ? array[length - 1] : undefined;
    //}

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} str The string to convert.
     * @returns {Array} Returns the property path array.
     */
    function stringToPath(str) {
      var result = [];
      str = _.isString(str) ? str : '';

      str.replace(rePropName, function(match, number, quote, s) {
        result.push(quote ? s.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (typeof value === 'number') {
        return true;
      }
      return !_.isArray(value) &&
        (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object !== null && value in Object(object)));
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */
    function baseCastPath(value) {
      return _.isArray(value) ? value : stringToPath(value);
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = isKey(path, object) ? [path + ''] : baseCastPath(path);

      var index = 0,
        length = path.length;

      while (object != null && index < length) {
        object = object[path[index++]];
      }
      return (index && index === length) ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object === null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    ///**
    // * The base implementation of `_.has` without support for deep paths.
    // *
    // * @private
    // * @param {Object} object The object to query.
    // * @param {Array|string} key The key to check.
    // * @returns {boolean} Returns `true` if `key` exists, else `false`.
    // */
    //function baseHas(object, key) {
    //  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
    //  // that are composed entirely of index properties, return `false` for
    //  // `hasOwnProperty` checks of them.
    //  return hasOwnProperty.call(object, key) ||
    //    (typeof object === 'object' && key in object && Object.getPrototypeOf(object) === null);
    //}
    //
    ///**
    // * Gets the parent value at `path` of `object`.
    // *
    // * @private
    // * @param {Object} object The object to query.
    // * @param {Array} path The path to get the parent value of.
    // * @returns {*} Returns the parent value.
    // */
    //function parent(object, path) {
    //  return path.length === 1 ? object : get(object, baseSlice(path, 0, -1));
    //}

    ///**
    // * Checks if `path` exists on `object`.
    // *
    // * @private
    // * @param {Object} object The object to query.
    // * @param {Array|string} path The path to check.
    // * @param {Function} hasFunc The function to check properties.
    // * @returns {boolean} Returns `true` if `path` exists, else `false`.
    // */
    //function hasPath(object, path, hasFunc) {
    //  if (object == null) {
    //    return false;
    //  }
    //  var result = hasFunc(object, path);
    //  if (!result && !isKey(path)) {
    //    path = baseCastPath(path);
    //    object = parent(object, path);
    //    if (object != null) {
    //      path = last(path);
    //      result = hasFunc(object, path);
    //    }
    //  }
    //  var length = object ? object.length : undefined;
    //  return result || (
    //      !!length && isLength(length) && isIndex(path, length) &&
    //      (_.isArray(object) || _.isString(object) || _.isArguments(object))
    //    );
    //}

    _.get = get;
    //_.has = hasPath;
  }

  angular.module('common.extensions')
    .service('common.extensions._', Ext);
}());
angular.module('common')
  //  .filter('shCommaList', [
  //    'utils',
  //    'translate.service',
  //    function(utils, translateService){
  //
  //      var comma = ', ';
  //
  //      return function(list, prop, andKey){
  //        var str = '';
  //        var listLength = list.length;
  //        var and = ' ' + translateService.tryTranslate(andKey || 'shared.and') + ' ';
  //
  //        _.each(list, function(listItem, index){
  //          var value = prop ? utils.traverse(listItem, prop) : listItem;
  //          switch (index){
  //            case 0:
  //              break;
  //            case listLength - 1:
  //              value = and + value;
  //              break;
  //            default:
  //              value = comma + value;
  //              break;
  //          }
  //
  //          str += value;
  //        });
  //
  //        return str;
  //      }
  //    }
  //  ])

  .filter('shTruncate', [
    function () {

      return function (str, length) {
        var newStr = str;

        if (str.length > length) {
          newStr = str.substr(0, length) + '...';
        }

        return newStr;
      }
    }
  ])

  .filter('shOrdinal', [
    function () {
      return function (n, locale) {
        if (!_.isNumber(n)) {
          n = parseInt(n);
        }

        if (!isNaN(n)) {

          if (locale == 'es-LA') {
            var b = n % 10;
            return n + ((b === 1 || b === 3) ? 'er' :
                (b === 2) ? 'do' :
                  (b === 7 || b === 0) ? 'mo' :
                    (b === 8) ? 'vo' :
                      (b === 9) ? 'no' : 'to');
          }

          var s = ["th", "st", "nd", "rd"], v = n % 100;
          return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        return '';
      }
    }
  ])
  
  .filter('ordinalDate', [
    '$filter',
    'services.date',
    function($filter, dateService){
      var suffixes = ['th', 'st', 'nd', 'rd'];

      return function(input, format){

        if (_.isString(input)){
          input = dateService.fromIsoDate(input);
        }

        var ngDateResult = $filter('date')(input, format);
        var day = parseInt($filter('date')(input, 'dd'));
        var suffix = suffixes[(day - 20) % 10] || suffixes[day] || suffixes[0];
        return ngDateResult.replace('oo', suffix);
      };
    }
  ])

  .filter('capitalize', [
    'utils',
    function (utils) {
      return function (s) {
        return _.isString(s) && utils.capitalize(s) || s;
      }
    }
  ])

  .filter('stripMdLink', [
    function () {
      // replace [Some link text](http://someurl.com) with Some link text
      var reg = /\[([^\]]*)\] *\([^\)]*\)/g;

      return function (s) {
        return _.isString(s) ? s.replace(reg, '$1') : s
      }
    }
  ])

  .filter('tel', function () {
    return function (tel) {
      if (!tel) {
        return '';
      }

      var value = tel.toString().trim().replace(/^\+/, '');

      if (value.match(/[^0-9]/)) {
        return tel;
      }

      var country, city, number;

      switch (value.length) {
        case 10: // +1PPP####### -> C (PPP) ###-####
          country = 1;
          city = value.slice(0, 3);
          number = value.slice(3);
          break;

        case 11: // +CPPP####### -> CCC (PP) ###-####
          country = value[0];
          city = value.slice(1, 4);
          number = value.slice(4);
          break;

        case 12: // +CCCPP####### -> CCC (PP) ###-####
          country = value.slice(0, 3);
          city = value.slice(3, 5);
          number = value.slice(5);
          break;

        default:
          return tel;
      }

      if (country == 1) {
        country = "";
      }

      number = number.slice(0, 3) + '-' + number.slice(3);

      return (country + " (" + city + ") " + number).trim();
    };
  })
  .filter('urlEscape', [
    function () {
      return function (s) {
        return _.isString(s) && encodeURI(s);
      }
    }
  ])
  .filter('possessive', [
    function () {
      return function (s) {
        var possessive = s;

        if (_.isString(s)) {
          if (s.slice(-1) === 's') {
            possessive = s.concat('\'');
          } else {
            possessive = s.concat('\'s');
          }
        }
        return possessive;
      }
    }
  ]);
angular.module('common.directives', ['translate', 'ngAnimate', 'plan']);
angular.module('common.directives')
  .directive('shApp', [
    function(){

      return {
        controller: function(){
          this.setNav = function($element){
            this.nav = $element;
          };
        }
      }

    }
  ])

  .directive('shHeaderNav', function(){
    return {
      transclude: true,
      template: '',
      replace: true,
      require: '^shApp',
      link: function($scope, $element, $attr, appCtrl, $transclude) {
        var transcludeScope;

        appCtrl.setNav($transclude(function(clone, scope){
          transcludeScope = scope;
        }));

        // need to clean up the transcluded scope when this scope is destroyed
        $scope.$on('$destroy', function(){
          appCtrl.setNav(null);
          transcludeScope.$destroy();
        });
      }
    }
  })

  .directive('shHeaderTransclude', [
    '$http',
    '$compile',
    'config.paths',
    function($http, $compile, paths) {

//      var defaultTemplate = $http
//        .get(paths.partials + '/routes/shared/site-header-nav.html')
//        .then(function(response){ return response.data });

      return {
        scope: true,
        require: '^shApp',
        link: function ($scope, $element, $attr, controller) {

          $scope.$watch(function () {
            return controller.nav;
          }, function(newValue){

              $element.html(newValue || '');
//
//            else {
//              defaultTemplate.then(function (template) {
//                $element.html($compile(template)($scope));
//              })
//            }
          });
        }


      };
    }
  ]);
// modified from ui.bootstrap

angular.module('common.directives')

  .directive('shCollapse', [
    '$timeout',
    function ($timeout) {

      return {
        link: function ($scope, $element, $attr) {
          $element.addClass('collapse');
          var clearAnimTimeout;
          var initialAnimSkip = true;

          function expand() {
            $timeout.cancel(clearAnimTimeout);

            if (initialAnimSkip) {
              initialAnimSkip = false;
              $element.height('auto');
            }
            else {
              var promise = animateTo($element[0].scrollHeight);
              if (promise){
                promise.then(function(){
                  $element.height('auto');
                });
              }
            }
          }

          function collapse() {
            $timeout.cancel(clearAnimTimeout);

            if (initialAnimSkip) {
              initialAnimSkip = false;
              $element.height(0).addClass('close');

            }
            else {
              // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
              $element.height($element[0].scrollHeight);
              //trigger reflow so a browser realizes that height was updated from auto to a specific value
              var x = $element[0].offsetWidth;

              animateTo(0);
            }
          }

          function animateTo(height){
            $element.addClass('animating');
            $element.height(height);

            if (!!height){
              $element.removeClass('close');
            }

            clearAnimTimeout = $timeout(function(){
              $element.removeClass('animating');
              if (!height){
                $element.addClass('close');
              }
            }, getDuration());

            return clearAnimTimeout;
          }

          function getDuration(){
            var cssDuration = $element.css('transitionDuration');

            if (cssDuration && cssDuration != ''){
              return parseFloat(cssDuration) * 1000; //jquery converts it into seconds
            }

            return 0;
          }
  
          $scope.$watch($attr.shCollapse, function (shouldCollapse) {
            if (shouldCollapse) {
              collapse();
            } else {
              expand();
            }
          });
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shDisableSubmit', [
    function(){
      return {
        restrict: 'A',
        link: function($scope, $element){
          $element.on('keydown', function($event){
            if ($event.keyCode == 13){
              $event.preventDefault();
              $event.stopPropagation();
            }
          });
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('dynamicTemplate', [
    '$compile',
    function($compile){
      return {
        link: function($scope, $element, $attr){
          var template = $scope.$eval($attr.dynamicTemplate);
          $element.html(template);
          $compile($element.contents())($scope);
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shFillHeight', [
    '$window',
    function($window) {
      return {
        link: function($scope, $element, $attr){
          $element.addClass('fill-height');
          var $elementToFill = $attr.shFillHeight ? $($attr.shFillHeight) : $($window);

          $scope.$on('delayed-resize', setHeight);
          $scope.$on('$viewContentLoaded', _.debounce(setHeight, 50));
          $scope.$on('$stateChangeSuccess', setHeight);
          $attr.$observe('setHeight', setHeight);

          function setHeight(height){
            if (!_.isNumber(height)){
              height = $elementToFill.height();
            }

            var pad = parseInt($attr.pad);
            if (_.isNaN(pad)){
              pad = 0;
            }

            $element.css('height', height - $element.offset().top - pad);
          }
        }
      };
    }
  ]);
//angular.module('common.directives')
//  .directive('shFillScreen', [
//    function(){
//      return {
//        link: function($scope, $element){
//          adjust();
//
//          $scope.$on('delayed-resize', adjust);
//
//          function adjust(){
////            if (mqService.medium()){
//              // need to reset these momentarily to get the correct negative offsets
////              $element.css({ top: 0, left: 0 });
//
////              var offset = $element.offset();
//
//              $element.css({
////                top: -offset.top,
////                left: -offset.left,
//                width: $(window).width(),
//                height: $(window).height()
//              });
////            }
//          }
//        }
//      }
//    }
//  ]);
angular.module('common.directives')
  .directive('shFocusIf', [
    function(){
      return {
        restrict: 'A',
        link: function($scope, $element, $attr){

          $scope.$watch($attr.shFocusIf, function(newValue){
            if (newValue){
              $element.focus();
            }
          });
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shHtmlClass', [
    'services.htmlClass',
    function(htmlClassService){
      return {
        restrict: 'A',
        link: function($scope, $element, $attrs){
          var classes = $attrs.shHtmlClass || '';
          htmlClassService.add(classes);

          $scope.$on('$destroy', function(){
            htmlClassService.remove(classes);
          });
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('httpButton', [
    '$http',
    '$timeout',
    'config.paths',
    function($http, $timeout, paths){

      var template = $http.get(paths.partials + '/common/partials/loader.html')
        .then(function(response){
          return response && response.data || '';
        });

      return {
        link: function($scope, $element){
          var lockName = 'pending';

          template.then(function(html){
            $element.after(html);
          });

          function lock(){
            $scope[lockName] = true;
            $element.addClass(lockName);
          }

          function unlock(){
            $scope[lockName] = false;
            $element.removeClass(lockName)
          }

          function getPendingRequests(){
            return $http.pendingRequests.length;
          }

          $element.on('click', function(e){
            if (!$element.hasClass('disabled')) {
              lock();

              // something failed or everything was synchronous, so remove loader
              $timeout(function(){
                if (getPendingRequests() == 0){
                  unlock();
                }
              });
            }
          });

          $scope.$watch(getPendingRequests, function(count){
            if ($scope[lockName] && count == 0){
              unlock();
            }
          });
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shMatchHeight', function(){

    return {
      controller: ['$scope', function($scope){
        var $els = [];

        var adjust = function(){
          var maxHeight = 0;

          $els.forEach(function($el){
            $el.css('height', 'auto');
            maxHeight = Math.max(maxHeight, $el[0].scrollHeight);
          });

          $els.forEach(function($el){
            $el.css('height', maxHeight);
          });
        };

        this.addEl = function($el){
          $els.push($el);
        };

        this.removeEl = function($el){
          $els = _.without($els, $el);
        };

        this.adjust = _.debounce(adjust, 10);

//        $scope.$on('page-height-change', function(){ console.log(arguments) });
        $scope.$on('img-loaded', this.adjust);
        $scope.$on('delayed-resize', this.adjust);
      }]
    }
  })

  .directive('shMatchHeightItem', [
    function(){
      return {
        require: '?^shMatchHeight',
        link: function($scope, $element, attrs, matchHeightCtrl){
          if (!matchHeightCtrl) return;
          matchHeightCtrl.addEl($element);

          $scope.$on('$destroy', function(){
            matchHeightCtrl.removeEl($element);
          });

          // watching html is actually faster and more accurate
          // than watching the scroll height of the element
          $scope.$watch(function(){ return $element.html() }, matchHeightCtrl.adjust);
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('noWidows', function(){
    return {
      link: function($scope, $element, $attr){
        var cachedValue;
        var wordCount = $attr.wordCount ? parseInt($attr.wordCount) : 2;

        updateText($element.text());
        $scope.$watch(function(){ $element.html(); }, updateText);

        function updateText(value){
          // prevent recursive firing, since we're
          // potentially editing the value we're watching
          if (value && value !== cachedValue){
            // IE9 strict mode does not support native string.trim()
            var words = $.trim(value).split(' ');
            var length = words.length;

            if (length + 1 < wordCount){
              return;
            }

            cachedValue = _.reduce(words.slice(1), function(memo, word, index){
              return memo + (length - index > wordCount ? ' ' : '&nbsp;') + word;
            }, words[0]);

            $element.html(cachedValue);
          }
        }
      }
    };
  });
(function(){
  var placeholder = 'placeholder';

  angular.module('common.directives')
    .directive(placeholder, [
      function() {
        // native support, just let the native placeholder attr take over
        if (placeholder in document.createElement('input')){
          return {};
        }

        // otherwise create an overlay with the value in it
        return {
          restrict: 'A',
          require: 'ngModel',
          link: function($scope, $element, $attr) {
            var $parent = $element.parent();
            var $placeholder = $('<span class="' + placeholder + '" />');
            var toggle = function(){
              if ($element.val() !== '') {
                $placeholder.remove();
              }
              else {
                $parent.prepend($placeholder);
              }
            };

            $parent.on('click', '.' + placeholder, $element.focus);
            $scope.$watch($attr.ngModel, toggle);
            $attr.$observe(placeholder, function(value){
              $placeholder.text(value);
            });
          }
        };
      }
    ]);

}());

angular.module('common.directives')
  .directive('slick', [
    '$q',
    '$timeout',
    function($q, $timeout){
      return {
        restrict: 'A',
        controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs){

          var isInitialized = false;

          if (angular.isDefined($attrs.whichSlide)){
            $scope.$watch($attrs.whichSlide, function(newValue, oldValue){
              if (isInitialized && newValue != oldValue){
                $element.slickGoTo(newValue);
              }
            });
          }



          this.init = function(){
            isInitialized = true;
            $scope.totalSlides = $element.children().length;

            // jenky polling for slick, but whatever
            slickReady().then(function(){
              $element.slick({
                slidesToShow: $attrs.slidesToShow || 4,
                //slidesToScroll: $attrs.slidesToScroll || 1, // this is breaking it for some reason
                infinite: false,
                onAfterChange: function(){
                  $scope.$apply(function(){
                    $scope.$parent.currentSlide = $element.slickCurrentSlide();
                  })
                },
                responsive: [
                  {
                    breakpoint: 640,
                    settings: {
                      slidesToShow: 1,
                      slidesToScroll: 1
                    }
                  }
                ]
              });

              if ($scope.currentSlide !== 0){
                $element.slickGoTo($scope.currentSlide);
              }
            });

          };

          this.addSlide = function($slide){
            if (isInitialized){
              $element.slickAdd($slide);
              $scope.totalSlides = $element.children().length;
            }
          };


          function slickReady(){
            var defer = $q.defer();

            (function loop(){
              if ($.fn.slick){
                defer.resolve();
                return;
              }

              $timeout(loop, 100);
            })();

            return defer.promise;
          }
        }]
      }

    }
  ])
  .directive('slickSlide', [
    '$timeout',
    function($timeout){

      return {
        restrict: 'A',
        require: '?^slick',
        link: function($scope, $element, attrs, ctrl){
          if (!ctrl) return;

          // need to wait for a digest cycle
          // so binding occurs before slick clones it
          $timeout(function(){
            ctrl.addSlide($element);

            if ($scope.$last){
              $timeout(ctrl.init, 100);
            }
          });

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shSortList', [
    '$timeout',
    function($timeout){

      return {
        scope: true,
        link: function($scope, $element, $attr){
          $element.addClass('sort-list');

          var _duration, _limit, _fullList;

          if ($attr.limit){
            _limit = parseInt($attr.limit);
          }

          setDuration();

          // need to slice here for angular to see it as a different array
          _fullList = $scope.$eval($attr.shSortList).slice(0);
          $scope.sortedList = _fullList.slice(0, _limit);

          $attr.$observe('limit', function(value){
            value = parseInt(value);
            if (_limit !== value){
              _limit = value;
              $scope.sortedList = _fullList.slice(0, _limit);
            }
          });

          $scope.$watchCollection($attr.shSortList, function(newOrder){
            if (!angular.equals(_fullList, newOrder)){
              sort(newOrder);
            }
          });

          function setDuration(){
            $element.addClass('animating');
            var $tempItem = $element.append('<li />').children().last();
            var cssDuration = $tempItem.css('transitionDuration');

            if (cssDuration && cssDuration !== ''){
              _duration = parseFloat(cssDuration) * 1000; //jquery converts it into seconds
            }

            $element.removeClass('animating');
            $tempItem.remove();
          }

          function sort(newOrder){
            var itemHeight = $element.children().eq(0).outerHeight();

            _fullList = newOrder.slice(0);
            $element.addClass('animating');//.css('height', $element.height());


            var newItems = _.reject(newOrder.slice(0, _limit), function(newItem){
              return _.contains($scope.sortedList, newItem);
            });

            _.each(newItems, function(item){
              $scope.sortedList.push(item);
            });

            // let digest happen first so all the $li elements are there
            $timeout(function(){
              var $currentList = $element.children();

              _.each($scope.sortedList, function(sortedItem, oldIndex) {
                var translate = 0;
                var $oldItem = $currentList.eq(oldIndex);
                var newIndex = _.indexOf(newOrder, sortedItem);

                var newTop = itemHeight * newIndex;
                var className = 'removing';

                // if it is staying in the list, move it
                if (newIndex > -1 && newIndex < _limit) {
                  translate = newTop - $oldItem.position().top;
                  className = translate > 0 ? 'down' : 'up';

                  if (_.contains(newItems, sortedItem)){
                    className = 'adding';
                  }
                }
                else {
                  translate = 200;
                }

                $oldItem
                  .addClass(className)
                  .css('transform', 'translate3d(0, ' + translate + 'px, 0)');
              });

            }, 10);

            $timeout(function(){
              $element.removeClass('animating');
              $scope.sortedList = newOrder.slice(0, _limit);
              resetChildren();
            }, _duration, true);

          }

          function resetChildren(){
            $element.children().each(function(){
              $(this)
                .removeClass('up down adding removing')
                .css('transform', null);
            });
          }
        }
      };
    }
  ]);
//'use strict';
//
//angular.module('common.directives')
//  .directive('stateNav', [
//    '$state',
//    'utils',
//    'config.paths',
//    function($state, utils, paths) {
//
//      return {
//        scope: true,
//        templateUrl: paths.partials + '/routes/shared/state-nav.html',
//        link: function($scope) {
//          $scope.$watch('items', updateStates);
//          $scope.$on('$stateChangeSuccess', updateStates);
//
//          $scope.back = function(){
//            var current = utils.indexOf($scope.renderedItems, function(item){ return item.active; });
//
//            if (current > 0 && $state.get()){
//              $state.go()
//            }
//          };
//
//          function updateStates(){
//            var items = angular.copy($scope.items);
//
//            _.each(items, function(item){
//              item.excluded = isMatching(item, 'excludedStates');
//              item.active = !item.excluded && $state.includes(item.state.name, item.state.params);
//              item.visited = !item.excluded && isMatching(item, 'visitedStates');
//              item.disabled = isMatching(item, 'disabledStates');
//            });
//
//            $scope.renderedItems = items;
//          }
//        }
//      };
//
//      function isMatching(item, arrayName){
//        var array = item[arrayName] || [];
//
//        return array.some(function(state){
//          return $state.includes(state.name, state.params)
//        });
//      }
//    }
//  ]);
//
//  .directive('stateNavBack', [
//    function(){
//      return {
//        require: 'stateNav',
//        link: function($scope, $element, $attr, stateNavController){
//
//        }
//      }
//    }
//  ]);
angular.module('common.directives')
  .directive('shSubmitErrors', [
    function(){
      var showErrorsClass = 'show-errors';
      var hideErrorsClass = 'hide-errors';

      return {
        restrict: 'A',
        require: 'form',
        link: function($scope, $element, $attrs, formController){

          $scope.$watch(function(){ return formController.$valid; }, function(newValue){
            if (newValue || formController.$pristine){
              $element
                .addClass(hideErrorsClass)
                .removeClass(showErrorsClass);
            }
          });

          //$scope.$on('submit-error', showErrors);

          $element.on('submit', function($event){
            if (!formController.$valid){
              $event.preventDefault();
              showErrors();
            }
          });

          $scope.showErrors = showErrors;

          function showErrors(){
            $element
              .addClass(showErrorsClass)
              .removeClass(hideErrorsClass);
          }
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shTicker', [
    '$filter',
    'services.animate',
    function($filter, animateService){

      return {
        restrict: 'A',
        template: '<span></span>',
        link: function($scope, $element, attrs){

          var isCurrency  = !!attrs.currency;
          var duration = parseFloat(attrs.duration) || .5;

          $scope.$watch(attrs.value, function(newValue, oldValue){
            if (newValue != oldValue){
              update(newValue, oldValue);
            }

            else {
              setValue(newValue);
            }
          });

          function update(newValue, oldValue){
            var current     = oldValue;
            var stepCount   = Math.floor(duration * 1000 / 60); // duration * framerate
            var stepAmount  = (newValue - oldValue) / stepCount;

            (function loop(){
              current = current + stepAmount;

              if (--stepCount > 0){
                setValue(current);
                animateService.raf(loop);
              }
              else {
                // use newValue here to make sure it ends up at the correct amount
                setValue(newValue);
              }
            }());
          }

          function setValue(value){
            $element.html((isCurrency ? '$' : '') + $filter('number')(value, 0));
          }

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('transScope', function(){
    return {
      link: {
        pre: function($scope, $element, $attr, ctrl, transclude){
          if (transclude){
            transclude($scope, function(el){
              if (el.length){
                $element.html(el);
              }
            });
          }
        }
      }
    };
  });
angular.module('common.directives').directive('shYoutube', [
  '$q',
  'services.tracking',
  function($q, trackingService){

    var deferred        = $q.defer();
    var ready           = deferred.promise;
    var tag             = document.createElement('script');
    var firstScriptTag  = document.getElementsByTagName('script')[0];

    window.onYouTubeIframeAPIReady = function(){
      deferred.resolve();
    };

    // This code loads the IFrame Player API code asynchronously.
    tag.async = 1;
    tag.src = "https://www.youtube.com/iframe_api";
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    return {
      restrict: 'A',
      template: '<div><div class="video-swap"></div></div>',
      link: function($scope, $element, $attrs){
        if (!$attrs.videoId) return;

        var player;
        var id = 'yt-' + (+new Date());
        var started = false;

        $('.video-swap', $element).attr('id', id);

        ready.then(function(){

          player = new YT.Player(id, {
            height: $attrs.videoHeight || '390',
            width: $attrs.videoWidth || '640',
            videoId: $attrs.videoId,
            events: {
              //'onReady': onPlayerReady,
              'onStateChange': onPlayerStateChange
            }
          });
        });

        function onPlayerStateChange(event){
          if (!started && event.data == YT.PlayerState.PLAYING){
            started = true;
            trackingService.event('Video', 'play', 'Play ' + ($attrs.videoTitle || $attrs.videoId))
          }
        }
      }
    }
  }
]);
/**
 * @namespace common.services
 * @memberOf common
 * @description This contains the basic services that are used throughout the application
 */

//TODO: remove session once member service is moved to it's own module
angular.module('common.services', ['config', 'ui.router', 'analytics.mixpanel', 'session']);
angular.module('common.services')
  .service('services.alert', [
    '$timeout',
    function($timeout){
      var _self = this;
      var messageTimeout, warningTimeout;

      // trying this to simplify things a little
      var _message = null;
      _self.getMessage = function(){
        return _message;
      };
      _self.setMessage = function(message){
        $timeout.cancel(messageTimeout);
        _message = message;

        if (message && _.isNumber(message.duration)){
          messageTimeout = $timeout(function(){
            _self.setMessage(null);
          }, message.duration);
        }
      };

      var _warning = null;
      _self.getWarning = function(){
        return _warning;
      };
      _self.setWarning = function(warning){
        $timeout.cancel(warningTimeout);
        _warning = warning;

        if (warning && _.isNumber(warning.duration)){
          warningTimeout = $timeout(function(){
            _self.setWarning(null);
          }, warning.duration);
        }
      };

      _self.clear = function(){
        _warning = null;
        _message = null;
      };

//      var _histories = {
//        message: [],
//        warning: [],
//        error:   []
//      };

//      _self.addMessage = function(message){
//        add('message', message);
//      };
//
//      _self.replaceMessage = function(newMessage, oldMessage){
//        replace('message', newMessage, oldMessage);
//      };
//
//      _self.replaceLastMessage = function(newMessage){
//        replaceLast('message', newMessage);
//      };
//
//      _self.removeMessage = function(message) {
//        remove('message', message);
//      };
//
//      _self.removeLastMessage = function(){
//        removeLast('message');
//      };
//
//      _self.getMessages = function(){
//        return _histories.message;
//      };
//
//      _self.getLastMessage = function(){
//        return _histories.message[_histories.message.length - 1];
//      };
//
//      _self.addWarning = function(warning){
//        add('warning', warning);
//      };
//
//      _self.removeLastWarning = function(){
//        removeLast('warning');
//      };
//
//      _self.getLastWarning = function(){
//        return _histories.warning[_histories.warning.length - 1];
//      };





//      _self.setMessages = function(messages){
//        set('messages', messages);
//      };
//
//      _self.setWarnings = function(warnings){
//        set('warnings', warnings);
//      };
//
//      function set(type, alerts){
//        var oldAlerts = angular.copy(_alerts[type]);
//        _alerts[type] = alerts;
//        $rootScope.$broadcast('alert-' + alert + '-changed', _alerts[type], oldAlerts);
//      }

//      function add(type, alert){
//        var history = _histories[type];
//        var previousAlert = history[history.length - 1];
//
//        // only transition in when message key changes,
//        // so updating the models won't pull in another banner
//        if (!previousAlert || alert.key != previousAlert.key){
//
//          // if there is no history yet, don't need to do subsequent checks
//          if (!history.length){
//            history.push(alert);
//          }
//
//          else {
//            // if the message is already present in the history,
//            // just move it to the latest position
//            var existingIndex = _.indexOf(history, alert);
//            if (existingIndex >= 0){
//              history.splice(existingIndex, 1);
//            }
//
//            history.push(alert);
//          }
//
//        }
//      }
//
//      function remove(type, alert){
//        var history = _histories[type];
//        _histories[type] = _.isArray(alert) ? _.without.apply(null, history, alert) : _.without(history, alert);
//      }
//
//      function removeLast(type){
//        var history = _histories[type];
//        _histories[type] = _.without(history, history[history.length - 1]);
//      }
//
//      function replace(type, newAlert, oldAlert){
//        var history = _histories[type];
//        var index = _.indexOf(history, oldAlert);
//
//        if (index >= 0){
//          if (newAlert.key != oldAlert.key){
//            history.splice(index, 1, newAlert);
//          }
//          // just update the model if the keys are the same so it doesn't transition in
//          else {
//            history[index].model = newAlert.model;
//          }
//        }
//        else {
//          add(type, newAlert);
//        }
//      }
//
//      function replaceLast(type, newAlert){
//        var history = _histories[type];
//        replace(type, newAlert, history[history.length - 1]);
//      }
    }
  ]);
angular.module('common.services')
  .service('services.animate', [
    '$window',
    '$timeout',
    function($window, $timeout){

      var raf = $window.requestAnimationFrame       ||
                $window.webkitRequestAnimationFrame ||
                $window.mozRequestAnimationFrame    ||
                $window.oRequestAnimationFrame      ||
                $window.msRequestAnimationFrame     ||
                function(callback){
                  $timeout(callback, 1000 / 60);
                };

      this.raf = function(callback){
        // keep this as an anonymous function, rAF needs window as context
        raf(callback);
      };
    }
  ]);
angular.module('common.services')
  .service('services.auth', [
    '$q',
    '$http',
    '$rootScope',
    '$state',
    'config',
    'config.service',
    'utils',
    function($q, $http, $rootScope, $state, config, configService, utils){

      /**
       * @name services.auth
       * @memberOf common.services
       */

      var self            = this;
      var _authenticated  = false;
      var _verified       = false;
      var _appComplete    = false;
      var _previousState  = null;

      // get the previous route info
      $rootScope.$on('$stateChangeSuccess', function($event, toState, toParams, fromState, fromParams){
        if (fromState && fromState.name && (!fromState.data || !fromState.data.authPassThrough)){
          _previousState = { state: fromState, params: fromParams };
        }
      });

      /**
       * @name services.auth.isAuthenticated
       * @memberOf services.auth
       * @returns {Boolean}
       */
      self.isAuthenticated = function(){
        return _authenticated;
      };

      self.isVerified = function(){
        return _verified;
      };

      self.setAppComplete = function(isAppComplete){
        _appComplete = isAppComplete;
      };

      self.setVerified = function(isVerified){
        _verified = isVerified;
      };

      self.setAuthenticated = function(isAuthenticated){
        _authenticated = isAuthenticated;
      };

      self.getPreviousState = function(){
        return _previousState || { state: $state.get('home'), params: null };
      };

      self.performChecks = function($event, toState){
        return self.authorize($event, toState) &&
          self.verify($event, toState) &&
          self.appComplete($event, toState) &&
          self.partnerRoute($event, toState);
      };

      // keep $event, toState order since that's how the args are passed in from events
      self.authorize = function($event, toState){
        var authorized = true;

        if (!toState){
          toState = $state.current;
        }

        var toData = toState.data;

        if (toData &&
            toData.authenticate &&
            !_authenticated
          ){

          if (!toData.authPassThrough){
            _previousState = toState;
          }

          authorized = false;

          // no event will be passed from base route resolve
          if ($event){
            $event.preventDefault();
          }

          var unAuthState = toData.unAuthState;

          if (unAuthState && $state.get(unAuthState)){
            $state.go(unAuthState);
          }
          else {
            $state.go('account.login');
          }

        }

        return authorized;
      };

      self.partnerRoute = function($event, toState) {
        if ($state.getData().partnerGate){
          var isEnabled = configService.isEnabled($state.getData().partnerGate);
          if (!isEnabled) {
            $state.go($state.getData().partnerInvalidState || 'home');
          }
          return isEnabled;
        }
        return true;
      };

      self.verify = function($event, toState){
        var verified = true;

        if (!toState){
          toState = $state.current;
        }

        var toData = toState.data;

        if (toData &&
            toData.verified &&
            !_verified){

          verified = false;
          // no event will be passed from base route resolve
          if ($event){
            $event.preventDefault();
          }

          $state.go('unverified');
        }

        return verified;
      };

      self.appComplete = function($event, toState){
        var appComplete = true;

        if (!toState){
          toState = $state.current;
        }

        var toData = toState.data;

        if (toData &&
            toData.appComplete &&
            !_appComplete){

          appComplete = false;

          // no event will be passed from base route resolve
          if ($event){
            $event.preventDefault();
          }

          $state.go('ob');
        }

        return appComplete;
      };


      var token = null;
      var tokenExp = new Date();

      /**
       * Fetch auth token from the server if current token has expired
       * @name services.auth.getToken
       * @methodOf services.auth
       * @returns {Promise<string>}
       */
      self.getToken = function(){
        if (token && tokenExp.getTime() > (+new Date() + 1000)){
          return $q.when(token);
        }

        return $http.get(config.paths.services + '/auth/token')
          .then(utils.dataOrObject)
          .then(function(response){
            token = response.token;
            tokenExp = new Date(response.expires);

            return token;
          });
      };
    }
  ]);
(function () {

  /**
   * @name services.branch
   * @memberOf services
   * @param $q
   * @constructor
   */
  function BranchService($q) {
    var branchReadyDeferred = $q.defer();

    (function(b,r,a,n,c,h,_,s,d,k){if(!b[n]||!b[n]._q){for(;s<_.length;)c(h,_[s++]);d=r.createElement(a);d.async=1;d.src="https://cdn.branch.io/branch-latest.min.js";k=r.getElementsByTagName(a)[0];k.parentNode.insertBefore(d,k);b[n]=h}})(window,document,"script","branch",function(b,r){b[r]=function(){b._q.push([r,arguments])}},{_q:[],_v:1},"addListener applyCode banner closeBanner creditHistory credits data deepview deepviewCta first getCode init link logout redeem referrals removeListener sendSMS setIdentity track validateCode".split(" "), 0);

    branch.init('key_live_egh4cYidygaBMNd1pTP9hmjfDDoyBtmM', function (err, data) {
      branchReadyDeferred.resolve(data);
    });

    /**
     * @name services.branch.getData
     * @methodOf services.branch
     * @returns {*}
     */
    this.getData = function () {
      return branchReadyDeferred.promise
        .then(function (response) {
          return response;
        });
    };
  }

  BranchService.$inject = ['$q'];

  angular.module('common.services')
    .service('services.branch', BranchService);
}());
angular.module('common.services')
  .factory('services.cost', [
    '$filter',
    function($filter){

      var textConfig = {
        "xForFirstY": "$:x for first :y then full price",
        "xOfPricePlusY": ":x% of price plus $:y",
        "noCost": "No cost",
        "allCost": "All costs",
        "fullPrice": "Full price",
        "free": "Free",
        "ofPrice": "of price",
        "then": "then"
      };

      return {
        getText: getFormattedText,
        getCombined: getPrePostCombined
      };

      // text config schema is currently defined by the costs section of plan.json
      // noCost, fullPrice, free, xOfPricePlusY, xForFirstY, then
      function getFormattedText(benefit, isPostDeductible, verbose){

        var text = 'N/A';
        isPostDeductible = !!isPostDeductible;

        if (benefit){

          // this check trumps any other conditions
          if (benefit.deductible === 'none' || benefit.deductible === 'false'){
            text = getBasicText(benefit, verbose);
          }

          // if it's subject to a deductible and deductible hasn't been met
          else if (!isPostDeductible){

            // if there's a pre deductible benefit, show it
            if (benefit.preQty){
              text = $filter('format')(textConfig.xForFirstY, { x: benefit.preAmt, y: benefit.preQty });
            }
            // otherwise they just pay full price
            else {
              text = textConfig.fullPrice;
            }
          }

          // if it's post deductible, do similar operation to getBasicDisplayText

          else {
            text = getBasicText(benefit, verbose);
          }

        }

        return text;
      }

      function getBasicText(benefit, verbose){
        var text = textConfig.noCost;

        if (benefit.amt){
          switch (benefit.payType){
            case 'copay':
              text = '$' + benefit.amt;
              break;

            case 'coins':
              if (benefit.amt === 100){
                text = textConfig.fullPrice;
              }
              else {
                text = benefit.amt + '%' + (verbose ? ' ' + textConfig.ofPrice : '');
              }
              break;

            case 'dual':
              text = $filter('format')(textConfig.xOfPricePlusY, { x: benefit.amtDual, y: benefit.amt });
              break;
          }
        }

        return text;
      }

      function getPrePostCombined(benefit){
        var pre = getFormattedText(benefit, false, true);
        var post = getFormattedText(benefit, true, true);

        if (pre === post) {
          return pre;
        }

        return pre + ', ' + textConfig.then + ' ' + post;
      }
    }
  ]);
'use strict';

angular.module('common.services')
  .factory('services.date', [
    '$q',
    '$http',
    '$httpParamSerializer',
    '$cacheFactory',
    '$rootScope',
    'config.paths',
    'utils',
    'logger',
    function ($q, $http, $httpParamSerializer, $cacheFactory, $rootScope, paths, utils, logger) {

      var sixtyDays = 5184000000;
      var isoRegex = /^(\d{4})-(\d{2})-(\d{2})/;
      var effectiveDateRequestTimestamp = +new Date();
      var enrollmentPeriodsRequestTimestamp = +new Date();

      /**
       * @typedef {String} DateOnly An ISO format date '2016-01-01' used for DoB, Effective Date, etc..
       */

      /**
       * @name services.date
       */
      var DateService = {

        getDate: getDate,
        isValidEventDate: isValidEventDate,
        isBeforeCutoff: isBeforeCutoff,
        //isBonusEnrollment: isBonusEnrollment,
        //isBonusEnrollmentEligible: isBonusEnrollmentEligible,
        getCutoff: getCutoffDate,
        getStartDate: getStartDate,
        getYears: getYears,

        /**
         * Strip off time/offset from UTC string
         * Useful for dob
         * @name services.date.fromIsoDate
         * @methodOf services.date
         * @param {string} string
         * @returns {Date}
         */
        fromIsoDate: function (string) {
          var ymd = isoRegex.exec(string);
          return new Date(ymd[1], parseInt(ymd[2]) - 1, ymd[3]);
        },

        /**
         * Strip off time information from date object
         * @name services.date.toIsoDate
         * @methodOf services.date
         * @param {Date} date
         * @returns {DateOnly}
         */
        toIsoDate: function (date) {
          if (!_.isDate(date)) {
            return '';
          }

          return [
            date.getFullYear(),
            utils.padNumber(date.getMonth() + 1, 2),
            utils.padNumber(date.getDate(), 2)
          ].join('-');
        },

        /**
         * @name services.date.isSameIsoDate
         * @methodOf services.date
         * @param {DateOnly} dateA
         * @param {DateOnly} dateB
         * @returns {boolean}
         */
        isSameIsoDate: function (dateA, dateB) {
          if (_.isDate(dateA)) {
            dateA = DateService.toIsoDate(dateA);
          }

          if (_.isDate(dateB)) {
            dateB = DateService.toIsoDate(dateB);
          }

          return dateA === dateB;
        },

        /**
         * @typedef {Object} EnrollmentPeriod
         * @property {Date} stride_start_date
         * @property {Date} stride_end_date
         * @property {Date} official_start_date
         * @property {Date} official_end_date
         * @property {string} effective_date
         * @property {string} period_type
         */

        /**
         * @typedef {Object} EnrollmentPeriodDb
         * @property {string} stride_start_date
         * @property {string} stride_end_date
         * @property {string} official_start_date
         * @property {string} official_end_date
         * @property {string} effective_date
         * @property {string} period_type
         */

        ///**
        // * @name services.date.getEnrollmentPeriod
        // * @methodOf services.date
        // * @param {Object} params
        // * @param {boolean} params.onExchange
        // * @param {Date} params.effectiveDate
        // * @param {string} params.state
        // * @returns {Promise<EnrollmentPeriod>}
        // */
        //getEnrollmentPeriod: function(params){
        //  return $http
        //    .get(paths.services + '/enrollment/period', {
        //      params: params,
        //      cache: true
        //    })
        //    .then(utils.dataOrObject)
        //    .then(getPeriodFromDb);
        //},

        /**
         * @name services.date.getEnrollmentPeriods
         * @methodOf services.date
         * @param {Object} params
         * @param {boolean} params.onExchange
         * @param {string} params.state
         * @param {boolean} [params.officialDate=false]
         * @returns {Promise<EnrollmentPeriod[]>}
         */
        getEnrollmentPeriods: function (params) {
          var now = new Date();
          params.m = now.getTimezoneOffset();
          params.officialDate = params.officialDate === true;
          params.state = params.state || 'DEFAULT';

          var path = paths.services + '/enrollment/periods?' + $httpParamSerializer(params);

          // 10 sec cache
          if (now.getTime() - enrollmentPeriodsRequestTimestamp > 1000 * 10) {
            enrollmentPeriodsRequestTimestamp = now.getTime();
            $cacheFactory.get('$http').remove(path);
          }

          return $http
            .get(path, {
              cache: true
            })
            .then(utils.dataOrObject)
            .then(function (periods) {
              // only set oep flag if it's a request for stride enrollment period or if it hasn't been set yet
              if (periods && periods.current && (!params.officialDate || _.isUndefined($rootScope.globals.isOep))) {
                $rootScope.globals.isOep = periods.current.period_type === 'oep';
              }

              return _.mapObject(periods, getPeriodFromDb);
            });
        },

        /**
         * @name services.date.isOepAsync
         * @methodOf services.date
         * @param {Object} params
         * @param {boolean} params.onExchange
         * @param {string} params.state
         * @param {boolean} [params.officialDate=false]
         * @returns {boolean}
         */
        isOepAsync: function (params) {
          return DateService.getEnrollmentPeriods(params)
            .then(function () {
              return $rootScope.globals.isOep;
            });
        },

        /**
         * @name services.date.getEffectiveDate
         * @methodOf services.date
         * @param {Object} params
         * @param {boolean} params.onExchange
         * @param {string} params.state
         * @returns {Promise<DateOnly>}
         */
        getEffectiveDate: function (params) {
          var now = new Date();
          params.m = now.getTimezoneOffset();

          var path = paths.services + '/enrollment/effective?' + $httpParamSerializer(params);

          // 30 sec cache
          if (now.getTime() - effectiveDateRequestTimestamp > 1000 * 30) {
            effectiveDateRequestTimestamp = now.getTime();
            $cacheFactory.get('$http').remove(path);
          }

          return $http
            .get(path, {
              cache: true
            })
            .then(utils.dataOrNull);
        },

        /**
         * @name services.date.missedStrideCutoff
         * @methodOf services.date
         * @param {EnrollmentPeriod} enrollmentPeriod
         * @returns {boolean}
         */
        missedStrideCutoff: function (enrollmentPeriod) {
          var now = +new Date();
          return enrollmentPeriod.stride_end_date.getTime() < now && enrollmentPeriod.official_end_date.getTime() > now;
        },

        /**
         * @name services.date.nearStrideCutoff
         * @methodOf services.date
         * @param {EnrollmentPeriod} enrollmentPeriod
         * @returns {boolean}
         */
        nearStrideCutoff: function (enrollmentPeriod) {
          var now = +new Date();
          var difference = enrollmentPeriod.stride_end_date.getTime() - now;
          return difference > 0 && difference <= 1000 * 60 * 60 * 24 * 5; // 5 day buffer
        },

        /**
         * @name services.date.nearDeadline
         * @methodOf services.date
         * @param {EnrollmentPeriod} enrollmentPeriod
         * @returns {boolean}
         */
        nearDeadline: function (enrollmentPeriod) {
          var now = +new Date();
          var difference = enrollmentPeriod.official_end_date.getTime() - now;
          return difference > 0 && difference <= 1000 * 60 * 60 * 24 * 5; // 5 day buffer
        },

        /**
         * @name services.date.getNextEffectiveDate
         * @methodOf services.date
         * @param {string} isoEffectiveDate
         * @returns {DateOnly} date in iso format
         */
        getNextEffectiveDate: function (isoEffectiveDate) {
          var segments = isoEffectiveDate.split('-');
          return DateService.toIsoDate(new Date(segments[0], segments[1], segments[2]));
        },

        ///**
        // * @name services.date.isOpenEnrollment
        // * @methodOf services.date
        // * @param {Date} date
        // * @param {health.app} applicationModel
        // * @returns {boolean}
        // */
        //// open enrollment for 2015-2016 is Nov 1 - Jan 31
        //isOpenEnrollment: function(date, applicationModel){
        //
        //  var month = date.getMonth();
        //  //var day = date.getDate();
        //
        //  return month === 0 || month >= 10;
        //
        //  // dec and jan are all in
        //  //return (month == 11 || month == 0)
        //  //  // any day after 14th in nov is good
        //  //  || (month == 10 && day > 14)
        //  //  // any day before the 15th in feb, or the 15th before the cutoff time is good
        //  //  || (month == 1 && isBeforeCutoff(date, applicationModel))
        //  //  || isBonusEnrollmentEligible(date, applicationModel)
        //},

        /**
         * @name services.date.getStartDateAge
         * @methodOf services.date
         * @param {Date} dob
         * @param {health.app} applicationModel
         * @returns {Promise<number>}
         */
        getStartDateAge: function (dob, applicationModel) {
          return DateService
            .getEffectiveDate({
              state: applicationModel.getState(),
              onExchange: applicationModel.hasSubsidy()
            })
            .then(function (effectiveDate) {
              return getYears(dob, DateService.fromIsoDate(effectiveDate));
            });
        },

        /**
         * @name services.date.getStartDateAges
         * @param {Array} dobs
         * @param {health.app} applicationModel
         * @returns {Array}
         */
        getStartDateAges: function (dobs, applicationModel) {
          return DateService
            .getEffectiveDate({
              state: applicationModel.getState(),
              onExchange: applicationModel.hasSubsidy()
            })
            .then(function (effectiveDate) {

              return _.map(dobs, function (dob) {
                return getYears(dob, DateService.fromIsoDate(effectiveDate));
              });
            });
        },

        /**
         * @name services.date.getStartDateAgeSync
         * @methodOf services.date
         * @param {Date} dob
         * @param {DateOnly} effectiveDate
         * @returns {number}
         */
        getStartDateAgeSync: function (dob, effectiveDate) {
          return getYears(dob, DateService.fromIsoDate(effectiveDate));
        },

        /**
         * @name services.date.getWeek
         * @methodOf services.date
         * @param {Date} date
         * @param {number} [weekStartIndex=0]
         * @returns {Date[]}
         */
        getWeek: function (date, weekStartIndex) {
          date = getDate(date);

          if (!_.isNumber(weekStartIndex)) {
            weekStartIndex = 0;
          }

          var weekStart = new Date(date.getFullYear(), date.getMonth(), date.getDate() + (weekStartIndex - date.getDay()));

          return _.times(7, function (i) {
            return new Date(weekStart.getFullYear(), weekStart.getMonth(), weekStart.getDate() + i);
          });
        },

        /**
         * @name services.date.getApplyByDate
         * @methodOf services.date
         * @param {Date} startDate
         * @returns {Date}
         */
        getApplyByDate: function (startDate) {
          var day = 15;
          var month = startDate.getMonth();
          var year = startDate.getFullYear();

          // if start date is in january, apply by date will be Dec 15, 2015
          if (month === 0) {
            year -= 1;
          }

          return new Date(year, month - 1, day);
        },

        /**
         * @name services.date.getNextMonth
         * @methodOf services.date
         * @returns {Date}
         */
        getNextMonth: function () {
          var now = new Date();
          return new Date(now.getFullYear(), now.getMonth() + 1);
        }
      };

      return DateService;

      /**
       * @name services.date.getStartDate
       * @methodOf services.date
       * @param {application.model} applicationModel
       * @param {Date} [date]
       * @returns {Date}
       */
      function getStartDate(applicationModel, date) {
        // copy the date so we don't mess with it
        date = getDate(date || new Date());
        var month = date.getMonth();
        var monthAdd = 1;
        var plan = _.isObject(applicationModel) && applicationModel.getPlan();

        // can only purchase plans starting jan 1 in november for 2016 plans
        if (!isBeforeCutoff(date) || ((!plan || plan.planYear === 2016) && month === 10)) {
          monthAdd = 2;
        }

        date.setDate(1);
        date.setMonth(month + monthAdd);

        return new Date(date.getFullYear(), date.getMonth(), 1);
      }

      function isValidEventDate(date) {
        date = getDate(date);

        if (date === false) return date;

        var eventTime = date.getTime();
        var todayTime = +new Date();

        // if today is within 60 days of the event
        return Math.abs(eventTime - todayTime) <= sixtyDays;
      }

      function isBeforeCutoff(date, applicationModel) {
        date = getDate(date);
        return getCutoffDate(date, applicationModel).getTime() > date.getTime();
      }

      function getCutoffDate(date, applicationModel) {
        var cutoffDay = 15;
        var cutoffHours = 18; // this is for Off exchange everywhere
//        var state = applicationModel && applicationModel.getAddress() && applicationModel.getAddress().state || '';
        //var onExchange = applicationModel && !!applicationModel.get().subsidy && !!applicationModel.get().subsidy.amount;

//        if (applicationModel && !onExchange){
//          cutoffDay = 15;
//          cutoffHours = 18;
//        }

        //if (date.getMonth() === 0){
        //  cutoffDay = 31;
        //}

        return new Date(date.getFullYear(), date.getMonth(), cutoffDay, cutoffHours);

        // going to make this local time
        //var utcOffset = isDaylightSavingsTime(date) ? 7 : 8;
//        cutoff.setHours(cutoffHours);
        // 5 minute buffer for folks
//        cutoff.setMinutes(5);
//        return cutoff;
      }

      /**
       * @name services.date.getYears
       * @methodOf services.date
       * @param {Date} refDate
       * @param {Date} date
       * @returns {number}
       */
      function getYears(refDate, date) {
        refDate = getDate(refDate);
        date = getDate(date);

        return Math.floor((date.getTime() - refDate.getTime()) / 1000 / 60 / 60 / 24 / 365.25);
      }

      /**
       * this method will parse a date string or return the date object passed in
       * @name services.date.getDate
       * @methodOf services.date
       * @param {Date} [date]
       * @returns {Date}
       */
      function getDate(date) {
        if (!angular.isDate(date)) {

          if (typeof date === 'string' && !isNaN(Date.parse(date))) {
            date = new Date(date);
          }

          else {
            return false;
          }
        }

        return date;
      }

      /**
       * @param {EnrollmentPeriodDb} period
       * @returns {EnrollmentPeriod}
       */
      function getPeriodFromDb(period) {
        /// this logic needs to be on the client for timezone reasons
        var officialStartDate = DateService.fromIsoDate(period.official_start_date);
        var officialEndDate = DateService.fromIsoDate(period.official_end_date);
        officialEndDate.setHours(23);
        officialEndDate.setMinutes(59);
        officialEndDate.setSeconds(59);

        return {
          stride_start_date: new Date(period.stride_start_date),
          stride_end_date: new Date(period.stride_end_date),
          effective_date: period.effective_date,
          period_type: period.period_type,
          official_start_date: officialStartDate,
          official_end_date: officialEndDate
        };
      }
    }
  ]);
angular.module('common.services')
  .service('services.email', [
    '$http',
    'config.paths',
    function($http, paths){
      this.sendToMany = function(action, inputText, options, limit){
        return $http.post(paths.services + '/email/many/' + action, {
          emails: parseEmailsFromInput(inputText).slice(0, limit),
          options: options
        })
      };

      // addresses is a textarea or text input of common listing types for emails
      // taken from http://stackoverflow.com/a/9731293
      function parseEmailsFromInput(inputText){
        return inputText
          .replace(/[^,;]*.?</g,'')
          .replace(/>/g,'')
          .replace(/[,; ]{1,}/g, '\n')
          .replace(/[\n]{2,}/g, '\n')
          .split('\n')
      }
    }
  ]);
angular.module('common.services')
  .factory('services.hsa', [
    'services.tax',
    function (taxService) {
      var singleLimit = 3350;
      var familyLimit = 6650;
//
//      function getRecommendedAmount(plan, familySize){
//        return Math.min(plan.totalCost, familySize > 1 ? familyLimit : singleLimit);
//      }

//      function getHsaSavings(filingStatus, familySize, income, plan){
//        var rate = getTaxRate(filingStatus, income);
//        var amount = getRecommendedAmount(plan, familySize);
//
//        return (amount / (1 - rate)) - amount;
//      }

      return {
        getTaxRate: taxService.getTaxRate,
        getBracket: taxService.getBracket,
        // TODO: make sure this math is right
        getMaxSavings: function(filingStatus, familySize, income, maxCost){
          var rate = taxService.getTaxRate(filingStatus, income);
          //var maxCost = 0;
          var maxHsa = familySize > 1 ? familyLimit : singleLimit;

          maxHsa = Math.min(maxHsa, maxCost);

          return {
            amount: maxHsa,
            savings: (maxHsa / (1 - rate)) - maxHsa
          };
        }
      };
    }
  ]);
angular.module('common.services')
  .service('services.htmlClass', [
    '$window',
    '$timeout',
    '$rootScope',
    function($window, $timeout, $rootScope){
      var $html = $('html');
      var footer = $('footer');
      var footerVisibleClass = 'footer-visible';

      $($window).on('scroll', setFooterVisible);
      $rootScope.$on('delayed-resize', setFooterVisible);

      // need to wait for digest to complete after
      // content is loaded before checking dimensions
      // this also handles initial load
      $rootScope.$on('$viewContentLoaded', function(){
        $timeout(setFooterVisible);
      });

      function setFooterVisible(){
        if (footer.is(':visible') && footer.offset().top < $window.innerHeight + $window.scrollY) {
          $html.addClass(footerVisibleClass);
        }
        else {
          $html.removeClass(footerVisibleClass);
        }
      }

      this.add = function(classes){
        $html.addClass(classes);
      };

      this.remove = function(classes){
        $html.removeClass(classes);
      };

      this.checkFooter = setFooterVisible;
    }
  ]);
(function () {
  /**
   * Logger service.
   * @name logger
   * @memberOf services
   * @param {ng.$http} $http
   * @param {ui.router.state.$state} $state
   * @param {config.paths} paths
   */
  var Logger = function ($http, $state, paths) {

    /**
     * Log an error to the couchDB error collection.
     * @name logger.error
     * @methodOf logger
     * @param {object} options
     * @returns {HttpPromise} promise
     */
    this.error = function (options) {
      if (_.isString(options)) {
        options = { message: options };
      }
      if (!_.isObject(options)) {
        options = {};
      }

      return $http.post(paths.services + '/error', _.defaults(options, {
        path: $state.href($state.current),
        statusCode: 500
      }));
    };
  };
  // can remove this once closure compiler is working
  Logger.$inject = ['$http', '$state', 'config.paths'];

  angular.module('common.services')
    .service('logger', Logger);
}());



angular.module('common.services')
  .service('services.mediaQuery', [

    /**
     * @name services.mediaQuery
     */

      function(){

      var $mqs = $('#mqs');

      /**
       * @name services.mediaQuery.smallOnly
       * @methodOf services.mediaQuery
       * @returns {boolean}
       */
      this.smallOnly = function(){
        return isVisible('.small-only');
      };

      /**
       * @name services.mediaQuery.mediumDown
       * @methodOf services.mediaQuery
       * @returns {boolean}
       */
      this.mediumDown = function(){
        return isVisible('.small-only') || isVisible('.medium-only');
      };

      /**
       * @name services.mediaQuery.mediumUp
       * @methodOf services.mediaQuery
       * @returns {boolean}
       */
      this.mediumUp = function(){
        return isVisible('.medium-up');
      };

      /**
       * @name services.mediaQuery.largeUp
       * @methodOf services.mediaQuery
       * @returns {boolean}
       */
      this.largeUp = function(){
        return isVisible('.large-up');
      };

      /**
       * @param {string} selector
       * @returns {boolean}
       */
      function isVisible(selector){
        return $(selector, $mqs).css('display') === 'block';
      }
    }
  ]);
angular.module('common.services')
  .factory('services.promo', [
    '$q',
    '$http',
    '$location',
    'config.paths',
    function($q, $http, $location, paths){

      return {
        logVisit: function(){
          if ($location.search().ref){
            return $http.get(paths.services + '/promo/visit/' + $location.search().ref)
          }

          return $q.when({});
        },

        // TODO: these code methods will need the promo id added in
        // the future when we support multiple promotions on the API layer
        getCode: function(){
          return $http.get(paths.services + '/promo/code')
            .then(function(response){
              return response.data && response.data.promoCode;
            });
        },

        redeemFlu: function(){
          return $http.get(paths.services + '/promo/redeem/flu')
            .then(function(response){
              return response || {};
            });
        },

        getStats: function(code){
          return $http.get(paths.services + '/promo/stats/' + code)
            .then(function(response){
              return response.data || {};
            });
        }
      };

    }
  ]);
angular.module('common.services')
  .service('services.share', [
    '$q',
    '$window',
    '$http',
    '$timeout',
    'config',
    'services.tracking',
    function($q, $window, $http, $timeout, config, trackingService){

      var fbReady = $q.defer();
      var twitterReady = $q.defer();

      (function fbLoop(){
        if ($window.FB){
          fbReady.resolve();

          $window.FB.Event.subscribe('edge.create', function(){
            trackingService.event('social', 'like', 'facebook');
          });
          $window.FB.Event.subscribe('edge.remove', function(){
            trackingService.event('social', 'unlike', 'facebook');
          });
        }
        else {
          $timeout(fbLoop, 200);
        }
      }());

      (function twitterLoop(){
        if ($window.twttr){
          $window.twttr.events.bind('click', function(e){
            trackingService.event('social', 'click', 'twitter');
          });

          $window.twttr.events.bind('tweet', function(e){
            trackingService.event('social', 'share', 'twitter');
          });

          twitterReady.resolve();
        }
        else {
          $timeout(twitterLoop, 200);
        }
      }());

      this.getFeedLink = function(options) {
        var link = 'http://www.facebook.com/dialog/feed'
          + '?app_id='          + config.fb.appId
          + '&picture='         + encodeURIComponent(options.picture || 'https://www.stridehealth.com/assets/img/logo/logo-fb.png')
          + '&redirect_uri='    + encodeURIComponent('https://facebook.com')
          + '&link='            + encodeURIComponent(options.url || 'https://www.stridehealth.com')
          + '&name='            + encodeURIComponent(options.name || 'Stride Health')
          + '&description='     + encodeURIComponent(options.description || 'We make health insurance human.')
          + '&display=popup';

        // caption will default to www.stridehealth.com if it's not present
        if (options.caption){
          link += '&caption=' + encodeURIComponent(options.caption);
        }

        return link;
      };

      this.getTweetLink = function(options){
        return 'https://twitter.com/share'
          + '?url=' + encodeURIComponent(options.url)
          + '&text=' + encodeURIComponent(options.text || '');
      };

      this.openPopup = function($event){
        $event.preventDefault();
        window.open($event.target.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600')
      };

      /**
       * @type {Promise}
       */
      this.fbReady = fbReady.promise;
      /**
       * @type {Promise}
       */
      this.twitterReady = twitterReady.promise;
    }
  ]);
(function () {

  /**
   * @name services.subscription
   * @memberOf services
   * @param $http
   * @param config
   * @constructor
   */

  function SubscriptionService($http, config) {
    var baseUrl = config.paths.services;

    this.subscribe = function (email, lists) {
      return $http.post(baseUrl + '/drive/subscription', {
        email: email,
        lists: lists
      });
    };
  }

  SubscriptionService.$inject = ['$http', 'config'];

  angular.module('common.services')
    .service('services.subscription', SubscriptionService);
}());
angular.module('common.services')
  .service('services.subsidy', [
    '$q',
    '$http',
    'config.paths',
    'logger',
    'utils',
    function ($q, $http, paths, logger, utils) {
      var basePath = paths.services + '/subsidy';

      /**
       * @name services.subsidy
       */

      /**
       * @name services.subsidy.getEstimate
       * @methodOf services.subsidy
       * @param {string} state
       * @param {number} income
       * @param {number} familySize
       * @param {string} applicants
       * @param {number} benchmarkPremium
       * @returns {Promise.<SubsidyEstimate>}
       */
      this.getEstimate = function (state, income, familySize, applicants, benchmarkPremium) {
        return $http
          .get(basePath + '/estimate', {
            params: {
              state: state,
              income: income,
              familySize: familySize,
              applicants: applicants,
              benchmarkPremium: benchmarkPremium
            },
            cache: true
          })
          .then(utils.dataOrObject)
          .catch(function (err) {
            logger.error({
              error: err
            });
            return $q.reject(err);
          });
      };

      /**
       * @name services.subsidy.checkApplicants
       * @param {string[]} eligibilities
       * @param estimate
       * @param {Member[]} members
       * @returns {SubsidyApplicantEligibilities}
       */
      this.checkApplicants = function (eligibilities, estimate, members) {
        var medicaidMembers = [];
        var subsidyMembers = [];
        var ineligibleMembers = [];
        var subsidyType = 'someMedicaid';

        _.forEach(members, function (member, index) {
          var eligibility = eligibilities[index];

          if (eligibility === 'medicaid') {
            medicaidMembers.push(member);
          }
          else if (eligibility === 'subsidy' && estimate.aptc > 0) {
            subsidyMembers.push(member);
          }
          else {
            ineligibleMembers.push(member);
          }
        });

        if (medicaidMembers.length === members.length) {
          subsidyType = 'allMedicaid';
        }
        else if (subsidyMembers.length === members.length) {
          subsidyType = 'allSubsidy';
        }
        else if (ineligibleMembers.length === members.length) {
          subsidyType = 'noSavings';
        }

        return {
          medicaidMembers: medicaidMembers,
          subsidyMembers: subsidyMembers,
          ineligibleMembers: ineligibleMembers,
          subsidyType: subsidyType
        };
      };

      /**
       * @name services.subsidy.getLatestEligibilities
       * @methodOf services.subsidy
       * @param {CoveredMemberStatus[]} oldMemberStatuses
       * @param {CoveredMemberStatus[]} newMemberStatuses
       * @returns {string[]}
       */
      this.getLatestEligibilities = function(oldMemberStatuses, newMemberStatuses){
        return _.chain(newMemberStatuses.concat(oldMemberStatuses))
          .uniq(function(status){ return _.get(status, 'member.id'); })
          .pluck('eligibility')
          .value();
      };

      /**
       * @name services.subsidy.getPenalty
       * @methodOf services.subsidy
       * @param {number} income
       * @param {string} applicants
       * @returns {Promise.<number>}
       */
      this.getPenalty = function (income, applicants) {

        return $http
          .get(basePath + '/penalty', {
            params: {
              income: income,
              applicants: applicants
            },
            cache: true
          })
          .then(utils.dataOrZero)
          .catch(function (err) {
            logger.error({
              error: err
            });

            return $q.reject(err);
          });
      };

      /**
       * @name services.subsidy.getMaxQualifyingIncome
       * @methodOf services.subsidy
       * @param {string} state
       * @param {number} familySize
       * @param {number} benchmarkPremium
       * @returns {Promise.<number>}
       */
      this.getMaxQualifyingIncome = function (state, familySize, benchmarkPremium) {
        return $http
          .get(basePath + '/max-income', {
            params: {
              state: state,
              familySize: familySize,
              benchmarkPremium: benchmarkPremium
            },
            cache: true
          })
          .then(utils.dataOrZero)
          .catch(function (err) {
            logger.error({
              error: err
            });

            return $q.reject(err);
          });
      };
    }
  ]);

/**
 * @typedef {Object} SubsidyEstimate
 * @property {{ UUID: string }} eligibility
 * @property {Object} estimate
 * @property {number} estimate.aptc
 * @property {number} estimate.fpl
 * @property {number} estimate.csr
 * @property {boolean} estimate.medicaid
 * @property {StatePlanProgram} estimate.statePlanProgram
 */

/**
 * @typedef {Object} StatePlanProgram
 * @property {string} name
 * @property {number} fplMin
 * @property {number} fplMax
 * @property {string} qualifyText
 */

/**
 * @typedef {Object} SubsidyApplicantEligibilities
 * @property {string} subsidyType
 * @property {Member[]} medicaidMembers
 * @property {Member[]} subsidyMembers
 * @property {Member[]} ineligibleMembers
 */

/**
 * @typedef {Object} CoveredMemberStatus
 * @property {Member} member
 * @property {string} eligibility
 */
(function(){

  // TODO: move this logic to node and make these service requests

  /**
   * @name services.tax
   * @constructor
   */
  function Svc(){
    var max = Number.MAX_VALUE;

    var statuses = {
      single: [
        [0, 9225],
        [9225, 37450],
        [37450, 90750],
        [90750, 189300],
        [189300, 411500],
        [411500, 413200],
        [413200, max]
      ],

      jointly: [
        [0, 18450],
        [18450, 74900],
        [74900, 151200],
        [151200, 230450],
        [230450, 411500],
        [411500, 464850],
        [464850, max]
      ],

      separately: [
        [0, 9225],
        [9225, 37450],
        [37450, 75600],
        [75600, 115225],
        [115225, 205750],
        [205750, 232425],
        [232425, max]
      ],

      headOfHousehold: [
        [0, 13150],
        [13150, 50200],
        [50200, 129600],
        [129600, 209850],
        [209850, 411500],
        [411500, 439000],
        [439000, max]
      ]
    };

    // http://taxes.about.com/od/deductionscredits/qt/standard.htm
    var standardDeductions = {
      single: 6300,
      headOfHousehold: 9250,
      jointly: 12600,
      separately: 6300,
      widow: 12600,
      dependent: 1050
    };

    var taxRates = [
      0.10,
      0.15,
      0.25,
      0.28,
      0.33,
      0.35,
      0.396
    ];

    var additionalAmounts = {
      single: [
        0,
        922.50,
        5156.25,
        18481.25,
        46075.25,
        119401.25,
        119996.25
      ],
      headOfHousehold: [
        0,
        1315,
        6872.50,
        26722.50,
        49192.50,
        115737,
        125362
      ],
      separately: [
        0,
        922.50,
        5156.25,
        14693.75,
        25788.75,
        55662,
        64989.25
      ],
      jointly: [
        0,
        1845,
        10312.50,
        29387.50,
        51577.50,
        111324,
        129996.50
      ]
    };

    var caTaxRates = [
      {
        rate: 0.01,
        range: [0, 7750]
      },
      {
        rate: 0.02,
        range: [7750, 18372]
      },
      {
        rate: 0.04,
        range: [18372, 28996]
      },
      {
        rate: 0.06,
        range: [28996, 40251]
      },
      {
        rate: 0.08,
        range: [40251, 50870]
      },
      {
        rate: 0.093,
        range: [50870, 259845]
      },
      {
        rate: 0.103,
        range: [259845, 311813]
      },
      {
        rate: 0.113,
        range: [311813, 519688]
      },
      {
        rate: 0.123,
        range: [519688, max]
      }
    ];

    function doubleBracket(bracket){
      return {
        rate: bracket.rate,
        range: [bracket.range[0] * 2, bracket.range[1] * 2]
      };
    }

    var stateTaxRates = {
      CA: {
        single: caTaxRates,
        separately: caTaxRates,
        jointly: _.map(caTaxRates, doubleBracket),
        headOfHousehold: _.map(caTaxRates, doubleBracket)
      }
    };

    /**
     * @name services.tax.getTaxRate
     * @methodOf services.tax
     * @param {string} filingStatus
     * @param {number} income
     * @returns {number}
     */
    this.getTaxRate = function(filingStatus, income){
      var bracket = this.getBracket(filingStatus, income);
      return taxRates[bracket];
    };

    /**
     * @name services.tax.getBracket
     * @methodOf services.tax
     * @param {string} filingStatus
     * @param {number} income
     * @returns {number}
     */
    this.getBracket = function(filingStatus, income){
      var brackets = statuses[filingStatus];
      var index = _.findIndex(brackets, function(bracket){
        // if single and income is 9225, it will choose the correct bracket index 0 since it finds the first match
        return income >= bracket[0] && income <= bracket[1];
      });

      return  index > -1 && index || 0;
    };

    /**
     * @name services.tax.getSeTax Calculate the Social Security and Medicare taxes owed http://taxes.about.com/od/soleproprietorships/a/self-employment-tax.htm
     * @methodOf services.tax
     * @param {number} netIncome
     * @returns {number}
     */
    this.getSeTax = function(netIncome){
      if (netIncome <= 0){
        return 0;
      }

      // 92.35% factor takes into account that part of the Social Security and Medicare taxes are a deductible business expense
      var netSelfEmploymentIncome = netIncome * 0.9235;

      // $118,500 is maximum amount of income subject to the Social Security tax
      var ssTaxBase = Math.min(118500, netSelfEmploymentIncome);
      var ssTaxAmount = ssTaxBase * 0.124;

      // all net income is subject to medicare tax
      var medicareTaxAmount = netSelfEmploymentIncome * 0.029;

      return ssTaxAmount + medicareTaxAmount;
    };

    /**
     * @name services.tax.getStateTax
     * @methodOf services.tax
     * @param {string} stateCode
     * @param {string} filingStatus
     * @param {number} taxableIncome
     * @returns {number}
     */
    this.getStateTax = function(stateCode, filingStatus, taxableIncome){
      var rates = stateTaxRates[stateCode];

      if (!rates || !rates[filingStatus]){
        return 0;
      }

      var bracket = _.find(rates[filingStatus], function(b){
        return taxableIncome >= b.range[0] && taxableIncome < b.range[1];
      });

      if (!bracket){
        return 0;
      }

      return taxableIncome * bracket.rate;
    };

    /**
     * @name services.tax.getTotalSeTax Self-employment tax + Income tax
     * @methodOf services.tax
     * @param {number} netIncome
     * @param {Member[]} family
     * @param {string} status
     * @param {string} stateCode
     * @param {number} [taxRate]
     * @param {number} [periodInDays=365]
     * @returns {*}
     */
    this.getTotalSeTax = function(netIncome, family, status, stateCode, taxRate, periodInDays){
      if (netIncome <= 0){
        return 0;
      }

      var seTax = this.getSeTax(netIncome);
      var periodMultiplier = (periodInDays || 365) / 365;

      var standardDeduction = (standardDeductions[status] || standardDeductions.single) * periodMultiplier;
      var hasSpouse = !!_.findWhere(family, { type: 'spouse' });


      // exclude the spouse if they aren't filing jointly
      // http://www.irs.gov/publications/p17/ch03.html
      var personalExemptionCount = hasSpouse && status !== 'jointly' ? family.length - 1 : family.length;

      // http://taxes.about.com/od/preparingyourtaxes/a/personal_exempt.htm
      var personalExemptionAmount = personalExemptionCount * 4000 * periodMultiplier;

      // http://taxes.about.com/od/paymentoptions/a/estimated_tax_3.htm
      var taxableIncome = netIncome - (seTax / 2) - standardDeduction - personalExemptionAmount;

      // allow tax rate to be passed in, since income may not always be for the year
      taxRate = taxRate || this.getTaxRate(status, taxableIncome * periodMultiplier);

      var bracketIndex = taxRates.indexOf(taxRate);
      var bracket = statuses[status][bracketIndex];
      var addition = additionalAmounts[status][bracketIndex] * periodMultiplier;
      var federalIncomeTax = Math.max(0, (taxableIncome - (bracket[0] * periodMultiplier)) * taxRate + addition);
      var stateIncomeTax = this.getStateTax(stateCode, status, taxableIncome);

      return  {
        selfEmployment: seTax,
        federal: federalIncomeTax,
        state: stateIncomeTax,
        total: (seTax + federalIncomeTax + stateIncomeTax).toFixed(2)
      };
    };
  }

  angular.module('common.services')
    .service('services.tax', Svc);
}());
(function () {

  /**
   * @name services.texting
   * @memberOf services
   * @param $http
   * @param config
   * @constructor
   */
  function TextingService($http, config) {
    var baseUrl = config.paths.services;

    this.sendText = function (phoneNumber, referringLink) {
      return $http.post(baseUrl + '/drive/sms', {
        phone: phoneNumber,
        referringLink: referringLink
      });
    };
  }

  TextingService.$inject = ['$http', 'config'];

  angular.module('common.services')
    .service('services.texting', TextingService);
}());
(function () {

  /**
   * @name services.tracking
   * @memberOf services
   * @param {ng.$window} $window
   * @param {ng.$location} $location
   * @param {utils} utils
   * @param {mixpanel} mixpanel
   * @param {config.service} configService
   * @constructor
   */
  function TrackingService($window, $location, $http, $q, utils, paths, mixpanel, configService) {

    var self = this;
    var serviceBase = paths.services;

    /**
     * @name services.tracking.propEnum
     * @memberOf services.tracking
     * @type {{doctorAdd: string, age: string, gender: string, householdSize: string, drugs: string, subsidy: string, purchasedRank: string}}
     */
    this.propEnum = {
      action: {
        signup: 'Signed Up'
      },
      doctorAdd: 'Doctors Added',
      age: 'Age',
      gender: 'Gender',
      householdSize: 'Household Size',
      drugs: 'Prescriptions Added',
      subsidy: 'Eligible for Subsidy',
      eligibilityChange: 'Eligibility Changed',
      purchasedRank: 'Purchased Plan Stride Rank',
      flushotSent: 'Flu Shot Coupon Sent',
      dentalDetail: 'Dental plan viewed',
      dentalMembers: 'Dental Members',
      dentists: 'Dentists Added',
      cartAction: 'Shopping Cart Action',
      cartView: 'Shopping Cart View',
      purchaseComplete: 'Purchase Complete',
      dentalPurchased: 'Dental Plan Purchased',
      incomeDelta: 'Income Estimate Delta (new - old)',
      obIncome: 'Income Entered',
      deductionEntry: 'Deductions Entered',
      homepage: 'Home Page Viewed',
      blogViewed: 'Blog post viewed',
      taskList: 'Task List Viewed',
      docUploaded: 'Document Uploaded',
      getstarted: {
        hasHealthInsurance: 'Get Started: Info: hasInsurance?',
        gender: 'Gender',
        age: 'Age',
        recommendedServices: 'Recommended Services Seen',
        recommendedServicesSel: 'Recommended Services Selected',
        suggestedServices: 'Suggested Services Seen',
        suggestedServicesSel: 'Suggested Services Selected',
        selectedValue: 'Total Value of Services Selected'
      },
      bor: {
        landing: {
          cta: 'Landing Page CTA Clicked'
        },
        questions: {
          selected: 'Questions Selected',
          custom: 'Custom Text Entered'
        },
        funnel: {
          action: 'BOR: Action',
          intro: 'BOR: Intro',
          identity: 'BOR: Confirm Identity',
          esign: 'BOR: e-Sign',
          confirm: 'BOR: Confirmation'
        }
      },
      landingViewed: 'Landing Page Viewed'
    };

    /**
     * Parse ref code from query string. If no ref is present, looks for utm parameters
     * @name services.tracking.getRefCode
     * @methodOf services.tracking
     * @returns {string}
     */
    this.getRefCode = function () {
      var mediumKey = 'utm_medium';
      var contentKey = 'utm_content';
      var queryParams = $location.search();
      var ref = '';

      // look for the ref parameter in the querystring first
      if (queryParams.ref && queryParams.ref.length) {
        ref = queryParams.ref;
      }
      // if that's empty, try looking for utm keys
      else if (queryParams[mediumKey] && queryParams[mediumKey].length) {
        ref = queryParams[mediumKey] + '-' + queryParams.utm_source + '-' + queryParams.utm_campaign;

        if (queryParams[contentKey] && queryParams[contentKey]) {
          ref += '-' + queryParams[contentKey];
        }
      }

      return ref;
    };

    /**
     * Parse site from the host. Falls back to www if the subdomain is bare e.g. https://stridehealth.com
     * @name services.tracking.getSite
     * @methodOf services.tracking
     * @returns {string}
     */
    this.getSite = function () {
      var site = $window.location.hostname.split('.')[0];
      // if we're on stridehealth.com directly, manually set to www
      // otherwise, we can default to the first value whether it's sidecar, dev, www, or localhost
      if (site === 'stridehealth') {
        site = 'www';
      }

      return site;
    };

    /**
     * Sets the page in GA and sends the pageview
     * @name services.tracking.pageView
     * @methodOf services.tracking
     * @returns {void}
     */
    this.pageView = function () {
      if (typeof $window.ga !== 'undefined') {
        ga('set', 'page', $location.path());
        ga('send', 'pageview');
      }
    };

    /**
     * Track event to GA
     * @name services.tracking.event
     * @methodOf services.tracking
     * @param {string} [category='']
     * @param {string} [action='click']
     * @param {string} [label]
     * @param {number} [value]
     * @returns {void}
     */
    this.event = function (category, action, label, value) {

      if (_.isArray($window.dataLayer)) {

        var params = {

          hitType: 'event',
          eventCategory: category || '',
          eventAction: action || 'click'
        };

        // optional
        if (angular.isString(label)) {
          params.eventLabel = label;
        }

        // optional
        if (angular.isNumber(value)) {
          params.eventValue = value;
        }

        $window.dataLayer.push({event: 'gaEvent', gaEvent: params});
      }

      // mixpanel event tracking
      mixpanel.track(utils.snakeToTitle(category) || category, {
        action: action || "None",
        label: label || "None",
        value: value || "None"
      });
    };

    /**
     * @name services.tracking.mixpanelEvent
     * @methodOf services.tracking
     * @param {string} name
     * @param {Object} [properties={}]
     */
    this.mixpanelEvent = function (name, properties) {
      // don't send to GA for now
      //if (_.isArray($window.dataLayer)){
      //  var params = {
      //    hitType: 'event',
      //    eventCategory: name,
      //    eventAction: 'click'
      //  };
      //  $window.dataLayer.push({ event: 'gaEvent', gaEvent: params });
      //}

      if (mixpanel && _.isFunction(mixpanel.track)) {
        mixpanel.track(name, properties || {});
      }
    };

    /**
     * @name services.tracking.setPeopleProps
     * @methodOf services.tracking
     * @param {Object} props
     * @param {boolean} [setOnce=false]
     */
    this.setPeopleProps = function (props, setOnce) {
      if (!mixpanel) {
        return;
      }

      if (_.isFunction(mixpanel.register)) {
        if (setOnce) {
          mixpanel.register_once(props);
        }
        else {
          mixpanel.register(props);
        }
      }

      if (mixpanel.people && _.isFunction(mixpanel.people.set)) {

        if (setOnce) {
          mixpanel.people.set_once(props);
        }
        else {
          mixpanel.people.set(props);
        }

      }
    };

    /**
     * @name services.tracking.setPeopleProp
     * @methodOf services.tracking
     * @param {string} key
     * @param {*} value
     */
    this.setPeopleProp = function (key, value) {
      if (!mixpanel) {
        return;
      }

      var prop = {};
      prop[key] = value;

      if (_.isFunction(mixpanel.register)) {
        mixpanel.register(prop);
      }

      if (mixpanel && mixpanel.people && _.isFunction(mixpanel.people.set)) {
        mixpanel.people.set(prop);
      }
    };

    /**
     * @name services.tracking.incrementPeopleProp
     * @methodOf services.tracking
     * @param {string} prop
     * @param {number} [value]
     */
    this.incrementPeopleProp = function (prop, value) {
      if (mixpanel && mixpanel.people && _.isFunction(mixpanel.people.increment)) {
        if (value) {
          mixpanel.people.increment(prop, value);
        } else {
          mixpanel.people.increment(prop);
        }

      }
    };

    /**
     * Wrap mixpanel's alias function to also set props for the user
     * @name services.tracking.alias
     * @methodOf services.tracking
     * @param {user.model} userModel
     * @returns {HttpPromise<boolean>}
     */
    this.alias = function (userModel) {
      if (mixpanel && _.isFunction(mixpanel.alias)) {
        var id = userModel.getId();
        mixpanel.alias(id);
        self.setPeopleProps({
          $id: id,
          $email: userModel.email,
          $name: userModel.email
        });

        return $http.post(serviceBase + '/user/alias', {is_aliased: true})
          .then(function (response) {
            var success = response.status === 200;
            userModel.isAliased = success;
            return success;
          });
      }
      return $q.reject('Mixpanel.alias unavailable');
    };

    /**
     * Alias a user who's info isn't set yet, identify if user is aliased
     * @name services.tracking.tryAlias
     * @methodOf services.tracking
     * @param {user.model} userModel
     * @returns {HttpPromise<boolean>}
     */
    this.tryAlias = function (userModel) {
      if (!mixpanel || !_.isFunction(mixpanel.identify)){
        return $q.reject('Mixpanel not ready');
      }

      if (!userModel.isLoggedIn){
        return $q.reject('User not logged in');
      }

      if (!userModel.isAliased) {
        return self.alias(userModel);
      }

      self.mixpanel.identify(userModel.getId());
      return $q.resolve(true);
    };

    /**
     * Pushes virtual page view event to dataLayer
     * @name services.tracking.virtualPageView
     * @methodOf services.tracking
     * @param {string} [url]
     * @returns {void}
     */
    this.virtualPageView = function (url) {
      url = url || $location.url();

      if (_.isArray($window.dataLayer)) {

        var payload = {
          event: 'virtualPageView',
          virtualUrl: url,
          site: self.getSite()
        };

        var ref = self.getRefCode();
        if (ref) {
          payload.ref = ref;
        }

        $window.dataLayer.push(payload);
      }

      mixpanel.track('Page View', {
        pageview_url: url
      });
    };

    /**
     * Convenience method for tracking landing page view events
     * @name services.tracking.trackLP
     * @methodOf services.tracking
     * @param {string} pageName
     * @returns {void}
     */
    this.trackLP = function (pageName) {
      self.mixpanelEvent(self.propEnum.landingViewed, {
        Page: pageName,
        Site: configService.getBrand()
      });
    };

    // expose this directly for convenience
    /**
     * @name services.tracking.mixpanel
     * @memberOf services.tracking
     * @type {mixpanel}
     */
    this.mixpanel = mixpanel;
  }

  TrackingService.$inject = ['$window', '$location', '$http', '$q', 'utils', 'config.paths', '$mixpanel', 'config.service'];

  angular.module('common.services')
    .service('services.tracking', TrackingService);
}());
(function(){

  /**
   * Utility methods used throughout the application
   * @name utils
   * @param {ng.$location} $location
   * @param {function} $timeout
   * @constructor
   * @ngInject
   */
  function Utils($location, $timeout){
    var self = this;
    var toDashStrip = /[^a-z0-9 \-+]/g;
    var toDashReplace = /[ \-]+/g;

    /**
     * @name utils.uuid
     * @methodOf utils
     * @returns {string}
     */
    this.uuid = function(){
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c === 'x' ? r : (r&0x3|0x8);
        return v.toString(16);
      });
    };

    /**
     * Adds an iterator test on top of underscore's indexOf
     * @name utils.indexOf
     * @methodOf utils
     * @param {Array} array
     * @param {function} test
     * @returns {number}
     */
    this.indexOf = function(array, test) {
      // delegate to standard indexOf if the test isn't a function
      if (!_.isFunction(test)) {
        return _.indexOf(array, test);
      }
      // otherwise, look for the index
      for (var x = 0; x < array.length; x++) {
        if (test(array[x])) {
          return x;
        }
      }
      // not found, return fail value
      return -1;
    };

    ///**
    // * Adds an iterator test on top of underscore's lastIndexOf
    // * @name utils.lastIndexOf
    // * @methodOf utils
    // * @param {Array} array
    // * @param {function} test
    // * @returns {number}
    // */
    //this.lastIndexOf = function(array, test) {
    //  // delegate to standard indexOf if the test isn't a function
    //  if (!_.isFunction(test)) {
    //    return _.lastIndexOf(array, test);
    //  }
    //  // otherwise, look for the index
    //  var x = array.length;
    //  // start from the back
    //  while (--x) {
    //    if (test(array[x])) {
    //      return x;
    //    }
    //  }
    //  // not found, return fail value
    //  return -1;
    //};

    /**
     * Move an item in the array from the oldIndex to the newIndex
     * If newIndex > array.length, extend the length of the array to accommodate.
     * **Modifies the array.**
     * @name utils.move
     * @methodOf utils
     * @param {Array} array
     * @param {number} oldIndex
     * @param {number} newIndex
     */
    this.move = function (array, oldIndex, newIndex) {
      if (newIndex >= array.length) {
        array.length = newIndex + 1;
      }

      array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
    };

    /**
     * Removes the first item that satisfies the test function from the array.
     * **Modifies the array.**

     * @name utils.remove
     * @methodOf utils
     * @param {Array} array
     * @param {function|object} test
     */
    this.remove = function(array, test){
      var index = _.findIndex(array, test);

      if (index > -1){
        array.splice(index, 1);
      }
    };

    /**
     * Capitalize the first letter of every word
     * @name utils.capitalize
     * @methodOf utils
     * @param {string} str
     * @returns {string}
     */
    this.capitalize = function(str){
      return _.map(str.split(' '), function(word){
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
      }).join(' ');
    };

    /**
     * Get the absolute url without the path or any trailing /
     * Use lastIndexOf to avoid url at '/' from returning 'http:'
     * @name utils.getAbsBaseUrl
     * @methodOf utils
     * @returns {string}
     */
    this.getAbsBaseUrl = function(){
      return $location.absUrl().substring(0, $location.absUrl().lastIndexOf($location.url()));
    };

    /**
     * Set the key's value to `toValue` within the digest cycle.
     * Then toggle that value back to `oldValue`
     * @name utils.toggleValue
     * @methodOf utils
     * @param {Object} obj
     * @param {string} key
     * @param {*} toValue
     * @param {*} [oldValue=obj.key]
     */
    this.toggleValue = function(obj, key, toValue, oldValue){
      if (_.isUndefined(oldValue)){
        oldValue = obj[key];
      }

      $timeout(function(){
        obj[key] = toValue;
      });

      $timeout(function(){
        obj[key] = oldValue;
      }, 10);
    };

    /**
     * Shortcut for calling `Utils.toggleValue` with true / false
     * @name utils.toggleBool
     * @methodOf utils
     * @param {Object} obj
     * @param {string} key
     */
    this.toggleBool = function(obj, key){
      self.toggleValue(obj, key, true, false);
    };

    /**
     * Traverse the object to get the value at the specified key
     * @name utils.traverse
     * @methodOf utils
     * @param {Object} obj
     * @param {string|Array.<string>} keys
     * @returns {*}
     */
    this.traverse = function(obj, keys){
      if (typeof keys === 'string'){
        keys = keys.split('.');
      }

      if (obj === undefined || obj === null) {
        return;
      }

      if (keys.length === 0) {
        return obj;
      }

      return self.traverse(obj[keys.shift()], keys);
    };

    /**
     * Convert from Some String & Literal! to some-string-literal
     * @name utils.toDash
     * @methodOf utils
     * @param {string} str
     * @returns {string}
     */
    this.toDash = function(str){
      return str ? str.toLowerCase().replace(toDashStrip, '-').replace(toDashReplace, '-').replace(/\-+$/, '') : '';
    };

    /**
     * Convert from some_string to Some String
     * @param {string} str
     * @returns {string}
     */
    this.snakeToTitle = function(str){
      // replace underscores with spaces first, then capitalize
      return this.capitalize(str.replace(/_/g, ' '));
    };

    //this.dashToCamel = function(str){
    //  var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
    //  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    //  return str.
    //    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
    //      return offset ? letter.toUpperCase() : letter;
    //    }).
    //    replace(MOZ_HACK_REGEXP, 'Moz$1');
    //};

    //this.getObscuredValue = function(value){
    //  if (!value) return null;
    //
    //  value = value.toString().split('');
    //
    //  // show the last 4 digits
    //  if (value.length > 8){
    //    return value.map(function(v, i){ return i > value.length - 5 ? v : 'x' }).join('')
    //  }
    //
    //  return value.map(function(){ return 'x' }).join('')
    //};

    /**
     * Modifies the `dst` object's values with each additional source's value
     * @name utils.deepExtend
     * @methodOf utils
     * @param {...*} dst
     * @returns {*}
     */
    this.deepExtend = function(dst){
      _.each(arguments, function(obj) {
        if (obj !== dst && typeof obj !== 'undefined') {
          var clone = JSON.parse(JSON.stringify(obj));

          _.each(clone, function(value, key) {
            if (dst[key] && dst[key].constructor && dst[key].constructor === Object) {
              self.deepExtend(dst[key], value);
            } else {
              dst[key] = value;
            }
          });
        }
      });
      return dst;
    };

    /**
     * @name utils.bindAll Apply the same arguments to each method of the instance, sets the context to the instance
     * @methodOf utils
     * @param {Object} instance
     */
    this.bindAll = function(instance){
      var args = _.toArray(arguments).slice(1);
      _.each(_.functions(instance), function(fnKey){
        instance[fnKey] = _.bind.apply(instance, [instance[fnKey], instance].concat(args));
      });
    };

    /**
     * @param {number} num
     * @param {number} size
     * @returns {string}
     */
    this.padNumber = function(num, size){
      return ('000000000' + num).substr(-size);
    };

    /**
     * @name utils.dataOrArray
     * @methodOf utils
     * @param {ng.$http.response} response
     * @returns {*[]}
     */
    this.dataOrArray = function(response){
      return responseDataOrElse(response, []);
    };

    /**
     * @name utils.dataOrObject
     * @methodOf utils
     * @param {ng.$http.response} response
     * @returns {*}
     */
    this.dataOrObject = function(response){
      return responseDataOrElse(response, {});
    };

    /**
     * @name utils.dataOrNull
     * @methodOf utils
     * @param {ng.$http.response} response
     * @returns {*|null}
     */
    this.dataOrNull = function(response){
      return responseDataOrElse(response, null);
    };

    /**
     * @name utils.dataOrFalse
     * @methodOf utils
     * @param {ng.$http.response} response
     * @returns {*|null}
     */
    this.dataOrFalse = function(response){
      return responseDataOrElse(response, false);
    };

    /**
     * @name utils.dataOrZero
     * @methodOf utils
     * @param {ng.$http.response} response
     * @returns {*|0}
     */
    this.dataOrZero = function(response){
      return responseDataOrElse(response, 0);
    };

    /**
     * @param {ng.$http.response} response
     * @param {*} defaultReturn
     * @returns {*}
     */
    function responseDataOrElse(response, defaultReturn){
      console.log(response.config.url, response);
      return response && response.status < 400 ? response.data : defaultReturn;
    }


    /**
     * @name utils.getIllnessNames
     * @methodOf utils
     * @param {string[]|Object[]} illnesses
     * @returns {string[]}
     */
    this.getIllnessNames = function(illnesses){
      return _.reject(_.map(illnesses, this.getIllnessName), _.isEmpty);
    };

    /**
     * @name utils.getIllnessName
     * @methodOf utils
     * @param {string|Object} illness
     * @returns {string}
     */
    this.getIllnessName = function(illness){
      var name = '';

      if (_.isString(illness)){
        name = illness;
      }
      else if (_.isObject(illness) && illness.name){
        name = illness.name;
      }

      return name;
    };
  }

  Utils.$inject = ['$location', '$timeout'];

  angular.module('common.services').service('utils', Utils);

}());
angular.module('common.services')
  .service('services.validation', [
  '$http',
  'config.paths',
  function($http, paths){

    this.routingNumber = function(number){
      return $http.get(paths.services + '/validation/routing-number/' + number)
        .then(function(response){
          return response && response.data ? response.data.name : false;
        })
    };
  }

]);
/**
 * @namespace address
 */
angular.module('address', ['config', 'session', 'common.services']);
(function(){
  /**
   * @typedef {Object} Address
   * @property {number} [id]
   * @property {string} [street]
   * @property {string} [unit]
   * @property {string} city
   * @property {string} [county]
   * @property {string} zipcode
   * @property {string} [region]
   * @property {string} [state]
   * @property {string} county_fips
   * @property {number} [phone_number]
   * @property {number} [lat]
   * @property {number} [lng]
   */

  /**
   * @name address.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {session} session
   * @param {utils} utils
   */
  var AddressService = function($q, $http, config, session, utils){
    var basePath = config.paths.services;
    var sessionKey = 'address';

    if (!getFromSession()){
      session.set(sessionKey, {});
    }

    /**
     * @name address.service.get Gets all addresses associated with user
     * @methodOf address.service
     * @param {user.model} userModel
     * @returns {HttpPromise<Address[]>}
     */
    this.get = function(userModel){
      if (!userModel.isLoggedIn){
        return $q.when([getFromSession()]);
      }

      return $http.get(basePath + '/address')
        .then(utils.dataOrArray);
    };

    /**
     * @name address.service.getForApp
     * @methodOf address.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @returns {HttpPromise<Address>}
     */
    this.getForApp = function(userModel, app_id){
      if (!userModel.isLoggedIn){
        return $q.when(getFromSession());
      }

      return $http.get(basePath + '/application/' + app_id + '/address')
        .then(utils.dataOrObject);
    };

    /**
     * @name address.service.post
     * @methodOf address.service
     * @param {user.model} userModel
     * @param {Address} address
     */
    this.post = function(userModel, address){
      if (!userModel.isLoggedIn){
        session.set(sessionKey, address);
        return $q.when(address);
      }

      cleanPhone(address);
      return $http.post(basePath + '/address', { address: address })
        .then(utils.dataOrObject);
    };

    /**
     * @name address.service.put
     * @methodOf address.service
     * @param {user.model} userModel
     * @param {Address} address
     */
    this.put = function(userModel, address){
      if (!userModel.isLoggedIn){
        return this.post(userModel, address);
      }

      cleanPhone(address);
      return $http.put(basePath + '/address/' + address.id, { address: address })
        .then(utils.dataOrObject);
    };

    /**
     * @name address.service.saveForApp
     * @methodOf address.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @param {Address} address
     * @returns {HttpPromise<Address>}
     */
    this.saveForApp = function(userModel, app_id, address){
      // logged out user only has one address
      if (!userModel.isLoggedIn){
        return this.post(userModel, address);
      }

      cleanPhone(address);

      return $http.post(basePath + '/application/' + app_id + '/address', { address: address })
        .then(utils.dataOrObject);
    };

    var geoAddressSharedProperties = ['city', 'county', 'region', 'zipcode', 'lat', 'lng'];

    /**
     * @name address.service.fromGeo
     * @methodOf address.service
     * @param {Geo} geo
     * @returns {Address}
     */
    this.fromGeo = function(geo){
      return _.chain(geo)
        .pick(geoAddressSharedProperties)
        .extend({
          county_fips: geo.countyFips,
          state: geo.stateCode
        })
        .value();
    };

    /**
     * @name address.service.toGeo
     * @methodOf address.service
     * @param {Address} address
     * @returns {Geo}
     */
    this.toGeo = function(address){
      return _.chain(address)
        .pick(geoAddressSharedProperties)
        .extend({
          countyFips: address.county_fips,
          stateCode: address.state,
          cityCounty: address.city + ', ' + address.county
        })
        .value();
    };

    /**
     * @name address.service.clearSession
     * @methodOf address.service
     */
    this.clearSession = function(){
      session.remove(sessionKey);
    };

    /**
     * @name address.service.getFromSession
     * @methodOf address.service
     * @returns {Address}
     */
    function getFromSession(){
      return session.get(sessionKey);
    }
    this.getFromSession = getFromSession;

    /**
     * @name address.service.cleanPhone
     * @methodOf address.service
     * @param {Address} address
     * @returns {Address} same reference as passed in address
     */
    function cleanPhone(address){
      if (_.isString(_.get(address, 'phone_number'))){
        address.phone_number = Number(address.phone_number.replace(/\D/g,''));
      }
      return address;
    }
    this.cleanPhone = cleanPhone;
  };
  AddressService.$inject = ['$q', '$http', 'config', 'session', 'utils'];

  angular.module('address')
    .service('address.service', AddressService);
}());

/**
 * Health application component
 * @namespace application
 */
angular.module('application', ['config', 'search', 'common', 'translate', 'drug', 'doctor', 'health', 'address', 'session', 'member', 'finance']);




/**
 * @typedef {Object} ifp_enroll_status
 * @property {number} agent_id
 * @property {string} carrier_notes
 * @property {Date} created_on
 * @property {Date} deleted_at
 * @enum {string} displayValue 'incomplete', 'pending', 'accepted', 'cancelled'
 * @property {number} id Sequence id from postgres
 * @property {string} ifp_app_id
 * @property {Boolean} isComplete
 * @property {string} notes
 * @property {number} status_id
 * @property {Date} updated_on
 * @property {UUID} user_id
 */

/**
 * @typedef {Object} ifp_app
 * @property {number} address_id
 * @property {number} agent_id
 * @property {string} app_id
 * @property {*} app_json
 * @property {string} app_status
 * @property {number} billing_id
 * @property {string} carrier_app_id
 * @property {string} carrier_id
 * @property {string} carrier_policy_id
 * @property {string} carrier_receipt
 * @property {Date} created_on
 * @property {Boolean} deleted Deprecated, use deleted_at
 * @property {Date} deleted_at
 * @property {number} id Sequence id from postgres
 * @property {number} num_lives
 * @property {string} payment_method
 * @property {string} plan_id
 * @property {string} premium
 * @property {string} product_id
 * @property {number} purchase_id
 * @property {string} purchase_item_id
 * @property {string} qualifying_event
 * @property {DateOnly} qualifying_event_date
 * @property {string} ref_code
 * @property {string} region
 * @property {string} session_id
 * @property {string} site
 * @property {DateOnly} start_date
 * @property {string} status displayValue from latest ifp_enroll_status
 * @property {Date} submitted_on
 * @property {Date} cancel_date
 * @property {string} type 'bor', 'dental', 'health'
 * @property {Date} updated_on
 * @property {UUID} user_id
 * @property {string} zipcode
 *
 * // these props are included by Sequelize
 * @property {ifp_enroll_status[]} ifp_enroll_statuses
 * @property {Member[]} members
 * @property {MemberDrug[]} member_drugs
 * @property {MemberProvider[]} member_providers
 * @property {Address} address
 * @property {Billing} billing
 */
angular.module('application')
  .directive('shApplicantName', [
    'config.paths',
    'application.model',
    function (paths, applicationModel) {
      var keyPrefix = 'shared.applicantNames.';

      return {
        scope: {
          applicant: '=shApplicantName',
          firstOnly: '='
        },
        templateUrl: paths.partials + '/components/application/applicant-name.html',
        link: function ($scope) {
          var applicant = $scope.applicant;

          //$scope.$watchCollection('applicant.name', setName);

          $scope.$watchGroup(['applicant.first_name', 'applicant.middle_name', 'applicant.last_name'], function (newValue, oldValue) {
            //if (newValue && newValue != oldValue) {
              setName();
            //}
          });

          $scope.$watch('applicant.type', function (newValue, oldValue) {
            if (newValue && newValue !== oldValue) {
              setName();
            }
          });

          function setName() {
            var name = {
              first: applicant.first_name,
              middle: applicant.middle_name,
              last: applicant.last_name
            };

            // if there's no first name, default to translated names
            if (!name.first) {
              name.key = keyPrefix + (applicant.type || 'generic');

              if (applicant.type === 'dependent') {
                if (applicant.age != null && !isNaN(applicant.age)) {
                  name.key = keyPrefix + 'dependentAge';
                  name.model = {age: applicant.age};
                }
                else {
                  name.index = _.indexOf(applicationModel.getKids(), applicant);
                }
              }
            }

            $scope.name = name;
          }
        }
      };
    }
  ])
  .directive('shApplicantNames', [
    'config.paths',
    'member.service',
    function (paths, memberService) {
      return {
        scope: {
          applicants: '=shApplicantNames',
          firstOnly: '='
        },
        templateUrl: paths.partials + '/components/application/applicant-names.html',
        link: function($scope){
          $scope.$watch('applicants', function(applicants){
            memberService.setOrder(applicants);
          });
        }
      };
    }
  ]);
(function () {
  /**
   * Application Drugs directive
   * @param $state
   * @param config
   * @param applicationModel
   * @param utils
   * @param drugEditor
   * @param drugService
   * @param userModel
   * @returns {{scope: {userDrugs: string}, templateUrl: templateUrl, link: link}}
   * @constructor
   */
  function ApplicationDrugsDirective(config, applicationModel, drugEditor) {
    return {
      scope: {
        userDrugs: '=?'
      },
      templateUrl: function ($elem, $attr) {
        return $attr.templateUrl || config.paths.partials + '/components/application/application-drugs.html';
      },
      link: function ($scope) {
        $scope.searchDrugs = function () {
          $scope.$emit('drug-search');
        };

        $scope.getDoseForm = drugEditor.getDoseForm;

        // this is just removed for all applicants right now
        $scope.removeDrug = function (drug) {
          $scope.$emit('drug-remove', drug);
        };

        $scope.editDrug = function (drug) {
          $scope.$emit('drug-edit', drug);
        };

        /**
         * Get the full applicant model associated with the drugModel.memberId
         * @param {MemberDrug} drugModel
         * @returns {applicant.model}
         */
        $scope.getApplicant = function (drugModel) {
          return _.findWhere(applicationModel.getMembers(), {id: drugModel.member_id});
        };
      }
    };
  }

  ApplicationDrugsDirective.$inject = ['config', 'application.model', 'drug.editor'];
  angular.module('application').directive('shApplicationDrugs', ApplicationDrugsDirective);
}());
(function(){

  /**
   * Health Application Model
   * @name application.model
   * @param {health.app} HealthApp
   * @param {services.auth} authService
   * @param {application.service} applicationService
   * @param {member.service} memberService
   * @param {doctor.service} doctorService
   * @param {drug.service} drugService
   * @param {address.service} addressService
   * @augments {health.app}
   * @constructor
   */
  function ApplicationModel(HealthApp, authService, applicationService, memberService, doctorService, drugService, addressService){

    /**
     * Inherit from Health App
     */
    function Model(){
      HealthApp.apply(this, arguments);
    }
    Model.prototype = new HealthApp();

    ///**
    // * Set application based on data object and updates AuthService.appComplete
    // * @name application.model.set
    // * @methodOf application.model
    // * @param {health.app.data} application Application json object from the server
    // */
    //Model.prototype.set = function(application){
    //  HealthApp.prototype.set.call(this, application);
    //  authService.setAppComplete(this.isComplete());
    //};

    /**
     * @name application.model.getId
     * @methodOf application.model
     * @returns {string}
     */

    /**
     * Shortcut method for wholesale posting of app_json
     * @name application.model.save
     * @methodOf application.model
     * @param {user.model} userModel
     * @returns {HttpPromise.<application.model|Error>}
     */
    Model.prototype.save = function(userModel){
      return applicationService.saveAppJson(userModel, this.getId(), this.get());
    };

    /**
     * Shortcut method for wholesale posting of QE
     * @name application.model.save
     * @methodOf application.model
     * @param {user.model} userModel
     * @param {string} qualifying_event
     * @param {Date} qualifying_event_date
     * @returns {HttpPromise.<application.model|Error>}
     */
    Model.prototype.saveQE = function(userModel, qualifying_event, qualifying_event_date){
      return applicationService.saveQE(userModel, this.getId(), qualifying_event, qualifying_event_date);
    };



    /**
     * Sets the plan for the application and persists to server
     * @name application.model.setPlan
     * @methodOf application.model
     * @param {user.model} userModel
     * @param {object} plan
     * @returns {HttpPromise.<application.model|Error>}
     */
    Model.prototype.setPlan = function(userModel, plan){
      this.data.plan = plan;

      if (!plan) {
        return applicationService.deletePlan(userModel, this.getId());
      }
      return applicationService.postPlan(userModel, this.getId(), plan);
    };


    return new Model();
  }
  ApplicationModel.$inject = ['health.app', 'services.auth', 'application.service', 'member.service', 'doctor.service', 'drug.service', 'address.service'];

  angular.module('application')
    .factory('application.model', ApplicationModel);
}());
angular.module('application')

  /**
   * Application Service
   * @name application.service
   * @memberOf application
   */

  .service('application.service', [
    '$q',
    '$http',
    'utils',
    'logger',
    'config.paths',
    'config.service',
    'search.geo',
    'member.service',
    'address.service',
    'doctor.service',
    'drug.service',
    'session',
    'services.date',
    'finance.service',
    function($q, $http, utils, logger, paths, configService, geoService, memberService, addressService, doctorService, drugService, session, dateService, financeService){
      var self = this;
      var sessionKey = 'applications';
      var serviceBase = paths.services;

      if (!_.isArray(session.get(sessionKey))){
        session.set(sessionKey, []);
      }

      /**
       * Resets the ifp_app, wiping off all data except for app_id.
       * Also sets the applicationModel data to the response on success
       * @name application.service.reset
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @returns {HttpPromise<ifp_app>}
       */
      this.reset = function(userModel, app_id){
        return $http.post(serviceBase + '/application/' + app_id + '/reset', {})
          .then(utils.dataOrObject);
      };

      /**
       * Save the plan for the application
       * @name application.service.postPlan
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @param {HealthPlan} plan
       * @returns {HttpPromise<ifp_app>} promise
       */
      this.postPlan = function(userModel, app_id, plan){
        if (!userModel.isLoggedIn){
          var allApps = session.get(sessionKey);
          var app = allApps[app_id];
          if (!app){
            console.log('No app to update plan on');
          }

          if (!_.isObject(app.app_json)){
            app.app_json = {};
          }

          app.app_json.plan = plan;
          session.set(sessionKey, allApps);

          return fromSession(app);
        }

        var payload = {
          plan_id: plan && plan.id || null,
          carrier_id: plan && plan.carrierId || null,
          premium: plan ? _.get(plan, 'mods.premiumMonth', plan.premiumMonth) : null,
          plan: !_.isEmpty(plan) ? plan : null
        };

        return $http.post(serviceBase + '/application/' + app_id + '/plan', payload)
          .then(utils.dataOrObject);
      };


      /**
       * Remove the plan for the application
       * @name application.service.deletePlan
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @returns {HttpPromise<ifp_app>} promise
       */
      this.deletePlan = function(userModel, app_id){
        if (!userModel.isLoggedIn){
          return this.postPlan(userModel, app_id, null);
        }

        return $http.delete(serviceBase + '/application/' + app_id + '/plan')
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.createWithResources
       * @methodOf application.service
       * @param {health.app.data} app_json
       * @param {Address} address
       * @param {Member[]} members
       * @param {MemberProvider[]} providers
       * @param {MemberDrug[]} drugs
       * @param {string} [type=health]
       * @returns {HttpPromise<ifp_app>}
       */
      this.createWithResources = function(app_json, address, members, providers, drugs, finances, type){
        var payload = {
          app_json: app_json,
          address: address,
          member: members,
          member_provider: providers,
          member_drug: drugs,
          member_finance: finances,
          type: type || 'health'
        };

        // wipe out any empty arrays or objects
        _.each(_.keys(payload), function(key){
          if (_.isEmpty(payload[key])){
            delete payload[key];
          }
        });

        return $http.post(serviceBase + '/application', payload).then(utils.dataOrObject);
      };

      /**
       * @name application.service.createAppsFromSession
       * @methodOf application.service
       */
      this.createAppsFromSession = function(){
        var allApps = session.get(sessionKey);
        var createdApps = [];

        // do these in sequence to avoid any concurrent update errors
        return $q.when(_.find(allApps, { type: 'health'}))
          .then(function(healthApp){
            if (healthApp){
              return createFromSession(healthApp);
            }
          })
          .then(function(healthApp){
            if (healthApp){
              createdApps.push(healthApp);
            }
            return true;
          })
          .then(function(){
            var dentalApp = _.find(allApps, { type: 'dental'});
            if (dentalApp){
              return createFromSession(dentalApp);
            }
          })
          .then(function(dentalApp){
            if (dentalApp){
              createdApps.push(dentalApp);
            }

            _.each([doctorService, drugService, memberService, addressService, financeService, self], function(svc){
              svc.clearSession();
            });

            return createdApps;
          });
      };

      /**
       * @name application.service.createFromSession
       * @methodOf application.service
       * @param {ifp_app} ifp_app
       * @returns {HttpPromise<ifp_app>}
       * @private
       */
      function createFromSession(ifp_app){
        return fromSession(ifp_app)
          .then(function(app){
            var members = _.map(app.members, function(member){
              return _.extend(member, { status: _.get(member, 'member_application.type', 'coverage') });
            });
            return self.createWithResources(app.app_json || {}, app.address, members, app.member_providers, app.member_drugs, app.member_finances, app.type);
          });
      }

      /**
       * Check to see if the application model is ready to be submitted
       * @name application.service.isValidToSubmit
       * @methodOf application.service
       * @param {string} app_id
       * @param {string} effectiveDate isoDateString 2016-02-01
       * @returns {HttpPromise<boolean>}
       */
      this.isValidToSubmit = function(app_id, effectiveDate){
        return $http.post(serviceBase + '/health/application/is-valid-to-submit', { app_id: app_id, effectiveDate: effectiveDate, m: (new Date()).getTimezoneOffset() })
          .then(utils.dataOrFalse);
      };

      //this.getExtras = function(applicationModel){
      //  var state = applicationModel.getState();
      //
      //  if (state){
      //    return geoService.getStateConfig(state)
      //      .then(function(stateConfig){
      //        var carrier = _.findWhere(stateConfig.carriers, { carrierId: applicationModel.getPlan().carrierId });
      //
      //        if (carrier && carrier.questions && carrier.questions.length){
      //          return configService.getEntry(carrier.id, 10)
      //            .then(function(carrier){
      //              return carrier.questions;
      //            });
      //        }
      //
      //        return [];
      //      });
      //  }
      //
      //  return $q.when([]);
      //};

      /**
       * @name application.service.get
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @returns {HttpPromise<ifp_app>}
       */
      this.get = function(userModel, app_id){
        if (!userModel.isLoggedIn){
          return fromSession(session.get(sessionKey)[app_id] || {});
        }

        return $http.get(serviceBase + '/application/' + app_id)
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.query
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {object} query
       * @returns {HttpPromise<ifp_app[]>}
       */
      this.query = function(userModel, query){
        if (!userModel.isLoggedIn){
          return $q.all(_.map(_.where(session.get(sessionKey), query), fromSession));
        }

        return $http.get(serviceBase + '/application', { params: query })
          .then(utils.dataOrArray);
      };

      /**
       * @name application.service.save
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {ifp_app} ifp_app
       * @returns {HttpPromise<ifp_app>}
       */
      this.save = function(userModel, ifp_app){
        if (!userModel.isLoggedIn){
          var allApps = session.get(sessionKey);
          // remove any associations that were attached
          ifp_app = _.omit(ifp_app, ['address', 'members', 'member_drugs', 'member_providers']);
          // if net new, use the application length to set client app_id
          if (_.isUndefined(ifp_app.app_id)){
            ifp_app.app_id = allApps.length;
            allApps.push(ifp_app);
          }
          else {
            var found = _.find(allApps, { app_id: ifp_app.app_id });
            if (found){
              _.extend(found, ifp_app);
            }
            else {
              console.error('Invalid session app_id: ', ifp_app.app_id);
            }
          }

          session.set(sessionKey, allApps);
          return fromSession(ifp_app);
        }

        // omit app_id if it's a number, since that is the index
        // set by the client to track logged out applications
        if (!_.isString(ifp_app.app_id)){
          return $http.post(serviceBase + '/application', _.omit(ifp_app, ['app_id']))
            .then(utils.dataOrObject);
        }

        return $http.put(serviceBase + '/application/' + ifp_app.app_id, ifp_app)
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.saveAppJson
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @param {health.app.data} app_json
       * @returns {HttpPromise<ifp_app>}
       */
      this.saveAppJson = function(userModel, app_id, app_json){
        return savePayload(userModel, app_id, { app_json: app_json });
      };

      /**
       * @name application.service.saveQE
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @param {string} qualifying_event
       * @param {Date} qualifying_event_date
       * @returns {HttpPromise<ifp_app>}
       */
      this.saveQE = function(userModel, app_id, qualifying_event, qualifying_event_date){
        return savePayload(userModel, app_id, {
          qualifying_event: qualifying_event,
          qualifying_event_date: dateService.toIsoDate(qualifying_event_date)
        });
      };

      /**
       * @name application.service.eSign
       * @methodOf application.service
       * @param {string} app_id
       * @param {UUID[]} member_ids
       * @returns {HttpPromise.<boolean>}
       */
      this.eSign = function (app_id, member_ids) {
        return $http.post(serviceBase + '/application/' + app_id + '/member/e-sign', { member_ids: member_ids })
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.submit
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       */
      this.submit = function(userModel, app_id){
        // can't submit if not logged in
        if (!userModel.isLoggedIn){
          return $q.reject('User not logged in');
        }

        return $http.post(serviceBase + '/application/submit', { app_id: app_id })
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.getActive
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} type
       * @returns {HttpPromise<ifp_app>}
       */
      this.getActive = function(userModel, type){
        if (!userModel.isLoggedIn){
          var active = _.findWhere(session.get(sessionKey), { type: type });
          if (!active){
            return this.save(userModel, { type: type });
          }

          return fromSession(active);
        }

        // if user has active app id, get that one
        if (userModel.activeAppId){
          return this.get(userModel, userModel.activeAppId);
        }

        return this.query(userModel, { type: type, is_complete: true })
          .then(function(apps){
            var app = apps.length && apps[0] || null;

            if (app && app.app_id && app.type === 'health'){
              return [app, self.setActive(userModel, app.app_id, type)];
            }

            return [app];
          })
          .then(function(responses){
            return responses && responses[0] || null;
          });

      };

      /**
       * @name application.service.setActive
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @param {string} type
       * @returns {HttpPromise<ifp_app>}
       */
      this.setActive = function(userModel, app_id, type){
        if (type !== 'health' && type !== 'bor'){
          return $q.reject('Active application must be health');
        }

        return $q.when(true)
          .then(function(){
            if (!userModel.isLoggedIn){
              return self.getActive(userModel, type);
            }

            return $http.post(serviceBase + '/application/' + app_id + '/active', {})
              .then(utils.dataOrObject);
          })
          .then(function(ifp_app){
            if ((type === 'health' || type === 'bor') && !_.isEmpty(ifp_app)){
              userModel.setActiveHealth(ifp_app);
            }

            return ifp_app;
          });
      };


      /**
       * @name application.service.getWorking
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} type
       * @returns {HttpPromise<ifp_app>}
       */
      this.getWorking = function(userModel, type){
        if (!userModel.isLoggedIn){
          return this.getActive(userModel, type);
        }

        if (type === 'health' && (userModel.workingAppId || userModel.activeAppId)){
          return this.get(userModel, userModel.workingAppId || userModel.activeAppId);
        }

        return this.query(userModel, { type: type, is_complete: false })
          .then(function(apps){

            if (apps && apps.length) {
              return apps[0];
            }

            return self.getActive(userModel, type);
          })
          .then(function(app){

            // if there's no active or working health app for a logged in user, create one
            if (type === 'health' && !app) {
              return self.save(userModel, { type: 'health' });
            }

            return app;
          })
          .then(function(app){
            if (app && app.app_id && app.type === 'health'){
              return $q.all([app, userModel.setWorkingApp(app.app_id)]);
            }

            return [app];
          })
          .then(function(res){
            return res[0];
          });
      };

      /**
       * Only for logged in users
       * @name application.service.getCopy
       * @methodOf application.service
       * @param {string} app_id
       * @returns {HttpPromise<ifp_app>}
       */
      this.getCopy = function(app_id){
        return $http.post(serviceBase + '/application/' + app_id + '/copy', {})
          .then(utils.dataOrObject);
      };

      /**
       * @name application.service.isComplete
       * @methodOf application.service
       * @param {ifp_app} ifp_app
       * @returns {boolean}
       */
      this.isComplete = function(ifp_app){
        return _.get(ifp_app, 'ifp_enroll_statuses.0.isComplete') === true;
      };

      /**
       * @name application.service.clearSession
       * @methodOf application.service
       */
      this.clearSession = function(){
        session.remove(sessionKey);
      };

      /**
       * Attaching these here for now to be consistent with how the API returns associated resources
       * @param {ifp_app} ifp_app
       * @returns {HttpPromise<ifp_app>}
       */
      function fromSession(ifp_app){
        return memberService.getAppMembers({ isLoggedIn: false }, ifp_app.app_id)
          .then(function(members){
            ifp_app.members = members;
            ifp_app.member_providers = _.filter(session.get('member_provider'), function(member_provider){
              return member_provider.product_type === ifp_app.type && !!_.find(members, { id: member_provider.member_id });
            });
            ifp_app.member_drugs = _.filter(session.get('member_drug'), function(member_drug){
              return ifp_app.type === 'health' && !!_.find(members, { id: member_drug.member_id });
            });
            ifp_app.address = session.get('address');
            // finance service will get from session if user is logged out
            ifp_app.member_finances = financeService.getForAppAsync(ifp_app.app_id);
            return $q.all(ifp_app);
          });
      }

      /**
       * @name application.service.savePayload
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @param {Object} payload
       * @returns {HttpPromise<ifp_app>}
       */
      function savePayload(userModel, app_id, payload){
        if (!userModel.isLoggedIn) {
          var allApps = session.get(sessionKey);
          var match = _.findWhere(allApps, { app_id: app_id });
          if (match) {
            _.each(payload, function(value, key){
              match[key] = value;
            });
          }

          session.set(sessionKey, allApps);
          return fromSession(match);
        }

        return $http.put(serviceBase + '/application/' + app_id, payload)
          .then(utils.dataOrObject);
      }

      /**
       * Gets all unique members from ifp_apps and returns them sorted by type primary -> spouse -> dependent
       * @name application.service.getUniqueMembers
       * @methodOf application.service
       * @param {ifp_app[]} ifp_apps
       * @returns {Member[]}
       */
      this.getUniqueMembers = function(ifp_apps){
        return memberService.setOrder(_.chain(ifp_apps)
          .pluck('members')
          .flatten()
          .uniq(false, function(member){ return member.id; })
          .value());
      };

      /**
       * @name application.service.getDrugs
       * @methodOf application.service
       * @param {user.model} userModel
       * @param {string} app_id
       * @returns {HttpPromise<MemberDrug[]>}
       */
      this.getDrugs = function (userModel, app_id) {
        if (!userModel.isLoggedIn) {
          var allDrugs = drugService.getFromSession();

          return memberService.getAppMembers(userModel, app_id)
            .then(function(members){
              return _.filter(allDrugs, function(drug){
                return !!_.find(members, { id: drug.member_id });
              });
            });
        }

        return $http.get(serviceBase + '/application/' + app_id + '/member/drug')
          .then(utils.dataOrArray);
      };


      /**
       * @name application.service.setEffectiveAges
       * @methodOf application.service
       * @param {Object} params
       * @param {Member[]} params.members
       * @param {DateOnly} [params.effectiveDate] either effectiveDate or onExchange/state must be set
       * @param {boolean} [params.onExchange=false]
       * @param {string} [params.state]
       * @returns {HttpPromise<Members[]>}
       */
      this.setEffectiveAges = function(params){
        return $q.when(params.effectiveDate)
          .then(function(ed){
            if (ed){
              return ed;
            }

            return dateService.getEffectiveDate({ onExchange: !!params.onExchange, state: params.state });
          })
          .then(function (ed) {
            return _.each(params.members, function (member) {
              if (member.dob) {
                member.age = dateService.getStartDateAgeSync(member.dob, ed);
                console.log(member.age)
              }
            });
          });
      };
    }
  ]);

angular.module('billing', ['application', 'common', 'plan', 'user', 'search', 'address', 'config']);


angular.module('billing')
  .controller('billing.combined.controller', [
    '$q',
    '$scope',
    '$state',
    'user.model',
    'application.model',
    'application.service',
    'services.validation',
    'services.date',
    'cart.service',
    'billing.service',
    'address.service',
    'search.carriers',
    'logger',
    /**
     * @param $q
     * @param $scope
     * @param $state
     * @param {user.model} userModel
     * @param {health.app} applicationModel
     * @param {application.service} applicationService
     * @param validationService
     * @param {services.date} dateService
     * @param {cart.service} cartService
     * @param {billing.service} billingService
     * @param {address.service} addressService
     * @param {search.carriers} carrierSearch
     * @param logger
     */
    function($q, $scope, $state, userModel, applicationModel, applicationService, validationService, dateService, cartService, billingService, addressService, carrierSearch, logger){
      if (!applicationModel.getAddress() || !cartService.apps.length){
        return;
      }

      var lock = false;
      var startDate = dateService.getStartDate(applicationModel);
      var stateData = $state.getData();
      var pgBilling = angular.copy(applicationModel.billing);
      var pgAddress = angular.copy(pgBilling.address || applicationModel.getAddress());
      var fields = {
        credit: ['card_number', 'expiration_date', 'name_on_card', 'security_code'],
        debit: ['account_number', 'routing_number']
      };
      var billingTypes = {
        none: 'no_stride_billing',
        ach: 'ach_preferred',
        cc: 'cc_preferred',
        achOnly: 'ach_only'
      };

      $scope.render = false;
      $scope.forms = {};
      $scope.appStartDate = startDate;
      $scope.expDateRange = [startDate, new Date(startDate.getFullYear() + 20, 11, 31)];
      $scope.model = applicationModel.billing;
      $scope.dbBilling = !_.isEmpty(pgBilling);

      // try to get the billing id associated with the current application

      carrierSearch.get(pgAddress)
        .then(function(carriers){
          var carrier = _.findWhere(carriers, { id: applicationModel.getPlan().carrierId });

          if (!carrier){
            throw new Error('No carrier found for ' + applicationModel.getId());
          }

          $scope.carrier = carrier;
          return initBillingTypes();
        })
        .then(function(){
          // pop the plan details to make sure people know what they're buying
          cartService.show();
          $scope.render = true;
        })
        .catch(function(err){
          logger.error({
            err: err && err.message || err
          });

          $state.go('500');
        });

      $scope.$watch(function(){ return cartService.apps.length; }, function(newCount, oldCount){
        if (_.isNumber(oldCount) && newCount !== oldCount){
          initBillingTypes();
        }
      });

      // local to the direct debit form
      $scope.submitDebit = function(){
        if ($scope.forms.debit.$valid){
          $scope.model.type = 'debit';
          cleanFields('credit');
          submitBilling();
        }
      };

      $scope.submitCredit = function(){
        if ($scope.forms.creditCard.$valid){
          $scope.model.type = 'credit';
          cleanFields('debit');
          $scope.model.expiration_date = dateService.toIsoDate($scope.model.expiration_date);
          submitBilling();
        }
      };

      $scope.nextNoBilling = function(){
        return $state.go(stateData.nextState);
        //if (!stateData.postBilling) {
        //  return;
        //}
        //
        //// still may need to update the app status even if nothing has changed in the billing object
        //return applicationService.postBilling(applicationModel, 'billing')
        //  .then(function(){
        //    return $state.go(stateData.nextState);
        //  });
      };

      $scope.changeBilling = function(){
        $scope.dbBilling = false;
        $scope.model = {};
      };

      $scope.toggleSCHelp = function(){
        $scope.showSCHelp = !$scope.showSCHelp;
      };

      $scope.fillAddress = function(value){
        if (!value) {
          return;
        }
        var primary = applicationModel.getPrimary();
        $scope.address = angular.copy(pgAddress);
        $scope.model.name_on_card = primary.first_name + ' ' + primary.last_name;
      };

      $scope.$on('$stateChangeSuccess', function(){
        lock = false;
        $scope.serverError = '';
      });

      // null out other fields to avoid admin portal confusion
      function cleanFields(type){
        _.each(fields[type], function(key){
          delete $scope.model[key];
        });
      }

      // handles both debit and credit
      function submitBilling(){
        if (!lock) {
          lock = true;
          $scope.serverError = '';

          // if the address has changed from the credit card entry
          return $q.when($scope.address && !angular.equals($scope.address, pgAddress))
            .then(function(isNewAddress){
              // save the new address
              if (isNewAddress){
                return addressService.post(userModel, _.omit($scope.address, ['id']));
              }

              // otherwise send the old address id through
              return { id: pgAddress.id };
            })
            .then(function(address){
              if ($scope.address){
                $scope.address.id = address.id;
                pgAddress = angular.copy($scope.address);
              }

              $scope.model.address_id = address.id;

              // if billing has changed at all, including address id, save it
              if (!angular.equals(pgBilling, $scope.model)){
                delete $scope.model.id;
                return billingService.postForApp(applicationModel.getId(), $scope.model);
              }

              return false;
            })
            .then(function (response) {
              if (response && response.id){
                $scope.model.id = response.id;
                applicationModel.billing = response;

                if ($scope.hasDental){
                  return billingService.putForApp($scope.dentalApp.app_id, response.id);
                }
              }
            })
            .then(function(){
              return $state.go(stateData.nextState);
            })
            .catch(function(err){
              var message = err && err.data && err.data.message || 'Error submitting billing information';
              lock = false;

              if (message === 'Must only use a test bank account number when making transfers or debits in test mode'){
                $scope.serverError = 'Please enter a valid account number';
              }
              else {
                $scope.serverError = message;
              }


              logger
                .error({
                  message: message,
                  stack: err,
                  userOid: applicationModel.getUserId()
                });
            });

        }
      }

      function goToType(type){
        var currentState = 'debit';
        var desiredState = 'debit';
        var goToState = '';

        switch (type){
          case billingTypes.none:
            desiredState = 'notAccepted';
            break;
          case billingTypes.cc:
            desiredState = $scope.model.type || 'credit';
            break;
          case billingTypes.ach:
            desiredState = $scope.model.type || 'debit';
        }

        if ($state.current.name.indexOf('credit') !== -1){
          currentState = 'credit';
        }
        else if ($state.current.name.indexOf('notAccepted') !== -1){
          currentState = 'notAccepted';
        }

        if (currentState !== desiredState){
          // if it's not already on debit, reference the parents state
          if (currentState !== 'debit'){
            goToState = '^';
          }

          // if we're not going to debit, go to the child state of the debit state
          if (desiredState !== 'debit'){
            goToState += '.'  + desiredState;
          }

          return $state.replace(goToState);
        }
      }

      function initBillingTypes(){
        var carrier = $scope.carrier;
        $scope.dentalApp = cartService.getAppByType('dental');
        $scope.hasDental = !!$scope.dentalApp;

        $scope.acceptsCredit = [];
        $scope.acceptsAch = [];
        $scope.noneAccepted = [];

        if ($scope.hasDental){
          var dentalCarrier = _.get($scope, 'dentalApp.plan.carrier');
          $scope.acceptsCredit.push(dentalCarrier);
          $scope.acceptsAch.push(dentalCarrier);
        }

        if (carrier.billingType === billingTypes.none){
          $scope.noneAccepted.unshift(carrier.name);
        }
        else if (carrier.billingType === billingTypes.achOnly){
          $scope.acceptsAch.unshift(carrier.name);
        }
        else {
          $scope.acceptsCredit.unshift(carrier.name);
          $scope.acceptsAch.unshift(carrier.name);
        }

        // if billing not accepted for health carrier but they have dental
        // we still need billing info, prefer cc for conversion since Beam takes both
        if (carrier.billingType === billingTypes.none && $scope.hasDental){
          $scope.billingType = billingTypes.cc;
        }
        else {
          $scope.billingType = carrier.billingType;
        }

        if (
          $scope.billingType === billingTypes.achOnly && pgBilling.type === 'credit' ||
          $scope.billingType === billingTypes.none && pgBilling.type
        ){
          $scope.dbBilling = false;
          $scope.model = {};
          pgBilling = {};
        }

        return goToType($scope.billingType);
      }
    }
  ]);
(function(){

  /**
   * @typedef {Object} Billing
   * @property {number} id
   * @property {UUID} user_id
   * @property {string} type
   * @property {string} [account_number]
   * @property {string} [routing_number]
   * @property {string} [bank_name]
   * @property {string} [card_number]
   * @property {string} [expiration_date]
   * @property {string} [name_on_card]
   * @property {string} [security_code]
   * @property {string} [stripe_token]
   * @property {number} [address_id]
   */

  /**
   * @name billing.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   */
  function BillingService($q, $http, config, utils){
    var basePath = config.paths.services;

    // don't accept billing for logged out users

    /**
     * @name billing.service.query
     * @methodOf billing.service
     * @param {Object} query
     * @returns {HttpPromise<Billing[]>}
     */
    this.query = function(query){
      return $http.get(basePath + '/billing', { params: query })
        .then(utils.dataOrArray);
    };

    /**
     * @name billing.service.get
     * @methodOf billing.service
     * @param {number} id
     * @returns {HttpPromise<Billing>}
     */
    this.get = function(id){
      return $http.get(basePath + '/billing', { id: id })
        .then(utils.dataOrObject);
    };

    /**
     * @name billing.service.post
     * @methodOf billing.service
     * @param {Billing} data
     * @returns {HttpPromise<Billing>}
     */
    this.post = function(data){
      return $http.post(basePath + '/billing', { billing: data })
        .then(utils.dataOrObject);
    };

    /**
     * @name billing.service.put
     * @methodOf billing.service
     * @param {Billing} data
     * @returns {HttpPromise<Billing>}
     */
    this.put = function(data){
      return $http.put(basePath + '/billing', { billing: data })
        .then(utils.dataOrObject);
    };

    /**
     * @name billing.service.postForApp
     * @methodOf billing.service
     * @param {string} app_id
     * @param {Billing} data
     * @returns {HttpPromise<Billing>}
     */
    this.postForApp = function(app_id, data){
      return $http.post(basePath + '/application/' + app_id + '/billing', { billing: data })
        .then(utils.dataOrObject);
    };

    /**
     * @name billing.service.postForApp
     * @methodOf billing.service
     * @param {string} app_id
     * @param {number} billing_id
     * @returns {HttpPromise} returns 200 on success
     */
    this.putForApp = function(app_id, billing_id){
      return $http.put(basePath + '/application/' + app_id + '/billing/' + billing_id, {});
    };
  }
  BillingService.$inject = ['$q', '$http', 'config', 'utils'];

  angular.module('billing')
    .service('billing.service', BillingService);
}());
/**
 * @namespace bor
 */
angular.module('bor', ['config', 'common.services']);
angular.module('bor')
  .directive('borPreview', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/bor/preview.html',
        scope: {
          borApp: '='
        }
      };
    }
  ]);
/**
 * @typedef {Object} broker_of_record
 * @property {number} id
 * @property {UUID} user_id
 * @property {UUID} member_id
 * @property {number} address_id
 * @property {number} agent_id
 * @property {number} carrier_brand_id
 * @property {string} carrier_brand_name
 * @property {string} plan_id
 * @property {string} insurance_member_id
 * @property {string} source
 * @property {Date} e_sign_date
 * @property {Date} created_on
 * @property {Date} updated_on
 * @property {Date} deleted_at
 */

(function(){

  /**
   * @name bor.service
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   * @param {logger} logger
   */
  function BorService($http, config, utils, logger){
    var serviceBase = config.paths.services;

    /**
     * @name bor.service.getActive
     * @methodOf bor.service
     * @returns {HttpPromise<broker_of_record>}
     */
    this.getLatest = function(){
      var route = serviceBase + '/bor/latest';

      return $http.get(route, { cache: true })
        .then(utils.dataOrObject)
        .catch(function(err){
          logger.error({
            message: 'Cannot get [' + route + ']',
            stack: err
          });

          return null;
        });
    };


    /**
     * Is the current user a paying bor/health
     * @name bor.service.hasGrantedBor
     * @methodOf bor.service
     * @returns {HttpPromise<boolean>}
     */
    this.hasGrantedBor = function(){
      var route = serviceBase + '/bor/is-active';

      return $http.get(route)
        .then(utils.dataOrObject)
        .then(function(res){ return !!res.isActive; })
        .catch(function(err){
          logger.error({
            message: 'Cannot get [' + route + ']',
            stack: err
          });

          return false;
        });
    };

  }
  BorService.$inject = ['$http', 'config', 'utils', 'logger'];


  angular.module('bor')
    .service('bor.service', BorService);
}());


/**
 * @namespace cart
 */
angular.module('cart', ['member', 'common', 'translate', 'application', 'address']);

(function () {

  /**
   * @name cart.controller
   * @param $state
   * @param $scope
   * @param {cart.service} cartService
   * @param {services.date} dateService
   * @param {services.tracking} trackingService
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($state, $scope, cartService, dateService, trackingService, userModel, memberService) {
    var self = this;

    if ($scope.showOnInit) {
      cartService.show();
    }

    $scope.$watch(function () {
      return cartService.apps;
    }, function (apps) {
      if (_.isArray(apps)) {
        var ascendingApps = _.sortBy(apps, 'type');
        self.apps = ascendingApps.reverse();
        self.premiumTotal = cartService.getPremiumTotal();

        // Update health app members
        var healthApp = _.findWhere(self.apps, {type: 'health'});
        if (healthApp) {
          var filteredMembers = self.getAppMembers(healthApp);
          cartService.updateAppMembers(healthApp.app_id, filteredMembers);
        }

      }
    });

    $scope.$watch(function () {
      return cartService.getPremiumTotal();
    }, function (premiumTotal) {
      if (self.premiumTotal !== premiumTotal) {
        self.premiumTotal = premiumTotal;
      }
    });

    $scope.$on('$destroy', function () {
      cartService.hide();
    });

    this.showing = function () {
      return cartService.showing;
    };

    this.getAppMembers = function (app) {
      if (app.type === 'dental') {
        return app.members;
      }
      return _.filter(app.members, function (member) {
        return memberService.isStatus(member, 'coverage');
      });
    };

    this.navToChange = function (app) {
      if (app.type === 'dental') {
        trackingService.mixpanelEvent(trackingService.propEnum.cartAction, {'Action': 'Edit Dental Plan'});

        $state.go('dental.plans');
      } else if (app.type === 'health') {
        trackingService.mixpanelEvent(trackingService.propEnum.cartAction, {'Action': 'Edit Health Plan'});
        $state.go('recommended');
      } else {
        // error
      }
    };

    this.removeApp = function (app) {
      cartService.removeApp(userModel, app.app_id)
        .then(function (response) {
          trackingService.mixpanelEvent(trackingService.propEnum.cartAction, {'Action': 'Remove Plan'});
          self.apps = response;
          return $state.go('cart');
        });
    };

    var healthApp = cartService.getAppByType('health');
    if (healthApp) {
      dateService.getEffectiveDate({
          onExchange: _.get(healthApp, 'app_json.subsidy.amount', 0) > 0,
          state: healthApp.address.state
        })
        .then(function (effectiveDate) {
          self.effectiveDate = effectiveDate;
        });
    }
    else {
      self.effectiveDate = dateService.getNextMonth();
    }

  }

  Ctrl.$inject = ['$state', '$scope', 'cart.service', 'services.date', 'services.tracking', 'user.model', 'member.service'];

  angular.module('cart')
    .controller('cart.controller', Ctrl);
}());

angular.module('cart')
  .directive('shCart', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          showOnInit: '='
        },
        templateUrl: paths.partials + '/components/cart/cart.html',
        controller: 'cart.controller as cartCtrl'
      };
    }
  ]);
(function () {

  /**
   * @name cart.service
   * @param {ng.$window} $window
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   * @param {application.service} applicationService
   * @param {address.service} addressService
   */
  function Svc($window, $http, config, utils, applicationService, addressService) {
    var self = this;
    //this.plans = [];
    this.apps = [];
    this.showing = false;
    var serviceBase = config.paths.services;

    /**
     * @name cart.service.getApps
     * @methodOf cart.service
     * @returns {HttpPromise<ifp_app[]>}
     */
    this.getApps = function () {

      return $http.get(serviceBase + '/cart')
        .then(utils.dataOrArray)
        .then(function (ifp_apps) {
          self.apps = ifp_apps;
          //
          //self.apps = _.map(ifp_apps, function(ifp_app){
          //  var planInfo = ifp_app.app_json.plan;
          //
          //  return {
          //    appId: ifp_app.app_id,
          //    type: ifp_app.type,
          //    applicants: ifp_app.members,
          //    carrierName: planInfo && planInfo.carrier || '',
          //    name: planInfo && planInfo.fullName || planInfo.name || '',
          //    premiumMonth: Number(ifp_app.premium) || null,
          //    plan: planInfo,
          //    ifpApp: ifp_app
          //  };
          //});

          return self.apps;
        });
    };

    /**
     * @name cart.service.purchase
     * @methodOf cart.service
     * @param {string[]} app_ids
     * @param {number} billing_id
     * @param {DateOnly} effective_date
     * @returns {HttpPromise<CartPurchaseDetails[]>}
     */
    this.purchase = function (app_ids, billing_id, effective_date) {
      return $http.post(serviceBase + '/cart/purchase', {
          appIds: app_ids,
          billingId: billing_id,
          effectiveDate: effective_date
        })
        .then(utils.dataOrArray)
        .then(function (purchaseDetails) {
          // modify any purchased apps in the cart with updated purchase detail information
          return _.each(purchaseDetails, function (pd) {
            var app = _.findWhere(self.apps, {app_id: pd.app_id});
            if (app) {
              app.ifp_enroll_statuses = pd.ifp_enroll_statuses;
              app.start_date = pd.start_date;
            }
          });
        })
    };

    this.clearApps = function () {
      self.apps = [];
    };

    /**
     * @name cart.service.removeApp
     * @methodOf cart.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @returns {ifp_app[]}
     */
    this.removeApp = function (userModel, app_id) {
      return applicationService.deletePlan(userModel, app_id)
        .then(function (response) {
          // Return updated plan list to display
          self.apps = _.reject(self.apps, {app_id: app_id});
          return self.apps;
        });
    };

    /**
     * @name cart.service.getPremiumTotal
     * @methodOf cart.service
     * @returns {number}
     */
    this.getPremiumTotal = function () {
      return _.reduce(this.apps, function (memo, app) {
        var premium = _.isNumber(app.premium) ? app.premium : parseFloat(app.premium);
        return memo + premium;
      }, 0);
    };

    this.show = function () {
      if (!this.showing) {
        $window.scrollTo(0, 0);
      }

      this.showing = true;
    };

    this.hide = function () {
      this.showing = false;
    };

    this.toggle = function () {
      this.showing ? this.hide() : this.show();
    };

    /**
     * @name cart.service.getAppByType
     * @methodOf cart.service
     * @param {string} type
     * @returns {ifp_app}
     */
    this.getAppByType = function (type) {
      return _.findWhere(this.apps, {type: type});
    };

    /**
     * @name cart.service.hasAppType
     * @methodOf cart.service
     * @param {string} type
     * @returns {boolean}
     */
    this.hasAppType = function (type) {
      return !!this.getAppByType(type);
    };

    /**
     * @name cart.service.updateDisplayPrice
     * @methodOf cart.service
     * @param {number} newPremium
     * @param {string} [type=health]
     */
    this.updateDisplayPrice = function (newPremium, type) {
      if (newPremium) {
        var app = self.getAppByType(type || 'health');

        if (newPremium != app.premium) {
          //healthApp.ifpApp.premium = newPremium;
          app.premium = newPremium;
        }
      }
    };

    /**
     * Update client side members of app in cart
     * @name cart.service.updateAppMembers
     * @methodOf cart.service
     * @param {string} appId
     * @param {Array<Object>} updatedMembers
     */
    this.updateAppMembers = function (appId, updatedMembers) {
      var app = _.findWhere(self.apps, {app_id: appId});
      if (app) {
        app.members = updatedMembers;
      }
    };

    /**
     * @name cart.service.saveAddress
     * @methodOf cart.service
     * @param {Address} address
     * @returns {HttpPromise<Address>}
     */
    this.saveAddress = function(address){
      return $http.post(serviceBase + '/cart/address', { app_ids: _.pluck(this.apps, 'app_id'), address: addressService.cleanPhone(address) })
        .then(utils.dataOrObject);
    };

    /**
     * @typedef {Object} CartTrackingPayload
     * @property {boolean} Health
     * @property {boolean} Dental
     * @property {number} 'Health Premium'
     * @property {number} 'Dental Premium'
     * @property {number} 'Subsidy Amount'
     * @property {number} 'Total Cart Value'
     * @property {number} 'Stride Plan ID'
     * @property {string} 'HIOS ID'
     */

    /**
     * @name cart.service.getTrackingPayload
     * @methodOf cart.service
     * @returns {CartTrackingPayload}
     */
    this.getTrackingPayload = function(){
      var healthApp = self.getAppByType('health');
      var dentalApp = self.getAppByType('dental');

      return {
        'Health': !!healthApp,
        'Dental': !!dentalApp,
        'Health Premium': _.get(healthApp, 'premium', null),
        'Dental Premium': _.get(dentalApp, 'premium', null),
        'Subsidy Amount': _.get(healthApp, 'app_json.plan.mods.savings.subsidy', 0),
        'Total Cart Value': self.getPremiumTotal(),
        'Stride Plan ID': _.get(healthApp, 'app_json.plan.id'),
        'HIOS ID': _.get(healthApp, 'app_json.plan.planId')
      };
    };
  }

  Svc.$inject = ['$window', '$http', 'config', 'utils', 'application.service', 'address.service'];

  angular.module('cart')
    .service('cart.service', Svc);
}());

/**
 * @typedef {Object} CartPurchaseDetails
 * @property {string} app_id
 * @property {ifp_enroll_status[]} ifp_enroll_statuses
 * @property {DateOnly} start_date
 */

(function () {

  /**
   * Configuration settings shared around the application
   * @typedef {object} config
   * @property {object} paths
   * @property {object} brandMap
   * @property {object} partner
   * @property {object} ages
   * @property {object} fb
   * @property {object} metalTiers
   */
  var module = angular.module('config', []);

  /**
   * @name config.partners
   * @type {string[]}
   */
  var partners = [
    'care',
    'etsy',
    'handy',
    'homebase',
    'icracked',
    'postmates',
    'intuit',
    'qbse',
    'taskrabbit',
    'uber',
    'uship',
    'usnews',
    'workmarket',
    'payable'
  ];

  /**
   * Common paths used in the application
   * @name config.paths
   * @const {object}
   * @property {string} root
   * @property {string} partials
   * @property {string} services
   * @property {string} search
   * @property {string} translations
   * @property {string} notification
   */
  var paths = {
    root: '/',
    partials: '',
    services: '/service',
    search: '/search',
    translations: '/translations',
    notification: '/notification'
  };

  /**
   * Sub domains mapped to co-brands that we currently support
   * @name config.brandMap
   * @const {object}
   */
  var brandMap = {};
  _.each(partners, function(partner){
    brandMap[partner] = brandMap['dev-' + partner] = partner;
  });

  /**
   * Partner based configuration settings
   * @name config.partner
   * @const {{landing: string[]}}
   */
  var partner = {
    landing: _.without(partners, 'handy', 'qbse'),
    finance: _.without(partners, 'intuit'),
    verify: ['care', 'homebase', 'intuit', 'payable', 'uber', 'workmarket'],
    flushots: ['uber'],
    returnBtn: ['care', 'intuit']
  };

  /**
   * Age ranges based on applicant type
   * @name config.ages
   * @const {{primary: number[], spouse: number[], dependent: number[]}}
   */
  var ages = {
    primary: [18, 64],
    spouse: [16, 64],
    dependent: [0, 25]
  };

  /**
   * Facebook settings
   * @name config.fb
   * @const {{appId: string}}
   */
  var fb = {
    appId: '812777325427213'
  };

  /**
   * Google settings
   * @name config.google
   * @const {{apiKey: string}}
   */
  var google = {
    apiKey: 'AIzaSyDWWhB_txB-UYSFFWbGcZzM-vpYsdWArHM'
  };

  /**
   * Metal tier enum
   * @name config.metalTiers
   * @const {{platinum: number, gold: number, silver: number, bronze: number, catastrophic: number}}
   */
  var metalTiers = {
    platinum: 0,
    gold: 1,
    silver: 2,
    bronze: 3,
    catastrophic: 4
  };

  // TODO: change this to just be one constant object
  module
    .constant('config.paths', paths)
    .constant('config.brandMap', brandMap)
    .constant('config.partner', partner)
    .constant('config.ages', ages)
    .constant('config.fb', fb)
    .constant('config.metalTiers', metalTiers);

  module.constant('config', {
    paths: paths,
    brandMap: brandMap,
    allPartners: partners,
    partner: partner,
    ages: ages,
    fb: fb,
    google: google,
    metalTiers: metalTiers,
    phone: {
      support: '415-930-9110'
    },
    version: '2.43.0'
  });

}());

/**
 * @name config.service
 */

angular.module('config')
  .factory('config.service', [
    '$q',
    '$http',
    '$rootScope',
    '$location',
    'config',
    function($q, $http, $rootScope, $location, config){
      var _defaultLocale = 'en-US';
      var _locale = _defaultLocale;
      var servicesPath = config.paths.services;

      var exports = {
        env: 'dev',

        /**
         * @name config.service.isLocal
         * @methodOf config.service
         * @returns {boolean}
         */
        isLocal: function(){
          return exports.env === 'localhost';
        },
        /**
         * @name config.service.isDev
         * @methodOf config.service
         * @returns {boolean}
         */
        isDev: function(){
          return exports.env === 'dev';
        },
        /**
         * @name config.service.isProd
         * @methodOf config.service
         * @returns {boolean}
         */
        isProd: function(){
          return exports.env === 'production';
        },
        /**
         * @name config.service.isPartner
         * @methodOf config.service
         * @returns {boolean}
         */
        isPartner: function(){
          return _.contains(config.allPartners, exports.getBrand());
        },
        /**
         * @name config.service.isEnabled
         * @methodOf config.service
         * @param {string} key
         * @returns {boolean}
         */
        isEnabled: function(key){
          // default to enabled
          var enabled = true;

          if (_.isArray(config.partner[key])){
            enabled = _.contains(config.partner[key], exports.getBrand());
          }

          return enabled;
        },
        /**
         * @name config.service.getBrand
         * @methodOf config.service
         * @returns {string}
         */
        getBrand: function(){
          // this is getting set in the buildStrideJs gulp task
          return 'stride';
        },
        getLocale: function(){
          return _locale;
        },
        setLocale: function(locale){
          var wasChanged = false;
          if (!locale) {
            locale = _defaultLocale;
          }

          if (locale !== _locale) {
            _locale = locale;
            wasChanged = true;
            $rootScope.$broadcast('locale-updated');
          }

          return wasChanged;
        },
        //fetchConfig: function(name){
        //  return $http
        //    .get(servicesPath + '/content/' + exports.getBrand() + '/config/' + name + '/' + exports.getLocale())
        //    .then(function(response){
        //      var data = response ? response.data : {};
        //      return data.fields ? data.fields.config : {};
        //    });
        //},
        getEntry: function(entryId, depth, locale){
          return $http
            .get(servicesPath + '/content/entry/' + entryId + '/' + depth, {
              params: { locale: locale || _defaultLocale },
              cache: true
            })
            .then(function(response){
              return response && response.data && response.data.data || {};
            });
        }
        //getEntries: function(entryIdArray, depth, locale){
        //  return $http
        //    .get(servicesPath + '/content/entries/' + entryIdArray.join(',') + '/' + depth, {
        //      params: { locale: locale || _defaultLocale },
        //      cache: true
        //    })
        //    .then(function(response){
        //      return response && response.data && response.data.data || {};
        //    });
        //}
      };


      return exports;
    }
  ]);

/** @namespace content **/
angular.module('content', ['config', 'common']);
/**
 * @name content.service
 */

angular.module('content')
  .factory('content.service', [
    '$http',
    'config.paths',
    'utils',
    'config.service',
    /**
     * @param {ng.$http} $http
     * @param {config.paths} paths
     * @param {utils} utils
     * @param {config.service} configService
     */
    function($http, paths, utils, configService) {

      function resolveSection(sectionName){
        return $http
          .get(paths.services + '/content/' + configService.getBrand() + '/section/' + sectionName + '/' + configService.getLocale())
          .then(function(response){
            return response.data;
          })
          .then(function(section){
            section.fields.pages = _.filter(section.fields.pages, function(page){
              return !!(page.fields && page.fields.key);
            });

            _.each(section.fields.pages, function(page){
              return addSref(section, page);
            });
            return section;
          });
      }

      function addSref(section, page){
        page.sref = getSref(section, page);
        page.params = getStateParams(section, page);

        if (page.fields.pages){
          page.fields.pages = _.filter(page.fields.pages, function(subPage){
            return !!(subPage.fields && subPage.fields.key);
          });


          _.each(page.fields.pages, function(subPage){
            subPage.sref = getSref(section, page, subPage);
            subPage.params = getStateParams(section, page, subPage);
          });
        }
      }

      function getSref(section, page, subPage){
        var sref = getStateName(section, page, subPage);
        var params = getStateParams(section, page, subPage);

        sref += "( " + JSON.stringify(params) + " )";

        return sref;
      }

      function getStateName(section, page, subPage){
        var stateName = section.fields.key + '.page';

        if (subPage){
          stateName += '.subPage';
        }

        return stateName;
      }

      function getStateParams(section, page, subPage){
        var params = {
          pageKey: page.fields.key
        };

        if (subPage && subPage.fields){
          params.subPageKey = subPage.fields.key;
        }

        return params;
      }

      function getPageByKey(sectionObj, pageKey){
        return _.find(sectionObj.fields.pages, function(page){
          return page.fields.key === pageKey;
        });
      }

      function getSubPageByKey(sectionObj, pageKey, subPageKey){
        var result;
        var page = getPageByKey(sectionObj, pageKey);

        if (page){
          result = _.find(page.fields.pages, function(subPage){
            return subPage.fields.key === subPageKey;
          });
        }

        return result;
      }

      function getSnippets(parentObj){
        var obj = {};

        if (parentObj && parentObj.fields && parentObj.fields.snippets){
          parentObj.fields.snippets.forEach(function(snippet){
            obj[utils.dashToCamel(snippet.fields.key)] = snippet.fields.value;
          });
        }

        return obj;
      }

      return {
        // resolves are server calls
        resolveSection: resolveSection,

        // gets deal with in memory data
        getSref: getSref,
        getStateName: getStateName,
        getStateParams: getStateParams,
        getPageByKey: getPageByKey,
        getSubPageByKey: getSubPageByKey,
        getSnippets: getSnippets,

        /**
         * @name content.service.getByType
         * @methodOf content.service
         * @param {string} type
         * @param {object} params
         * @returns {Promise<any[]>}
         */
        getByType: function(type, params){
          return $http.get(paths.services + '/content/type/' + type, { params: params })
            .then(utils.dataOrArray);
        }
      };
    }
  ]);
//
// showdown.js -- A javascript port of Markdown.
//
// Copyright (c) 2007 John Fraser.
//
// Original Markdown Copyright (c) 2004-2005 John Gruber
//   <http://daringfireball.net/projects/markdown/>
//
// Redistributable under a BSD-style open source license.
// See license.txt for more information.
//
// The full source distribution is at:
//
//				A A L
//				T C A
//				T K B
//
//   <http://www.attacklab.net/>
//
//
// Wherever possible, Showdown is a straight, line-by-line port
// of the Perl version of Markdown.
//
// This is not a normal parser design; it's basically just a
// series of string substitutions.  It's hard to read and
// maintain this way,  but keeping Showdown close to the original
// design makes it easier to port new features.
//
// More importantly, Showdown behaves like markdown.pl in most
// edge cases.  So web applications can do client-side preview
// in Javascript, and then build identical HTML on the server.
//
// This port needs the new RegExp functionality of ECMA 262,
// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers
// should do fine.  Even with the new regular expression features,
// We do a lot of work to emulate Perl's regex functionality.
// The tricky changes in this file mostly have the "attacklab:"
// label.  Major or self-explanatory changes don't.
//
// Smart diff tools like Araxis Merge will be able to match up
// this file with markdown.pl in a useful way.  A little tweaking
// helps: in a copy of markdown.pl, replace "#" with "//" and
// replace "$text" with "text".  Be sure to ignore whitespace
// and line endings.
//
//
// Showdown usage:
//
//   var text = "Markdown *rocks*.";
//
//   var converter = new Showdown.converter();
//   var html = converter.makeHtml(text);
//
//   alert(html);
//
// Note: move the sample code to the bottom of this
// file before uncommenting it.
//
//
// Showdown namespace
//

angular.module('content')
  .factory('content.showdown', function(){


    var Showdown={extensions:{}},forEach=Showdown.forEach=function(a,b){if(typeof a.forEach=="function")a.forEach(b);else{var c,d=a.length;for(c=0;c<d;c++)b(a[c],c,a)}},stdExtName=function(a){return a.replace(/[_-]||\s/g,"").toLowerCase()};Showdown.converter=function(a){var b,c,d,e=0,f=[],g=[];if(typeof module!="undefind"&&typeof exports!="undefined"&&typeof require!="undefind"){var h=require("fs");if(h){var i=h.readdirSync((__dirname||".")+"/extensions").filter(function(a){return~a.indexOf(".js")}).map(function(a){return a.replace(/\.js$/,"")});Showdown.forEach(i,function(a){var b=stdExtName(a);Showdown.extensions[b]=require("./extensions/"+a)})}}this.makeHtml=function(a){return b={},c={},d=[],a=a.replace(/~/g,"~T"),a=a.replace(/\$/g,"~D"),a=a.replace(/\r\n/g,"\n"),a=a.replace(/\r/g,"\n"),a="\n\n"+a+"\n\n",a=M(a),a=a.replace(/^[ \t]+$/mg,""),Showdown.forEach(f,function(b){a=k(b,a)}),a=z(a),a=m(a),a=l(a),a=o(a),a=K(a),a=a.replace(/~D/g,"$$"),a=a.replace(/~T/g,"~"),Showdown.forEach(g,function(b){a=k(b,a)}),a};if(a&&a.extensions){var j=this;Showdown.forEach(a.extensions,function(a){typeof a=="string"&&(a=Showdown.extensions[stdExtName(a)]);if(typeof a!="function")throw"Extension '"+a+"' could not be loaded.  It was either not found or is not a valid extension.";Showdown.forEach(a(j),function(a){a.type?a.type==="language"||a.type==="lang"?f.push(a):(a.type==="output"||a.type==="html")&&g.push(a):g.push(a)})})}var k=function(a,b){if(a.regex){var c=new RegExp(a.regex,"g");return b.replace(c,a.replace)}if(a.filter)return a.filter(b)},l=function(a){return a+="~0",a=a.replace(/^[ ]{0,3}\[(.+)\]:[ \t]*\n?[ \t]*<?(\S+?)>?[ \t]*\n?[ \t]*(?:(\n*)["(](.+?)[")][ \t]*)?(?:\n+|(?=~0))/gm,function(a,d,e,f,g){return d=d.toLowerCase(),b[d]=G(e),f?f+g:(g&&(c[d]=g.replace(/"/g,"&quot;")),"")}),a=a.replace(/~0/,""),a},m=function(a){a=a.replace(/\n/g,"\n\n");var b="p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside",c="p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside";return a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\b[^\r]*?\n<\/\2>[ \t]*(?=\n+))/gm,n),a=a.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\b[^\r]*?<\/\2>[ \t]*(?=\n+)\n)/gm,n),a=a.replace(/(\n[ ]{0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g,n),a=a.replace(/(\n\n[ ]{0,3}<!(--[^\r]*?--\s*)+>[ \t]*(?=\n{2,}))/g,n),a=a.replace(/(?:\n\n)([ ]{0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g,n),a=a.replace(/\n\n/g,"\n"),a},n=function(a,b){var c=b;return c=c.replace(/\n\n/g,"\n"),c=c.replace(/^\n/,""),c=c.replace(/\n+$/g,""),c="\n\n~K"+(d.push(c)-1)+"K\n\n",c},o=function(a){a=v(a);var b=A("<hr />");return a=a.replace(/^[ ]{0,2}([ ]?\*[ ]?){3,}[ \t]*$/gm,b),a=a.replace(/^[ ]{0,2}([ ]?\-[ ]?){3,}[ \t]*$/gm,b),a=a.replace(/^[ ]{0,2}([ ]?\_[ ]?){3,}[ \t]*$/gm,b),a=x(a),a=y(a),a=E(a),a=m(a),a=F(a),a},p=function(a){return a=B(a),a=q(a),a=H(a),a=t(a),a=r(a),a=I(a),a=G(a),a=D(a),a=a.replace(/  +\n/g," <br />\n"),a},q=function(a){var b=/(<[a-z\/!$]("[^"]*"|'[^']*'|[^'">])*>|<!(--.*?--\s*)+>)/gi;return a=a.replace(b,function(a){var b=a.replace(/(.)<\/?code>(?=.)/g,"$1`");return b=N(b,"\\`*_"),b}),a},r=function(a){return a=a.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,s),a=a.replace(/(\[((?:\[[^\]]*\]|[^\[\]])*)\]\([ \t]*()<?(.*?(?:\(.*?\).*?)?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,s),a=a.replace(/(\[([^\[\]]+)\])()()()()()/g,s),a},s=function(a,d,e,f,g,h,i,j){j==undefined&&(j="");var k=d,l=e,m=f.toLowerCase(),n=g,o=j;if(n==""){m==""&&(m=l.toLowerCase().replace(/ ?\n/g," ")),n="#"+m;if(b[m]!=undefined)n=b[m],c[m]!=undefined&&(o=c[m]);else{if(!(k.search(/\(\s*\)$/m)>-1))return k;n=""}}n=N(n,"*_");var p='<a href="'+n+'"';return o!=""&&(o=o.replace(/"/g,"&quot;"),o=N(o,"*_"),p+=' title="'+o+'"'),p+=">"+l+"</a>",p},t=function(a){return a=a.replace(/(!\[(.*?)\][ ]?(?:\n[ ]*)?\[(.*?)\])()()()()/g,u),a=a.replace(/(!\[(.*?)\]\s?\([ \t]*()<?(\S+?)>?[ \t]*((['"])(.*?)\6[ \t]*)?\))/g,u),a},u=function(a,d,e,f,g,h,i,j){var k=d,l=e,m=f.toLowerCase(),n=g,o=j;o||(o="");if(n==""){m==""&&(m=l.toLowerCase().replace(/ ?\n/g," ")),n="#"+m;if(b[m]==undefined)return k;n=b[m],c[m]!=undefined&&(o=c[m])}l=l.replace(/"/g,"&quot;"),n=N(n,"*_");var p='<img src="'+n+'" alt="'+l+'"';return o=o.replace(/"/g,"&quot;"),o=N(o,"*_"),p+=' title="'+o+'"',p+=" />",p},v=function(a){function b(a){return a.replace(/[^\w]/g,"").toLowerCase()}return a=a.replace(/^(.+)[ \t]*\n=+[ \t]*\n+/gm,function(a,c){return A('<h1 id="'+b(c)+'">'+p(c)+"</h1>")}),a=a.replace(/^(.+)[ \t]*\n-+[ \t]*\n+/gm,function(a,c){return A('<h2 id="'+b(c)+'">'+p(c)+"</h2>")}),a=a.replace(/^(\#{1,6})[ \t]*(.+?)[ \t]*\#*\n+/gm,function(a,c,d){var e=c.length;return A("<h"+e+' id="'+b(d)+'">'+p(d)+"</h"+e+">")}),a},w,x=function(a){a+="~0";var b=/^(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm;return e?a=a.replace(b,function(a,b,c){var d=b,e=c.search(/[*+-]/g)>-1?"ul":"ol";d=d.replace(/\n{2,}/g,"\n\n\n");var f=w(d);return f=f.replace(/\s+$/,""),f="<"+e+">"+f+"</"+e+">\n",f}):(b=/(\n\n|^\n?)(([ ]{0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(~0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/g,a=a.replace(b,function(a,b,c,d){var e=b,f=c,g=d.search(/[*+-]/g)>-1?"ul":"ol",f=f.replace(/\n{2,}/g,"\n\n\n"),h=w(f);return h=e+"<"+g+">\n"+h+"</"+g+">\n",h})),a=a.replace(/~0/,""),a};w=function(a){return e++,a=a.replace(/\n{2,}$/,"\n"),a+="~0",a=a.replace(/(\n)?(^[ \t]*)([*+-]|\d+[.])[ \t]+([^\r]+?(\n{1,2}))(?=\n*(~0|\2([*+-]|\d+[.])[ \t]+))/gm,function(a,b,c,d,e){var f=e,g=b,h=c;return g||f.search(/\n{2,}/)>-1?f=o(L(f)):(f=x(L(f)),f=f.replace(/\n$/,""),f=p(f)),"<li>"+f+"</li>\n"}),a=a.replace(/~0/g,""),e--,a};var y=function(a){return a+="~0",a=a.replace(/(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=~0))/g,function(a,b,c){var d=b,e=c;return d=C(L(d)),d=M(d),d=d.replace(/^\n+/g,""),d=d.replace(/\n+$/g,""),d="<pre><code>"+d+"\n</code></pre>",A(d)+e}),a=a.replace(/~0/,""),a},z=function(a){return a+="~0",a=a.replace(/(?:^|\n)```(.*)\n([\s\S]*?)\n```/g,function(a,b,c){var d=b,e=c;return e=C(e),e=M(e),e=e.replace(/^\n+/g,""),e=e.replace(/\n+$/g,""),e="<pre><code"+(d?' class="'+d+'"':"")+">"+e+"\n</code></pre>",A(e)}),a=a.replace(/~0/,""),a},A=function(a){return a=a.replace(/(^\n+|\n+$)/g,""),"\n\n~K"+(d.push(a)-1)+"K\n\n"},B=function(a){return a=a.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm,function(a,b,c,d,e){var f=d;return f=f.replace(/^([ \t]*)/g,""),f=f.replace(/[ \t]*$/g,""),f=C(f),b+"<code>"+f+"</code>"}),a},C=function(a){return a=a.replace(/&/g,"&amp;"),a=a.replace(/</g,"&lt;"),a=a.replace(/>/g,"&gt;"),a=N(a,"*_{}[]\\",!1),a},D=function(a){return a=a.replace(/(\*\*|__)(?=\S)([^\r]*?\S[*_]*)\1/g,"<strong>$2</strong>"),a=a.replace(/(\*|_)(?=\S)([^\r]*?\S)\1/g,"<em>$2</em>"),a},E=function(a){return a=a.replace(/((^[ \t]*>[ \t]?.+\n(.+\n)*\n*)+)/gm,function(a,b){var c=b;return c=c.replace(/^[ \t]*>[ \t]?/gm,"~0"),c=c.replace(/~0/g,""),c=c.replace(/^[ \t]+$/gm,""),c=o(c),c=c.replace(/(^|\n)/g,"$1  "),c=c.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm,function(a,b){var c=b;return c=c.replace(/^  /mg,"~0"),c=c.replace(/~0/g,""),c}),A("<blockquote>\n"+c+"\n</blockquote>")}),a},F=function(a){a=a.replace(/^\n+/g,""),a=a.replace(/\n+$/g,"");var b=a.split(/\n{2,}/g),c=[],e=b.length;for(var f=0;f<e;f++){var g=b[f];g.search(/~K(\d+)K/g)>=0?c.push(g):g.search(/\S/)>=0&&(g=p(g),g=g.replace(/^([ \t]*)/g,"<p>"),g+="</p>",c.push(g))}e=c.length;for(var f=0;f<e;f++)while(c[f].search(/~K(\d+)K/)>=0){var h=d[RegExp.$1];h=h.replace(/\$/g,"$$$$"),c[f]=c[f].replace(/~K\d+K/,h)}return c.join("\n\n")},G=function(a){return a=a.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g,"&amp;"),a=a.replace(/<(?![a-z\/?\$!])/gi,"&lt;"),a},H=function(a){return a=a.replace(/\\(\\)/g,O),a=a.replace(/\\([`*_{}\[\]()>#+-.!])/g,O),a},I=function(a){return a=a.replace(/<((https?|ftp|dict):[^'">\s]+)>/gi,'<a href="$1">$1</a>'),a=a.replace(/<(?:mailto:)?([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi,function(a,b){return J(K(b))}),a},J=function(a){var b=[function(a){return"&#"+a.charCodeAt(0)+";"},function(a){return"&#x"+a.charCodeAt(0).toString(16)+";"},function(a){return a}];return a="mailto:"+a,a=a.replace(/./g,function(a){if(a=="@")a=b[Math.floor(Math.random()*2)](a);else if(a!=":"){var c=Math.random();a=c>.9?b[2](a):c>.45?b[1](a):b[0](a)}return a}),a='<a href="'+a+'">'+a+"</a>",a=a.replace(/">.+:/g,'">'),a},K=function(a){return a=a.replace(/~E(\d+)E/g,function(a,b){var c=parseInt(b);return String.fromCharCode(c)}),a},L=function(a){return a=a.replace(/^(\t|[ ]{1,4})/gm,"~0"),a=a.replace(/~0/g,""),a},M=function(a){return a=a.replace(/\t(?=\t)/g,"    "),a=a.replace(/\t/g,"~A~B"),a=a.replace(/~B(.+?)~A/g,function(a,b,c){var d=b,e=4-d.length%4;for(var f=0;f<e;f++)d+=" ";return d}),a=a.replace(/~A/g,"    "),a=a.replace(/~B/g,""),a},N=function(a,b,c){var d="(["+b.replace(/([\[\]\\])/g,"\\$1")+"])";c&&(d="\\\\"+d);var e=new RegExp(d,"g");return a=a.replace(e,O),a},O=function(a,b){var c=b.charCodeAt(0);return"~E"+c+"E"}},typeof module!="undefined"&&(module.exports=Showdown),typeof define=="function"&&define.amd&&define("showdown",function(){return Showdown});

    return Showdown;

  })
  .filter('showdown', [
    'content.showdown',
    function(showdown){
      var converter = new showdown.converter();

      return function (text) {
        var markdown = text || '';
        return converter.makeHtml(markdown);
      };
    }
  ]);



/**
 * @namespace dental
 */
angular.module('dental', ['member', 'common', 'translate', 'application'])
  .constant('dental.documentUrls', {
    1: 'https://s3.amazonaws.com/download.stridehealth.com/Renaissance-PPO-Plan-1.pdf',
    2: 'https://s3.amazonaws.com/download.stridehealth.com/Renaissance-PPO-MAC-Plan-2.pdf',
    3: 'https://s3.amazonaws.com/download.stridehealth.com/Renaissance-PPO-MAC-Plan-3-R.pdf'
  });
/**
 * @namespace doctor
 */
angular.module('doctor', ['ui.router', 'search', 'common', 'google', 'session']);


/**
 * @typedef {Object} doctor.model
 * @property {number} id
 * @property {number} npi
 * @property {string} firstName
 * @property {string} middleName
 * @property {string} lastName
 * @property {string} addr1
 * @property {string} addr2
 * @property {string} city
 * @property {string} state
 * @property {string} zip5
 * @property {string} phone
 * @property {string} specialty
 * @property {string} facilityType
 * @property {string} groupName
 * @property {Object} networkStatus
 * @property {boolean} networkStatus.inNetwork
 * @property {string} networkStatus.lastSeenOn
 * @property {Object} locationGeography
 * @property {number} locationGeography.latitude
 * @property {number} locationGeography.longitude
 * @property {doctor.specialty[]} specialities
 */

/**
 * @typedef {Object} MemberProvider
 * @property {number} id
 * @property {string} user_id
 * @property {string} member_id
 * @property {number} provider_id
 * @property {number} npi
 */

/**
 * @typedef {Object} doctor.specialty
 * @property {string} specialty
 * @property {string} subspecialty
 */
/**
 * @namespace document
 */
angular.module('document', ['config', 'common']);
(function () {

  /**
   * @name document.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   * @constructor
   */
  function Svc($q, $http, config, utils) {

    /**
     * @name document.service.getPolicy
     * @methodOf document.service
     * @param {Object} params
     * @param {string} params.fileName
     * @param {string} params.fileType
     * @param {number} params.fileSize
     * @param {string} params.bucket
     * @returns {Promise}
     */
    this.getPolicy = function (params) {
      return $http.get(config.paths.services + '/document/policy', {params: params})
        .then(utils.dataOrObject);
    };


    /**
     * @name document.service.getDocTags
     * @methodOf document.service
     * @param {Object} params
     * @param {string} params.appId
     * @returns {Promise<[*]>}
     */
    this.getDocTags = function (params) {
      if (!params.appId){
        return $q.when([]);
      }

      return $http.get(config.paths.services + '/documents', {params: params})
        .then(utils.dataOrArray);
    };

    this.postDoc = function (params) {
      return $http.post(config.paths.services + '/document', params)
        .then(utils.dataOrObject);
    };

    this.getDoc = function (params) {
      return $http.get(config.paths.services + '/document', {params: params})
        .then(utils.dataOrObject);
    };

    this.deleteDoc = function (params) {
      return $http.delete(config.paths.services + '/document', {params: params})
        .then(utils.dataOrObject);
    };
  }

  Svc.$inject = ['$q', '$http', 'config', 'utils'];

  angular.module('document')
    .service('document.service', Svc);
}());
/**
 * @namespace drug
 */
angular.module('drug', ['search', 'common', 'session'])

/**
 * @typedef {Object} drug.formMap
 *
 */

  .constant('drug.formMap', {
    default: {
      singular: 'dose',
      plural: 'doses'
    },
    aerosol: {
      singular: 'inhaler',
      plural: 'inhalers'
    },
    capsule: {
      singular: 'capsule',
      plural: 'capsules'
    },
    tablet: {
      singular: 'tablet',
      plural: 'tablets'
    },
    pellet: {
      singular: 'tablet',
      plural: 'tablets'
    },
    injection: {
      singular: 'injection',
      plural: 'injections'
    },
    cream: {
      singular: 'cream',
      plural: 'creams'
    },
    crystals: {
      singular: 'crystal',
      plural: 'crystals'
    },
    solution: {
      singular: 'solution',
      plural: 'solutions'
    },
    lotion: {
      singular: 'lotion',
      plural: 'lotions'
    },
    liquid: {
      singular: 'liquid',
      plural: 'liquids'
    },
    film: {
      singular: 'film',
      plural: 'films'
    },
    gel: {
      singular: 'gel',
      plural: 'gels'
    },
    granules: {
      singular: 'granule',
      plural: 'granules'
    },
    implant: {
      singular: 'implant',
      plural: 'implants'
    },
    inhaler: {
      singular: 'inhaler',
      plural: 'inhalers'
    },
    kit: {
      singular: 'kit',
      plural: 'kits'
    },
    lozenge: {
      singular: 'lozenge',
      plural: 'lozenges'
    },
    lollipop: {
      singular: 'lollipop',
      plural: 'lollipops'
    },
    nebulizer: {
      singular: 'solution',
      plural: 'solutions'
    },
    oil: {
      singular: 'oil',
      plural: 'oils'
    },
    ointment: {
      singular: 'ointment',
      plural: 'ointments'
    },
    packet: {
      singular: 'packet',
      plural: 'packets'
    },
    pad: {
      singular: 'pad',
      plural: 'pads'
    },
    powder: {
      singular: 'powder',
      plural: 'powders'
    },
    paste: {
      singular: 'paste',
      plural: 'pastes'
    },
    patch: {
      singular: 'patch',
      plural: 'patches'
    },
    insert: {
      singular: 'ring',
      plural: 'rings'
    },
    shampoo: {
      singular: 'shampoo',
      plural: 'shampoo'
    },
    strip: {
      singular: 'strip',
      plural: 'strips'
    },
    suppository: {
      singular: 'suppository',
      plural: 'suppositories'
    },
    suspension: {
      singular: 'canister',
      plural: 'canisters'
    },
    swab: {
      singular: 'swab',
      plural: 'swabs'
    },
    tape: {
      singular: 'tape',
      plural: 'tapes'
    }
  });

/**
 * @typedef {Object} drug.model
 * @property {number}   id
 * @property {string}   product name of the drug
 * @property {boolean}  qtyDivisible
 * @property {string}   brand
 * @property {string}   doseForm
 * @property {string}   generic
 * @property {number}   genericId
 * @property {string}   relatedBrand
 * @property {number}   fillQty
 * @property {number}   fillCount
 * @property {number}   durationDays
 * @property {number}   dateAdded UTC timestamp
 * @property {drug.dosageResult} dose
 * @property {drug.pharmacyResult} pharmacy
 */

/**
 * @typedef {Object} drug.searchResultFreq
 * @property {string} freq
 * @property {string} timePeriod
 * @property {string} timePeriodId
 */

/**
 * @typedef {Object} drug.searchResult
 * @property {string}   product
 * @property {number}   id
 * @property {boolean}  qtyDivisible
 * @property {drug.searchResultFreq[]} freqs
 * @property {string}   brand
 * @property {string}   doseForm
 * @property {string}   [generic]
 * @property {number}   [genericId]
 * @property {string}   [relatedBrand]
 */

/**
 * @typedef {Object} drug.dosageResult
 * @property {number}   id
 * @property {number}   drugId
 * @property {string}   ndc
 * @property {string}   strength
 * @property {number}   qty
 * @property {string}   gpi
 * @property {string}   mony
 * @property {string}   otc
 * @property {string}   route
 * @property {boolean}  maintenance
 */

/**
 * @typedef {Object} drug.quoteResult
 * @property {number} meanPrice
 * @property {number} quantity
 * @property {string} ndc
 * @property {string} zip5
 */

/**
 * @typedef {Object} drug.pharmacyResult
 * @property {string} name
 * @property {number} discountPrice
 * @property {number} planPrice
 * @property {number} distanceMi
 * @property {string} lowestPrice 'discount' or 'plan'
 * @property {Address} address
 * @property {string} phone
 */

/**
 * @typedef {Object} drug.frequency
 * @property {number} timePeriodId
 * @property {number} intake
 * @property {number} fills
 */

/**
 * @typedef {Object} MemberDrug
 * @property {number|UUID} id UUID only if user is not logged in
 * @property {UUID} user_id
 * @property {UUID} member_id
 * @property {drug.model} drug_json
 * @property {Date} created_on
 * @property {Date} updated_on
 */
(function(){
  /**
   * Grabs and lists out the dosages for the current drug
   * @constructor drug.dose.controller
   * @param {ui.router.state.$state} $state
   * @param {drug.service} drugService
   * @param {drug.editor} drugEditor
   */
  function DrugDoseController($state, drugService, drugEditor){

    if (drugEditor.getModel() === null){
      return;
    }

    var self = this;
    var model = drugEditor.getModel();

    self.drugName = model.name;
    self.doses = drugEditor.getDosages();

    if (self.doses.length === 0){

      drugService.getDosages(model.id)
        .then(function(dosages){
          self.processResults(dosages);
          drugEditor.storeDosages(self.doses);
        });
    }

    /**
     * Set the dosage and go to the next state
     * @param {drug.dosageResult} dose
     */
    self.choose = function(dose){
      drugEditor.setDose(dose);
      $state.go($state.current.data.nextState);
    };

    /**
     * Any zero dose will be added first
     * If there aren't any non-zero doses, add the first
     * Otherwise, allow the user to choose any of the non-zero doses
     * @param {drug.dosageResult[]} dosages
     */
    self.processResults = function(dosages){
      // look for zero strength dosages and add it
      var zeroDosage = _.find(dosages, function(dose){
        return dose.strength && dose.strength === '0';
      });

      // only count the dosages that have a strength
      var nonZeroDosages = _.filter(dosages, function(dose){
        return dose.strength && dose.strength !== '0';
      });

      if (zeroDosage){
        self.choose(zeroDosage);
      }
      else if (nonZeroDosages.length){
        self.doses = nonZeroDosages.sort(function(a, b){
          return parseFloat(a.strength) - parseFloat(b.strength);
        });
      }
      // if there aren't any dosages w/ a strength, still need the NDC attached
      // so just use the first dosage returned
      else {
        self.choose(dosages[0]);
      }
    };
  }
  DrugDoseController.$inject = ['$state', 'drug.service', 'drug.editor'];

  angular.module('drug')
    .controller('drug.dose.controller', DrugDoseController);
}());
(function(){

  /**
   * Provides functionality for building a drug model
   * @class drug.editor
   * @param {drug.formMap} drugFormMap
   */
  function DrugEditorService(drugFormMap){

    /**
     * @type {drug.model}
     * @private
     */
    var _currentDrugJson = null;
    /**
     * @type {MemberDrug}
     * @private
     */
    var _currentDrug = null;

    /**
     * This is the in memory storage of all of the possible drug data (e.g. all of the freqs, dosages) for that drug
     * @typedef {Object} drug.dataStore
     * @property {drug.searchResultFreq[]} freqs
     * @property {drug.dosageResult[]} dosages
     */

    /**
     *
     * @type {drug.dataStore}
     * @private
     */
    var _dataStore = null;

    /**
     * @name drug.editor.getModel
     * @methodOf drug.editor
     * @returns {drug.model}
     */
    this.getModel = function(){
      return _currentDrugJson;
    };

    /**
     * @name drug.editor.getCurrentDrug
     * @methodOf drug.editor
     * @returns {MemberDrug}
     */
    this.getCurrentDrug = function(){
      return _currentDrug;
    };

    /**
     * Get all possible dosages for this drug
     * @returns {drug.dosageResult[]}
     */
    this.getDosages = function(){
      if (_dataStore && _.isArray(_dataStore.dosages)){
        return _dataStore.dosages;
      }

      return [];
    };

    /**
     * @param {drug.model} drugModel
     * @returns {string}
     */
    this.getDoseForm = function(drugModel){
      var form = { singular: 'dose', plural: 'doses' };
      var mappedForm = drugFormMap[drugModel.doseForm.toLowerCase()] || drugFormMap.default;

      if (mappedForm){
        form = mappedForm;
      }

      return drugModel.fillQty === 1 ? form.singular : form.plural;
    };

    /**
     *
     * @param {drug.model} drug
     */
    this.setDrug = function(drug){
      var currentDrug = angular.copy(drug);
      var drugJson = _.omit(currentDrug.drug_json, ['freqs']);

      _currentDrug = currentDrug;
      _currentDrugJson = currentDrug.drug_json = drugJson;
      _dataStore = null;
    };

    /**
     * @param {drug.dosageResult} dosageResult
     */
    this.setDose = function(dosageResult){
      _currentDrugJson.dose = dosageResult;
    };

    /**
     * @param {number} fillQty
     * @param {number} durationDays
     */
    this.setFill = function(fillQty, durationDays){
      _currentDrugJson.fillQty = fillQty;
      _currentDrugJson.durationDays = durationDays;
    };

    /**
     * @param {number} fillCount number of times per year this prescription will be filled
     */
    this.setFillCount = function(fillCount){
      // if this is a recurring prescription
      if (fillCount === Math.MAX_VALUE){
        // how many fills in a year
        fillCount = Math.floor(365 / (_currentDrugJson.durationDays || 30));
      }

      _currentDrugJson.fillCount = fillCount;
    };

    /**
     * @param {drug.pharmacyResult} pharmacy
     */
    this.setPharmacy = function(pharmacy){
      _currentDrugJson.pharmacy = pharmacy;
    };

    this.getPharmacy = function(){
      return _currentDrugJson && _currentDrugJson.pharmacy || null;
    };

    /**
     * @param {drug.dosageResult[]} dosageResults
     */
    this.storeDosages = function(dosageResults){
      _dataStore = _.isObject(_dataStore) ? _dataStore : {};
      _dataStore.dosages = dosageResults;
    };

    /**
     * @param {string} memberId
     */
    this.setMember = function(memberId){
      _currentDrug.member_id = memberId;
    };

    this.clear = function(){
      _currentDrug = _currentDrugJson = _dataStore = null;
    };

    /**
     * @name drug.editor.complete
     * @methodOf drug.editor
     * @returns {MemberDrug}
     */
    this.complete = function(){
      if (_currentDrugJson === null){
        return null;
      }

      var copyDrug = angular.copy(_currentDrug);
      copyDrug.drug_json = angular.copy(_currentDrugJson);

      this.clear();
      return copyDrug;
    };
  }
  DrugEditorService.$inject = ['drug.formMap'];

  angular.module('drug')
    .service('drug.editor', DrugEditorService);
}());

(function(){

  /**
   * @name drug.fill.controller
   * @param {ui.router.state.$state} $state
   * @param {drug.editor} drugEditor
   * @param {drug.formMap} drugFormMap
   * @constructor
   */
  function FillController($state, drugEditor, drugFormMap){
    var model = drugEditor.getModel();
    var self = this;
    if (model === null){
      return;
    }

    this.drug = model;
    this.qtyDivisible = model.qtyDivisible;

    /**
     * @type {form.FormController}
     */
    this.form = null;

    var qtyText = drugFormMap[model.doseForm.toLowerCase()] || drugFormMap.default;

    this.drugForms = qtyText.plural;

    this.qty = null;
    this.qtyList = [
      { value: 30,      text: '30 ' + qtyText.plural },
      { value: 60,      text: '60 ' + qtyText.plural },
      { value: 90,      text: '90 ' + qtyText.plural },
      { value: 'other', text: 'other'                }
    ];
    this.inputQty = '';

    if (!this.qtyDivisible){
      this.qtyList = [
        { value: 1,       text: '1 ' + qtyText.singular },
        { value: 2,       text: '2 ' + qtyText.plural },
        { value: 3,       text: '3 ' + qtyText.plural },
        { value: 4,       text: '4 ' + qtyText.plural },
        { value: 5,       text: '5 ' + qtyText.plural },
        { value: 'other', text: 'other'               }
      ];
    }

    var dayText = ' days';
    this.days = null;
    this.dayList = [
      { value: 7,       text: '7 '  + dayText },
      { value: 15,      text: '15 ' + dayText },
      { value: 30,      text: '30 ' + dayText },
      { value: 60,      text: '60 ' + dayText },
      { value: 90,      text: '90 ' + dayText },
      { value: 'other', text: 'other'         }
    ];
    this.inputDays = '';

    // pull over the old qty and duration props from persisted data
    if (model.fillQty){
      var oldQty = _.findWhere(this.qtyList, { value: model.fillQty });
      if (_.isUndefined(oldQty)){
        this.qty = this.qtyList[this.qtyList.length - 1].value;
        this.inputQty = model.fillQty;
      }
      else {
        this.qty = oldQty.value;
      }
    }
    else {
      this.qty = this.qtyList[0].value;
    }

    if (model.durationDays){
      var oldDuration = _.findWhere(this.dayList, { value: model.durationDays });
      if (_.isUndefined(oldDuration)){
        this.days = this.dayList[this.dayList.length - 1].value;
        this.inputDays = model.durationDays;
      }
      else {
        this.days = oldDuration.value;
      }
    }
    else  {
      this.days = 30;
    }

    this.choose = function(){
      if (self.form && self.form.$valid){
        var qty = self.qty === 'other' ? parseInt(self.inputQty) : self.qty;
        var days = self.days === 'other' ? parseInt(self.inputDays) : self.days;

        drugEditor.setFill(qty, days);
        $state.go($state.current.data.nextState);
      }
    };


  }
  FillController.$inject = ['$state', 'drug.editor', 'drug.formMap'];

  angular.module('drug')
    .controller('drug.fill.controller', FillController);
}());
//(function(){
//
//  /**
//   * @constructor drug.fillSize.controller
//   * @param {ui.router.state.$state} $state
//   * @param {drug.editor} drugEditor
//   */
//  function DrugFillSizeController($state, drugEditor){
//    var model = drugEditor.getModel();
//    if (model === null){
//      return;
//    }
//
//    this.drug = model;
//    this.qtyDivisible = model.qtyDivisible;
//    this.size = '';
//    /**
//     * @type {number[]}
//     */
//    this.sizes = [15, 30, 60, 90];
//
//    this.showFreeForm = false;
//
//    // if the model has already had a frequency attached to it
//    // default the choices to that freq
//    if (model.fillSize){
//      this.size = model.fillSize.toString();
//    }
//
//    /**
//     * @param {number} size
//     */
//    this.choose = function(size){
//      drugEditor.setFillSize(size);
//      $state.go($state.current.data.nextState);
//    };
//
//    this.chooseFreeForm = function(){
//      this.choose(parseInt(this.size));
//    };
//  }
//  DrugFillSizeController.$inject = ['$state', 'drug.editor'];
//
//  angular.module('drug')
//    .controller('drug.fillSize.controller', DrugFillSizeController);
//}());
//(function(){
//
//  /**
//   * @constructor drug.frequency.controller
//   * @param {ui.router.state.$state} $state
//   * @param {drug.editor} drugEditor
//   */
//  function DrugFrequencyController($state, drugEditor){
//    var model = drugEditor.getModel();
//    if (model === null){
//      return;
//    }
//
//    this.drug = model;
//    this.freqs = drugEditor.getFreqs();
//    this.qtyDivisible = model.qtyDivisible;
//
//    /**
//     * Used in the free form select
//     * @type {string}
//     */
//    this.times = '';
//    /**
//     * Used in the free form select
//     * default timePeriod to week for specific selection
//     * @type {number}
//     */
//    this.timePeriod = 2;
//
//    /**
//     * Time periods enum is { day: 1, week: 2, month: 3, year: 4 }
//     * Used in the free form select
//     * @type {number[]}
//     */
//    this.timePeriods = [1,2,3,4];
//
//    this.showFreeForm = false;
//
//    // if the model has already had a frequency attached to it
//    // default the choices to that freq
//    if (model.freq){
//      this.times = drugEditor.getFreqAmount().toString();
//      this.timePeriod = model.freq.timePeriodId;
//    }
//
//    /**
//     * @param {drug.searchResultFreq} freq
//     */
//    this.choose = function(freq){
//      drugEditor.setFreq(freq);
//      $state.go($state.current.data.nextState);
//    };
//
//    /**
//     * Pulls info from the free form entry to create a drug.searchResultFreq and call choose
//     */
//    this.chooseFreeForm = function(){
//      /**
//       * @type {drug.searchResultFreq}
//       */
//      var freq = {
//        timePeriodId: this.timePeriod.toString(),
//        freq: this.times
//      };
//
//      this.choose(freq);
//    };
//  }
//  DrugFrequencyController.$inject = ['$state', 'drug.editor'];
//
//  angular.module('drug')
//    .controller('drug.frequency.controller', DrugFrequencyController);
//}());
(function(){

  /**
   * @param {ui.router.state.$state} $state
   * @param {drug.editor} drugEditor
   * @param {Member[]} members
   * @param {services.tracking} trackingService
   * @constructor
   */
  function DrugMemberController($state, drugEditor, members, trackingService){
    this.members = members;

    this.choose = function(member){
      drugEditor.setMember(member.id);

      //Mixpanel prescriptions
      trackingService.incrementPeopleProp(trackingService.propEnum.drugs);

      $state.go($state.current.data.nextState);
    };

    if (members.length === 1){
      drugEditor.setMember(members[0].id);

      //Mixpanel prescriptions
      trackingService.incrementPeopleProp(trackingService.propEnum.drugs);

      $state.replace($state.current.data.nextState);
    }
  }
  DrugMemberController.$inject = ['$state', 'drug.editor', 'members', 'services.tracking'];

  angular.module('drug')
    .controller('drug.member.controller', DrugMemberController);
}());
(function(){

  /**
   * @constructor drug.picker.controller
   * @param {ui.router.state.$state} $state
   * @param {ng.$scope.$scope} $scope
   * @param {drug.editor} drugEditor
   * @param {drug.formMap} drugFormMap
   * @param {*} alertService
   */
  function DrugPickerController($state, $scope, drugEditor, drugFormMap, alertService){
    if (drugEditor.getModel() === null){
      var state = 'home';
      var data = $state.current.data;
      if (data && data.invalidState){
        state = data.invalidState;
      }

      if (!$state.is(state)){
        $state.replace(state);
      }

    }

    /**
     *
     * @param {drug.model} drugModel
     */
    this.setBreadCrumb = function(drugModel){
      if (!drugModel){
        alertService.clear();
        return;
      }

      /**
       * @type {string[]}
       */
      var sb = [drugModel.product];

      if (drugModel.dose && drugModel.dose.strength){
        sb.push(drugModel.dose.strength);
      }

      if (drugModel.fillQty){
        var form = drugFormMap[drugModel.doseForm.toLowerCase()] || drugFormMap.default;
        var formText = form.plural;

        if (drugModel.fillQty === 1){
          formText = form.singular;
        }

        sb.push(drugModel.fillQty + ' ' + formText);
      }

      if (drugModel.durationDays){
        sb.push('lasts ' + drugModel.durationDays + ' days');
      }

      if (!_.isUndefined(drugModel.fillCount)){
        sb.push(drugModel.fillCount + ' fill' + (drugModel.fillCount !== 1 ? 's' : ''));
      }

      alertService.setMessage({ text: sb.join(' - ') });
    };

    $scope.$watchCollection(drugEditor.getModel, this.setBreadCrumb);
  }
  DrugPickerController.$inject = ['$state', '$scope', 'drug.editor', 'drug.formMap', 'services.alert'];

  angular.module('drug')
    .controller('drug.picker.controller', DrugPickerController);
}());
(function(){

  /**
   * @constructor drug.refill.controller
   * @param {ui.router.state.$state} $state
   * @param {drug.editor} drugEditor
   */
  function DrugRefillController($state, drugEditor, trackingServices){
    var model = drugEditor.getModel();
    if (model === null){
      return;
    }

    this.showFreeForm = false;
    this.fillCount = '';

    /**
     * @param {number} count
     */
    this.choose = function(count){
      drugEditor.setFillCount(count);
      $state.go($state.current.data.nextState);
    };

    this.chooseFreeForm = function(){
      this.choose(parseInt(this.fillCount));
    };
  }
  DrugRefillController.$inject = ['$state', 'drug.editor', 'services.tracking'];

  angular.module('drug')
    .controller('drug.refill.controller', DrugRefillController);
}());
(function () {

  /**
   * Drug Search controller
   * @name drug.search.controller
   * @param {$rootScope.Scope} $scope
   * @param {drug.service} drugService
   */
  function DrugSearchController($scope, drugService) {
    var self = this;
    self.term = '';
    self.noResults = false;

    // keep this out of ng-options debounce so watchers of term changes can fire immediately
    self.search = _.throttle(function () {
      drugService
        .search(self.term)
        .then(function (matches) {
          self.matches = matches;
          self.noResults = self.term.length > 2 && (!matches || !matches.length);
        });
    }, 200);

    self.select = function (drug) {
      // Modify so that a drug object is created with the drugModel in drug_json
      $scope.$emit('drug-select', {drug_json: drug});
      self.clear();
    };

    self.clear = function () {
      self.term = '';
      self.noResults = false;
      self.matches = [];
      $scope.$emit('clear-search');
    };

    $scope.$watch(function () {
      return self.term;
    }, self.search);
  }

  DrugSearchController.$inject = ['$scope', 'drug.service'];

  angular.module('drug')
    .controller('drug.search.controller', DrugSearchController);
}());
(function () {

  /**
   * @name drug.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {search.request} searchRequest
   * @param {session} session
   * @param {utils} utils
   * @constructor
   */
  function DrugService($q, $http, config, searchRequest, session, utils) {

    var url = '/drug';
    var drugSessionKey = 'member_drug';
    var baseUrl = config.paths.services;

    if (!getFromSession()) {
      session.set(drugSessionKey, []);
    }

    /**
     * Search based on drug name
     * @param {string} drugName
     * @returns {HttpPromise<drug.searchResult[]>}
     */
    this.search = function (drugName) {
      // return promise with empty array when no drug name so we don't try to hit the server
      if (!drugName || drugName.length < 3) {
        return $q.when([]);
      }

      return searchRequest.get(url, {params: {nameLike: drugName}})
        .then(utils.dataOrArray);
    };

    /**
     * Get the dosages for a specific drugId
     * @param {number} drugId
     * @returns {HttpPromise<drug.dosageResult[]>}
     */
    this.getDosages = function (drugId) {
      return searchRequest.get(url + '/' + drugId + '/dosages')
        .then(utils.dataOrArray);
    };

    /**
     * Get the price from Envision
     * @param {drug.model} drug
     * @param {string} zipcode
     * @returns {HttpPromise<drug.quoteResult>}
     */
    this.getQuote = function (drug, zipcode) {
      var params = {
        zip5: zipcode,
        timePeriod: drug.freq.timePeriodId,
        intake: drug.freq.intake,
        fills: drug.freq.fills
      };

      return searchRequest.get(url + '/' + drug.id + '/dosages/' + drug.dose.ndc + '/quote', {params: params});
    };

    /**
     * Get the pharmacies from Envision
     * @param {drug.model} drugModel
     * @param {Address} address
     * @param {application.model} applicationModel
     * @returns {HttpPromise<drug.pharmacyResult>}
     */
    this.getPharmacies = function (drugModel, address, applicationModel) {

      if (!drugModel || !drugModel.dose) {
        return $q.when([]);
      }

      var params = {
        qty: drugModel.fillQty || 30,
        days: drugModel.durationDays || 30
      };

      if (address.lat && address.lng) {
        params.coord = [address.lat, address.lng].join(';');
      }
      else {
        params.zip5 = address.zipcode;
      }

      if (applicationModel.getPlan()) {
        params.planId = applicationModel.getPlan().id;
        if (applicationModel.get().subsidy && applicationModel.get().subsidy.csr > 0) {
          params.csr = applicationModel.get().subsidy.csr;
        }
      }

      //return $q.when(getMockPharmacyResults())

      return searchRequest.get([url, drugModel.id, 'dosages', drugModel.dose.ndc, 'prices'].join('/'), {params: params})
        .then(function (response) {
          return _.map(response.data, function (result) {
            var coords = result.pharmacy.coord;

            return {
              name: result.pharmacy.name,
              address: {
                street: result.pharmacy.address1,
                unit: result.pharmacy.address2,
                zipcode: result.pharmacy.zip5,
                city: result.pharmacy.city,
                state: result.pharmacy.state,
                lat: coords && coords.latitude || null,
                lng: coords && coords.longitude || null
              },
              phone: result.pharmacy.phone,
              distanceMi: result.distanceMi,
              discountPrice: result.discountPrice,
              planPrice: result.planPrice,
              lowestPrice: result.lowestPrice
            };
          });
        });
    };

    /**
     * @name drug.service.saveDrug
     * @methodOf drug.service
     * @param {user.model} userModel
     * @param {MemberDrug} memberDrug
     * @param {health.app} [applicationModel] Will created and associate if application model is present
     * @returns {HttpPromise<MemberDrug|Boolean>}
     */
    this.saveDrug = function (userModel, memberDrug, applicationModel) {
      if (!memberDrug.member_id){
        memberDrug.member_id = userModel.getPrimaryId();
      }

      if (!userModel.isLoggedIn) {
        var sessionDrugs = getFromSession();
        var drugJson = memberDrug.drug_json;

        if (!drugJson || !drugJson.dose || !drugJson.fillQty || !drugJson.durationDays) {
          return $q.when(false);
        }

        // add id if not present
        if (!memberDrug.id){
          memberDrug.id = utils.uuid();
          sessionDrugs.push(memberDrug);
        }
        else {
          var index = _.findIndex(sessionDrugs, { id: memberDrug.id });
          if (index > -1) {
            sessionDrugs[index] = memberDrug;
          }
        }

        session.set(drugSessionKey, sessionDrugs);
        return $q.when(memberDrug);
      }

      var memberId = memberDrug.member_id;

      // Edit drug if id already set
      if (_.isNumber(memberDrug.id)) {
        // Edit drug
        var editUrl = baseUrl + '/member/' + memberId + '/drug/' + memberDrug.id;
        return $http.put(editUrl, {
            drug_json: memberDrug.drug_json
          })
          .then(utils.dataOrObject)
          .catch(function (error) {
            return false;
          });
      }

      // Add drug
      var postUrl =  baseUrl + (applicationModel ? '/application/' + applicationModel.getId() : '') + '/member/' + memberId + '/drug';
      return $http.post(postUrl, {
          drug_json: memberDrug.drug_json
        })
        .then(utils.dataOrObject)
        .catch(function (error) {
          return false;
        });
    };

    /**
     *
     * @param {user.model} userModel
     * @param {MemberDrug} memberDrug
     * @param {health.app} applicationModel
     * @returns {HttpPromise<boolean>}
     */
    this.removeDrug = function (userModel, memberDrug, applicationModel) {
      if (!userModel.isLoggedIn) {
        var oldDrugs = getFromSession();
        var newDrugs = _.reject(oldDrugs, { id: memberDrug.id });
        session.set(drugSessionKey, newDrugs);

        return $q.when(newDrugs.length !== oldDrugs.length);
      }

      var deleteUrl = baseUrl + (applicationModel ? '/application/' + applicationModel.getId() : '') + '/member/' + memberDrug.member_id + '/drug/' + memberDrug.id;
      return $http.delete(deleteUrl)
        .then(function (response) {
          return response && response.data === 1;
        });
    };

    /**
     * @name drug.service.getAllForUser
     * @methodOf drug.service
     * @param {user.model} userModel
     * @returns {HttpPromise<MemberDrug[]>}
     */
    this.getAllForUser = function (userModel) {
      if (!userModel.isLoggedIn) {
        return $q.when(getFromSession());
      }

      return $http.get(baseUrl + '/member/drug')
        .then(utils.dataOrArray);
    };

    /**
     * @name drug.service.getFromSession
     * @methodOf drugService
     * @returns {MemberDrug[]}
     */
    this.getFromSession = getFromSession;

    function getFromSession(){
      return session.get(drugSessionKey);
    }

    /**
     * @name drug.service.clearSession
     * @methodOf drugService
     */
    this.clearSession = clearSession;

    function clearSession(){
      session.remove(drugSessionKey);
    }
  }

  DrugService.$inject = ['$q', '$http', 'config', 'search.request', 'session', 'utils'];

  angular.module('drug')
    .service('drug.service', DrugService);
}());
(function(){

  /**
   * @constructor drug.user.model
   * @param {ng.$q} $q
   * @param {search.geo} geoService
   * @param {drug.service} drugService
   * @param {utils} utils
   */
  function UserDrugModel($q, geoService, drugService, utils){

    var self = this;

    /**
     * Need to set the user prior to health application
     * @name drug.user.model.setUser
     * @memberOf drug.user.model
     * @param {user.model} userModel
     */
    this.setUser = function(userModel){

      // make sure there is always a userModel.drugs array to operate on
      if (!_.isArray(userModel.drugs)){
        userModel.drugs = [];
      }

      self.userModel = userModel;
    };

    /**
     * @name drug.user.model.getHealthApp
     * @memberOf drug.user.model
     * @returns {application.model}
     */
    this.getHealthApp = function(){
      return self.healthApp;
    };

    /**
     * Map old drug format to new and save to user.drugs[] and application.applicants[].drugs[]
     * @name drug.user.model.setHealthApp
     * @memberOf drug.user.model
     * @param {health.app} healthApplicationModel
     */
    this.setHealthApp = function(healthApplicationModel){
      //var hasBeenMapped = _.every(healthApplicationModel.getInfo('drugs'), function(drug){
      //  return _.isString(drug.uuid);
      //});
      //
      //if (!hasBeenMapped){
      //  // pull over any drugs from the existing health application
      //  var drugs = _.flatten(_.map(healthApplicationModel.getApplicants(), function(applicant){
      //    // convert the drugs for each applicant
      //    applicant.drugs = _.map(applicant.drugs, function(drug){
      //      return self.applicantDrugToUserDrug(drug, applicant.uuid);
      //    });
      //
      //    return applicant.drugs;
      //  }));
      //
      //
      //  // don't really need to wait for these
      //  self.updateDrugs(drugs);
      //  healthApplicationModel.save();
      //
      //}

      self.healthApp = healthApplicationModel;
    };

    /**
     * This is just in memory for now,
     * Once user refreshes it will be pulled from userModel.geo or get via IP
     * @type {Address}
     */
    this.geo = null;

    /**
     * @name drug.user.model.getGeo
     * @memberOf drug.user.model
     * @returns {Promise<Address>}
     */
    this.getGeo = function(){
      if (self.geo){
        return $q.when(self.geo);
      }

      if (self.userModel.getGeo()){
        self.geo = angular.copy(self.userModel.getGeo());
        return $q.when(self.geo);
      }

      return geoService.getByIp()
        .then(function(addresses){
          self.geo = addresses[0];
          return self.geo;
        });
    };

    this.setGeo = function(address){
      self.geo = address;

      // TODO: add a userModel.drugs.location?
      // if (_.isEmpty(self.userModel.getGeo())){
      if (!angular.equals(self.userModel.getGeo(), address)){
        _.extend(self.userModel.geo, address);
        self.userModel.save(true);
      }
    };

    /**
     * Stubbed out for now
     * @returns {drug.model[]}
     */
    this.getDrugs = function(){
      return self.userModel.drugs;
    };

    ///**
    // * @param {drug.model|drug.model[]} drugModels drug.model or array of drug.models
    // * @param {boolean} [persist=true] whether to save to the server
    // * @returns {Promise<drug.model[]>}
    // */
    //this.addDrugs = function(drugModels, persist){
    //  var added = false;
    //  if (_.isUndefined(persist)){
    //    persist = true;
    //  }
    //
    //  if (!_.isArray(drugModels)){
    //    drugModels = [drugModels];
    //  }
    //
    //  _.each(drugModels, function(drugModel){
    //    var exists = _.some(self.userModel.drugs, function(drug){
    //      return self.isSameDrug(drugModel, drug);
    //    });
    //
    //    if (!exists){
    //      added = true;
    //      self.userModel.drugs.push(drugModel);
    //    }
    //  });
    //
    //  if (added && persist){
    //    return drugService.addUserDrugs(drugModels, self.userModel);
    //  }
    //
    //  return $q.when(self.userModel.drugs);
    //};

    /**
     * @param {drug.model[]} drugModels
     * @returns {*}
     */
    this.updateDrugs = function(drugModels){
      var updated = false;
      if (!_.isArray(drugModels)){
        drugModels = [drugModels];
      }

      _.each(drugModels, function(drugModel){
        var userDrug = _.findWhere(self.userModel.drugs, { uuid: drugModel.uuid });

        if (!drugModel.memberId){
          drugModel.memberId = self.healthApp.getPrimaryId() || self.userModel.getPrimaryId();
        }

        if (!userDrug){
          updated = true;
          self.userModel.drugs.push(drugModel);
        }
        else if (!angular.equals(userDrug, drugModel)){
          updated = true;
          _.extend(userDrug, drugModel);
        }

      });

      if (updated){
        return drugService.updateUserDrugs(drugModels, self.userModel);
      }

      return $q.when(self.userModel.drugs);
    };
    //
    ///**
    // * This pulls the user.drugs and map them to the corresponding applicants on the current healthApp
    // * @param {health.app|application.model} healthApp
    // * @returns {Promise<application.model>}
    // */
    //this.updateApplicantDrugs = function(healthApp){
    //  var applicants = healthApp.getApplicants();
    //  var applicantsCopy = angular.copy(applicants);
    //
    //  _.each(applicants, function(applicant){
    //    applicant.drugs = _.where(self.getDrugs(), { memberId: applicant.uuid });
    //  });
    //
    //  // don't save if drugs weren't updated
    //  if (angular.equals(applicants, applicantsCopy) || !_.isFunction(healthApp.save)){
    //    return $q.when(healthApp);
    //  }
    //
    //  return healthApp.save();
    //};
    //
    ///**
    // * If the ndc and memberId for the drugs is the same,
    // * we can consider them to be the same drug.
    // * EDIT: relying on just the UUID now
    // * @param {drug.model} drug1
    // * @param {drug.model} drug2
    // * @returns {boolean}
    // */
    //this.isSameDrug = function(drug1, drug2){
    //  return drug1.uuid === drug2.uuid;
    //  //return drug1.dose.ndc === drug2.dose.ndc &&
    //  //    drug1.memberId === drug2.memberId;// &&
    //      //(drug1.pharmacy && drug2.pharmacy && angular.equals(drug1.pharmacy, drug2.pharmacy));
    //};

    //var whiteList = [
    //  'id',
    //  'ndc',
    //  'product',
    //  'qtyDivisible',
    //  'brand',
    //  'doseForm',
    //  'generic',
    //  'genericId',
    //  'relatedBrand',
    //  'memberId',
    //  'fillQty',
    //  'fillCount',
    //  'freq',
    //  'dose',
    //  'pharmacy'
    //];
    //var timePeriodToDaysMap = { '1': 1, '2': 7, '3': 30, '4': 365 };
    //this.applicantDrugToUserDrug = function(applicantDrug, applicantId){
    //
    //  var drug = _.pick(applicantDrug, whiteList);
    //  if (!drug.memberId){
    //    drug.memberId = applicantId;
    //  }
    //
    //  if (_.isObject(drug.freq) && _.isUndefined(drug.fillQty) && _.isUndefined(drug.durationDays)){
    //
    //    if (drug.qtyDivisible){
    //      drug.fillQty = drug.dose.qty;
    //      // how many times is it take per day * how many there are
    //      drug.durationDays = (drug.freq.intake / timePeriodToDaysMap[drug.freq.timePeriodId]) * drug.fillQty;
    //    }
    //    else {
    //      drug.fillQty = 1;
    //      drug.durationDays = timePeriodToDaysMap[drug.freq.timePeriodId];
    //    }
    //  }
    //
    //  //if (_.isUndefined(drug.qty)){
    //  //  drug.qty = drug.dose.qty;
    //  //}
    //
    //  if (_.isUndefined(drug.uuid)){
    //    drug.uuid = utils.uuid();
    //  }
    //
    //
    //  return drug;
    //};
  }
  UserDrugModel.$inject = ['$q', 'search.geo', 'drug.service', 'utils'];

  angular.module('drug')
    .service('drug.user.model', UserDrugModel);
}());
/**
 * @namespace finance
 */
angular.module('finance', ['common', 'config', 'translate', 'session']);
angular.module('finance')
  .directive('shMemberFinanceCard', [
    'config.paths',
    function (paths) {
      return {
        restrict: 'E',
        scope: {
          removeHandler: '=',
          finance: '=',
          defaultName: '=',
          basicEntry: '=?'
        },
        templateUrl: paths.partials + '/components/finance/finance-card.html',
        link: function($scope){
          $scope.finance.dirty = false;
          var origData = angular.copy($scope.finance);

          $scope.freqOptions = [
            { maxPerYear: 52, text: 'weekly', freqId: 1, unit:'week' },
            { maxPerYear: 12, text: 'monthly', freqId: 2, unit:'month' },
            { maxPerYear: 1, text: 'yearly', freqId: 3, unit:null },
            { maxPerYear: 1, text: 'one time', freqId: 4, unit:null },
          ];

          // set the scope property based on the freq, default to monthly
          $scope.selectedFreq = _.find($scope.freqOptions, function(option){
            return option.freqId === $scope.finance.freq_id;
          });

          // $scope.

          $scope.handleSelection = function(){
            $scope.finance.freq_id = $scope.selectedFreq.freqId;
            $scope.finance.multiplier = null;
            // for yearly and one time options
            if(!$scope.selectedFreq.unit){
              $scope.finance.multiplier = $scope.selectedFreq.maxPerYear;
            }
          }

          $scope.$watchCollection('finance', _.debounce(function(newData, oldData){
            // server update, referential equality fails
            // this is FRAGILE  TODO: rethink dirty checking
            if(newData !== oldData){
              $scope.finance.dirty = false;
            }
            // client side update check key equality
            $scope.finance.dirty = !angular.equals(origData, $scope.finance);
          },1000/60))
        }
      };
    }
  ]);
(function () {

  /**
   *
   * @param $scope
   * @param $state
   * @param $timeout
   * @param financeService
   * @param utils
   * @param {services.auth} authService
   * @constructor
   */
  function FinanceCardListCtrl($scope, $state, $timeout, financeService, utils, authService) {
    var self = this;
    self.render = true;

    function flagToDelete(entry) {
      return _.extend(entry, {delete: true});
    }

    // client side only delete
    this.deleteFinance = function (financeObj) {
      self.finances = self.finances.reduce(
        function (acc, entry) {
          // financeObj.id && (financeObj.id === entry.id)
          if (financeObj.localId && (financeObj.localId === entry.localId)) {
            // if logged in and entry matches on localId, just omit entry
            if (authService.isAuthenticated()) {
              return acc;
            }
            // need to mark when logged out for pesistence to session
            acc.push(flagToDelete(entry));
          } else if (financeObj.id && (financeObj.id === entry.id)) {
            acc.push(flagToDelete(entry));
          } else {
            acc.push(entry);
          }
          return acc;
        }, []);
    };

    this.getActiveFinances = function () {
      var financesOfType = _.filter(self.finances, {type: self.financeType});
      return _.reject(financesOfType, {delete: true});
    };

    this.createIncome = function (member_id) {
      self.finances.push(financeService.createFinance({
        member_id: member_id,
        type: 'income'
      }));
    };

    this.createDeduction = function (member_id) {
      self.finances.push(financeService.createFinance({
        member_id: member_id,
        type: 'deduction',
        inverseProp: -1,
        source_key: null
      }));
    };

    if (this.finances.length === 0 && this.requireOne) {
      if(this.addIncome){
        this.createIncome(this.memberId)
      } else if (this.addDeduction) {
        this.createDeduction(this.memberId)
      }
    }

  }

  FinanceCardListCtrl.$inject = ['$scope', '$state', '$timeout', 'finance.service', 'utils', 'services.auth'];

  angular.module('finance')
    .controller('finance.cardList.controller', FinanceCardListCtrl);
}());
angular.module('finance')
  .directive('shMemberFinanceCardList', [
    'config.paths',
    function (paths) {
      return {
        restrict: 'E',
        bindToController: {
          finances: '=',
          appId: '=',
          memberId: '=',
          memberType: '=',
          addIncome: '=?',
          addDeduction: '=?',
          onFinancesChange: '=',
          basicEntry: '=?',
          ctaKey:'@?',
          financeType: '=?',
          unitOfEntry:'@',
          requireOne:'=?'
        },
        transclude: true,
        templateUrl: paths.partials + '/components/finance/finance-card-list.html',
        controller: 'finance.cardList.controller as financeCardListCtrl'
      };
    }
  ]);
(function () {

  var SESSION_KEY = "member_finance";

  function removeFromArr(arr, index) {
    var head = arr.slice(0, index);
    var tail = arr.slice(index + 1);
    return head.concat(tail);
  }

  /**
   * @name finance.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {services.date} dateService
   * @param {session} session
   * @param {services.auth} authService
   * @constructor
   */
  function Svc($q, $http, config, dateService, session, authService) {
    var self = this;

    var baseUrl = config.paths.services;


    function _isLoggedIn() {
      return authService.isAuthenticated();
    }

    function _getFromSession() {
      return _set(session.get(SESSION_KEY) || []);
    }

    function _setSession(vals) {
      // console.log("SETTING SESSION", SESSION_KEY);
      var financesMinusDeletes = _.reduce(vals, function (acc, entry) {
        // omit deleted entries from being saved to session
        if(entry.delete){
          return acc;
        }
        // convert the client_created_on date obj to a string
        acc.push(
          _.extend(entry, {
            client_created_on: entry.client_created_on.toISOString()
          })
        )

        return acc;
      }, [])
      session.set(SESSION_KEY, financesMinusDeletes);
      return _set(financesMinusDeletes);
    }

    function _fromMaybeIsoDate(dateOrString) {
      if (dateOrString instanceof Date) {
        return dateOrString
      }
      return new Date(dateOrString);
    }

    function _formatData(data) {
      return _.map(data, function (d) {
        return _.extend(d, {
          client_created_on: _fromMaybeIsoDate(d.client_created_on)
        })
      })
    }

    function _set(updatedData) {
      var formattedData = _formatData(updatedData);
      memberFinance = formattedData;
      return self.get();
    }

    function _mergeFinances(financesObj) {
      var associatedFinances = financesObj.associatedFinances;
      var idsToSearch = _.map(associatedFinances, function (finance) {
        return finance.id;
      });
      var memberFinances = financesObj.memberFinances;
      var financesToAppend = _.reduce(memberFinances, function (acc, finance) {
        var associatedIndex = idsToSearch.indexOf(finance.id);
        if (associatedIndex >= 0) {
          idsToSearch.splice(associatedIndex, 1);
        } else {
          acc.push(finance);
        }
        return acc;
      }, []);
      return associatedFinances.concat(financesToAppend);
    }

    // /**
    //  * Stores what income estimation flow type user selected: 'guided' || 'exact'
    //  * @name finance.service.setEstimationType
    //  * @methodOf finance.service
    //  * @param {String} type
    //  */
    // this.setEstimationType = function (type) {
    //   console.log('set estimation type', type);
    //   self.estimateType = type;
    // };
    //
    // /**
    //  * Gets income estimation flow type user selected: 'guided' || 'exact'
    //  * @name finance.service.getEstimationType
    //  * @methodOf finance.service
    //  * @returns {String} type
    //  */
    // this.getEstimationType = function () {
    //   return self.estimateType;
    // };

    /**
     * @name finance.service.createFinance
     * @methodOf finance.service
     * @param overrides
     * @returns {Object}
     */
    this.createFinance = function (overrides) {
      if (!('member_id' in overrides)) {
        console.log('--DID YOU FORGET TO ADD member_id--');
        return {};
      }
      var defaultEntry = {
        name: null,
        freq_id: 2,
        multiplier: null,
        inverseProp: 1,
        amount: null,
        source_key: 'income.wages',
        localId: new Date().valueOf(),
        client_created_on: new Date()
      };
      return _.extend(defaultEntry, overrides);
    };

    /**
     * @name finance.service.createFromSession
     * @methodOf finance.service
     * @param appId
     * @returns {Promise.<[Finances]>}
     */
    this.createFromSessionForApp = function (appId) {
      _getFromSession();
      return self.saveForApp(appId);
    };

    function _buildRoute() {
      var args = Array.prototype.slice.call(arguments);
      var params = [baseUrl].concat(args);
      return params.join('/');
    }

    /**
     * Gets all the income sources (finances) of an application
     * @name finance.service.getForAppAsync
     * @methodOf finance.service
     * @param appId
     * @returns {Promise.<[Finances]>}
     */
    this.getForAppAsync = function (appId, filter) {
      //if (!appId) {
      //  throw new Error('--DID YOU FORGET TO ADD appId--')
      //}

      // applicationModel is a number like 0 if logged out
      if (_isLoggedIn() && appId) {
        var route = _buildRoute(appId, 'finance');
        return _getForApp(appId)
          .then(function (data) {
            // if(filter)
            return _set(data)
          })
      }

      return $q.when(_getFromSession());
    };

    /**
     * @name finance.service.getAllAsync
     * @methodOf finance.service
     * @param appId
     * @returns {*}
     */
    this.getAllAsync = function (appId) {
      if (_isLoggedIn() && appId) {
        return $q.all({
            associatedFinances: _getForApp(appId),
            memberFinances: _getForUser()
          })
          .then(_mergeFinances)
          .then(function (finances) {
            return _set(finances);
          })
      }
      return $q.when(self.get());
    };

    /**
     * @name finance.service.get
     * @methodOf finance.service
     * @returns {*|XMLList|XML}
     */
    this.get = function () {
      return angular.copy(memberFinance);
      // return angular.copy(_.filter(memberFinance, function (finance) {
      //   if (applicationModel) {
      //     var appMembers = applicationModel.getMembers();
      //     var memberIds = _.pluck(appMembers, 'id');
      //     return !finance.deleted && _.contains(memberIds, finance.member_id);
      //   }
      //   return !finance.delete;
      // }));
    };

    /**
     * @name finance.service.getByMemberAsync
     * @methodOf finance.service
     * @param appId
     * @param memberId
     * @param options
     * @returns {Promise.<[Finances]>}
     */
    this.getByMemberAsync = function (appId, memberId, options) {
      if (_isLoggedIn() && appId && memberId) {
        var route = _buildRoute('application', appId, 'finance', memberId);
        return $http.get(route)
          .then(function (res) {
            self.update(res.data.member_finances);
            return self.getByMember(memberId);
          })
      }
      // hmm, possibly problematic to do here
      _getFromSession();
      return $q.when(self.getByMember(memberId));
    };

    /**
     * @name finance.service.getByMember
     * @methodOf finance.service
     * @param memberId
     */
    this.getByMember = function (memberId) {
      return self.filterBy(self.get(), {member_id: memberId})
    };

    /**
     * @name finance.service.filterBy
     * @methodOf finance.service
     * @param finances
     * @param filter
     * @returns {Array}
     */
    this.filterBy = function (finances, filter) {
      return _.filter(finances, filter);
    };

    /**
     * @name finance.service.update
     * @methodOf finance.service
     * @param updatedFinances
     * @returns {*}
     */
    this.update = function (updatedFinances) {
      var finances = memberFinance.slice();
      var updates = updatedFinances.slice();
      // hmm this feels crappy TODO: make this better
      var newFinances = _.map(finances,
        function (existingFinance) {
          var match = _.find(updates, function (update, i) {
            var isUpdate = (existingFinance.localId && existingFinance.localId === update.localId) ||
              (existingFinance.id && existingFinance.id === update.id);
            if (isUpdate) {
              updates = removeFromArr(updates, i);
            }
            return isUpdate;
          });
          return match ? match : existingFinance;
        }
      ).concat(updates);
      return _set(newFinances);
    };


    /**
     * @name finance.service.saveForApp
     * @methodOf finance.service
     * @param appId
     * @param options
     * @returns {Promise.<Finance>}
     */
    this.saveForApp = function (appId, options) {
      if (!_isLoggedIn()) {
        return $q.when(_setSession(memberFinance));
      }

      if (!appId) {
        throw new Error('no appId supplied');
      }
      var upsertPayload = [];
      var deleteIds = [];

      // separate upserts and deletes
      _.each(memberFinance, function (entry) {
        // console.log(entry.id, 'dirty=', entry.dirty);
        if (entry.delete === true) {
          deleteIds.push(entry.id);
        } else if (entry.dirty) {
          upsertPayload.push(entry);
        }
      });

      // perform server deletes
      return _deleteFromApp(appId, deleteIds, options)
        .then(function () {
          // perform server upserts
          return _saveToApp(appId, upsertPayload);
        })
        .then(function (data) {
          return data ? _set(data) : self.getForAppAsync(appId);
        })
    };

    /**
     * @name finance.service.saveForApp
     * @methodOf finance.service
     * @param appId
     * @param payload
     * @returns {*}
     */
    this.saveAppAssociations = function (appId) {
      var disassociateIds = [];
      var associateIds = [];

      // separate associates and disassociates
      _.each(memberFinance, function (entry) {
        if (entry.delete) {
          disassociateIds.push(entry.id);
        } else if (entry.dirty) {
          associateIds.push(entry.id);
        }
      });

      console.log('disassociate', disassociateIds);

      return _deleteFromApp(appId, disassociateIds)
        .then(function () {
          console.log('associate', associateIds);
          return _putToApp(appId, associateIds);
        })
        .then(function (data) {
          return self.getAllAsync(appId);
        })
    };


    function _getForApp(appId) {
      var route = _buildRoute('application', appId, 'finance');
      return $http.get(route)
        .then(function (res) {
          return res.data.member_finances;
        });
    }

    function _getForUser() {
      var route = _buildRoute('member', 'finance');
      return $http.get(route)
        .then(function (res) {
          return res.data.member_finances;
        });
    }

    function _putToApp(appId, payload) {
      if (payload.length === 0) {
        return $q.when(0);
      }
      var putToRoute = _buildRoute('application', appId, 'finance');
      return $http.put(putToRoute, {member_finance_ids: payload})
        .then(function (res) {
          return res.data.member_finances;
        });
    }

    /**
     * Gets the income total
     * @name finance.service.getIncomeTotal
     * @methodOf finance.service
     * @param appId
     * @returns {Promise.<incomeTotal>}
     */
    this.getIncomeTotal = function (applicationModel) {
      return self.getForAppAsync(applicationModel.getId())
        .then(function (finances) {
          var appMembers = applicationModel.getMembers();
          var memberIds = _.pluck(appMembers, 'id');

          var filteredFinances = _.filter(finances, function (finance) {
            return _.contains(memberIds, finance.member_id);
          });

          return _.reduce(filteredFinances, function (total, finance) {
            total += finance.amount * finance.multiplier;
            return total
          },0);
        });

    };


    // /**
    //  * @name finance.service.getMembersByType
    //  * @methodOf finance.service
    //  * @param {String} type 'income' | 'deduction'
    //  * @returns {Array<Members>}
    //  */
    // this.getMembersByType = function (type) {
    //   switch (type) {
    //     case 'income':
    //       return self.incomeMembers;
    //     case 'deduction':
    //       return self.deductionsMembers;
    //     default:
    //       return null;
    //   }
    // };
    //
    // /**
    //  * @name finance.service.saveMembersByType
    //  * @methodOf finance.service
    //  * @param {Array<Members>}incomeMembers
    //  * @param {String} type
    //  */
    // this.saveMembersByType = function (filteredMembers, type) {
    //   switch (type) {
    //     case 'income':
    //       return self.incomeMembers = filteredMembers;
    //     case 'deduction':
    //       return self.deductionsMembers = filteredMembers;
    //     default:
    //       return null;
    //   }
    // };

    /**
     * @name finance.service.clearSession
     * @methodOf finance.service
     */
    this.clearSession = function () {
      _setSession([]);
    };

    function _saveToApp(appId, payload) {
      if (payload.length === 0) {
        return $q.when(0);
      }
      var postToRoute = _buildRoute('application', appId, 'finance');
      return $http.post(postToRoute, {memberFinances: payload})
        .then(function (res) {
          return res.data.member_finances;
        });
    }

    // removes association of member finance entry with application
    function _deleteFromApp(appId, ids, options) {
      if (ids.length === 0) {
        return $q.when(0);
      }
      var financeParam = 'finance?ids=' + ids.join(',');
      var deepParam = options && options.deep ? '&deep=true' : '';
      var queryParams = financeParam + deepParam;
      var deleteFromRoute = _buildRoute('application', appId, queryParams);
      // db call
      return $http.delete(deleteFromRoute)
        .then(function (res) {
          console.log('DELETE RESPONSE', res);
          return res.data;
        })
    }

    var memberFinance = [];

  }

  Svc.$inject = ['$q', '$http', 'config', 'services.date', 'session', 'services.auth'];

  angular.module('finance')
    .service('finance.service', Svc);
})();

(function () {

  /**
   *
   * @param $state
   * @constructor
   */
  function FinanceSummaryCtrl($state) {
    var self = this;
    // self.render = true;
    // console.log(this.aggregatedFinances);

    this.orderAggs = function (a, b) {
      if (b.type === 'object') {
        var prev = a.value;
        var next = b.value;

        switch (next.member.type) {
          case 'primary':
            return -1;
          case 'spouse':
            if (prev.member.type === 'primary') {
              return 1;
            }
            return -1;
          case 'dependent':
            if (prev.member.type === 'dependent') {
              // NEED TO VERIFY THIS
              return next.min_client_created_on - prev.min_client_created_on;
            }
          default:
            return 1
        }
      }
      return 0;

    };

    this.editFinances = function (aggFinance) {
      $state.replace('.edit', {
        member_id: aggFinance.member_id,
        finances: aggFinance.finances
      })
    };

    this.getFinances = function (finances) {
      return self.financeType ? _.filter(finances, {type: self.financeType}) : finances;
    };

    this.getLabel = function (currentMember) {
      if (currentMember) {
        switch (currentMember.type) {
          case 'primary':
            return 'my'; // or 'your' depending on if it's the header?
          case 'spouse':
            // first_name || your spouse's
            return (currentMember.first_name || "my spouse") + "'s";
          case 'dependent':
            // first_name || your 20 year old's || household member's
            var ageMemberLabel = currentMember.age ? "my " + currentMember.age + " year old" : null;
            return (currentMember.first_name || ageMemberLabel || "household member") + "'s";
          default:
            return "household member's";
        }
      }
    };

    // this.handleToggle = function(membersAggFinance){
    //   membersAggFinance.isAssociated = !membersAggFinance.isAssociated;
    //   // mark for deletion
    //   membersAggFinance.finances = membersAggFinance.finances.map(function(finance){
    //     finance.delete = !membersAggFinance.isAssociated;
    //     finance.dirty = !finance.dirty;
    //     return finance;
    //   });
    //
    //   var deDupedMemberIds = _.filter(self.disassociatedMembers, function(member_id){
    //     return member_id !== membersAggFinance.member_id;
    //   })
    //   // keep track of deselected ids, data lies in state controller so it is
    //   // not destroyed on change to child route
    //   if(!membersAggFinance.isAssociated){
    //     deDupedMemberIds.push(membersAggFinance.member_id);
    //   }
    //   self.disassociatedMembers = deDupedMemberIds;
    //   console.log('handle toggle', membersAggFinance.finances, self.disassociatedMembers);
    // }

  }

  FinanceSummaryCtrl.$inject = ['$state'];

  angular.module('finance')
    .controller('finance.summary.controller', FinanceSummaryCtrl)
    .filter('sumAmount', function () {
      // WHY WON'T MEMOIZE WORK HERE?????
      return function (data) {
        //console.log('sum amount', data)
        var total = _.reduce(data, function (acc, d) {
          acc += d.amount * d.multiplier;
          return acc;
        }, 0);
        return total
      }
    });
}());
angular.module('finance')
  .directive('shMemberFinanceSummary', [
    'config.paths',
    function (paths) {
      return {
        restrict: 'E',
        bindToController: {
          financeGroups: '=',
          unitOfRecords: '@',
          financeType: '=?'
        },
        transclude: true,
        templateUrl: paths.partials + '/components/finance/finance-summary.html',
        controller: 'finance.summary.controller as financeSummaryCtrl'
      };
    }
  ]);
(function(){

  var trackingPrefix = 'Earnings: Transaction: ';

  /**
   * @name financeTracker.config
   */
  var config = {
    tracking: {
      names: {
        selectSource: trackingPrefix + 'Select Source',
        enterAmount: trackingPrefix + 'Enter Amount',
        selectDate: trackingPrefix + 'Select Specific Date'
      },
      types: {
        income: 'Income',
        expense: 'Expense'
      }
    }
  };


  /**
   * @name financeTracker
   * @constructor
   */
  angular.module('financeTracker', ['ui.router', 'config', 'common'])
    .constant('financeTracker.config', config);
}());

(function(){

  /**
   * @name financeTracker.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {services.date} dateService
   * @param {logger} logger
   * @constructor
   */
  function Svc($q, $http, config, dateService, logger){
    var path = config.paths.services + '/transactions';

    /**
     * @name financeTracker.service.getSummary
     * @methodOf financeTracker.service
     * @param {Date} startDate
     * @param {Date} endDate
     * @returns {Promise<TransactionSummary>}
     */
    this.getSummary = function(startDate, endDate){
      if (!_.isDate(startDate) || !_.isDate(endDate)){
        return $q.reject('Invalid date');
      }

      var sections = ['income', 'expenses', 'earnings'];
      var offset = (new Date()).getTimezoneOffset() / 60;

      // copy the dates since they get modified
      startDate = new Date(startDate);
      endDate = new Date(endDate);

      // starting monday at midnight UTC
      startDate.setHours(startDate.getHours() - offset);

      // ending sunday at 11:59:59 UTC
      endDate.setHours(endDate.getHours() - offset + 23);
      endDate.setMinutes(59);
      endDate.setSeconds(59);

      var params = {
        startDate: startDate,
        endDate: endDate
      };

      return $http.get(path + '/summary', { params: params })
        .then(function(response){
          var data = response.data;

          if (!data || data.status === 'ERROR'){
            return $q.reject(data || 'No response data');
          }

          _.each(sections, function(key){
            data[key].absPeriod = Math.abs(data[key].period);
          });

          return data;
        })
        .catch(function(err){
          logger.error({
            message: 'Failed to get finance summary',
            res: err
          });

          return $q.reject(err);
        });
    };

    /**
     * @name financeTracker.service.getCategories
     * @methodOf financeTracker.service
     * @returns {Promise<TransactionCategory[]>}
     */
    this.getCategories = function(){

      //return $q.when([{"id":1,"categoryId":14,"subCategoryId":1401,"category":"Auto & Transport","subCategory":"Gas & Fuel","productCategory":"Gas","transactionType":"expense"},{"id":2,"categoryId":14,"subCategoryId":1403,"category":"Auto & Transport","subCategory":"Service & Parts","productCategory":"Car Maintenance","transactionType":"expense"},{"id":3,"categoryId":14,"subCategoryId":1405,"category":"Auto & Transport","subCategory":"Auto Insurance","productCategory":"Car Insurance","transactionType":"expense"},{"id":4,"categoryId":5,"subCategoryId":506,"category":"Health & Fitness","subCategory":"Health Insurance","productCategory":"Health Insurance","transactionType":"expense"},{"id":5,"categoryId":7,"subCategoryId":701,"category":"Food & Dining","subCategory":"Groceries","productCategory":"Passenger Goodies","transactionType":"expense"},{"id":6,"categoryId":2,"subCategoryId":204,"category":"Shopping","subCategory":"Electronics & Software","productCategory":"Music or other Paid Apps","transactionType":"expense"},{"id":7,"categoryId":0,"subCategoryId":0,"category":"Uncategorized","subCategory":"Uncategorized expense","productCategory":"Other","transactionType":"expense"},{"id":8,"categoryId":30,"subCategoryId":3001,"category":"Income","subCategory":"Paycheck","productCategory":"Income","transactionType":"income"}]);

      return $http.get(path + '/categories')
        .then(function(response){
          return _.isArray(response.data) ? response.data : [];
        });
    };

    /**
     * @name financeTracker.service.getTransactions
     * @methodOf financeTracker.service
     * @param {Date} startDate
     * @param {Date} endDate
     * @returns {Promise<Transaction[]>}
     */
    //this.getTransactions = function(startDate, endDate){
    //  var params = {
    //    startDate: startDate,
    //    endDate: endDate
    //  };
    //
    //  return $http.get(path, { params: params })
    //    .then(function(response){
    //
    //      console.log(response);
    //
    //      return _.isArray(response.data) ? response.data : [];
    //    });
    //};

    /**
     * @name financeTracker.service.postTransaction
     * @methodOf financeTracker.service
     * @param {Transaction} payload
     * @returns {Promise<Transaction>}
     */
    this.postTransaction = function(payload){
      return $http.post(path, { transaction: payload })
        .then(function(response){
          return response.data;
        })
        .catch(function(err){
          console.error(err);
        });
    };

    /**
     * Finance week is monday - sunday
     * @name financeTracker.service.getLastWeek
     * @methodOf financeTracker.service
     * @returns {Date[]}
     */
    this.getLastWeek = function(){
      var today = new Date();
      today.setDate(today.getDate() - 7);
      return dateService.getWeek(today, 1);
    };
  }
  Svc.$inject = ['$q', '$http', 'config', 'services.date', 'logger'];

  angular.module('financeTracker')
    .service('financeTracker.service', Svc);

  /**
   * @typedef {Object} TransactionSummary
   * @property {number} periodDays number of days spanned in the returned data
   * @property {TransactionSummarySection} earnings
   * @property {TransactionSummarySection} expenses
   * @property {TransactionSummarySection} income
   */

  /**
   * @typedef {Object} TransactionSummarySection
   * @property {number} period
   * @property {number} previousPeriod
   * @property {number} yearToDate
   */

  /**
   * @typedef {Object} TransactionCategory
   * @property {number} id
   * @property {number} categoryId
   * @property {number} subCategoryId
   * @property {string} category
   * @property {string} subCategory
   * @property {string} productCategory
   * @property {string} transactionType
   */

  /**
   * @typedef {Object} Transaction
   * @property {string} id
   * @property {number} categoryId
   * @property {string} userId
   * @property {string} source
   * @property {string} payeeName
   * @property {string} amount
   * @property {string} currencyType
   * @property {Date} settledOn
   * @property {Date} submittedOn
   */

}());
(function(){

  function Ctrl(financeService){
    this.summary = {};
    var week = financeService.getLastWeek();

    financeService.getSummary(week[0], week[6])
      .then(function(data){
        this.summary = data;
        this.tokens = {
          income: data.income.absPeriod.toFixed(2),
          expenses: data.expenses.absPeriod.toFixed(2),
          earnings: data.earnings.absPeriod.toFixed(2)
        };
      }.bind(this));
  }
  Ctrl.$inject = ['financeTracker.service'];

  angular.module('financeTracker')
    .controller('financeTracker.summaryCtrl', Ctrl);
}());
(function(){

  /**
   * @name financeTracker.txnBuilder
   * @param {ng.$q} $q
   * @param {services.date} dateService
   * @param {financeTracker.service} financeService
   * @constructor
   */
  function Builder($q, dateService, financeService){
    var data = {};
    var directMapKeys = ['source', 'payeeName'];

    /**
     * @name financeTracker.txnBuilder.getValue
     * @methodOf financeTracker.txnBuilder
     * @param {string} key
     * @returns {*}
     */
    this.getValue = function(key){
      return data[key];
    };

    /**
     * @name financeTracker.txnBuilder.setValue
     * @methodOf financeTracker.txnBuilder
     * @param {string} key
     * @param {*} value
     * @returns {financeTracker.txnBuilder}
     */
    this.setValue = function(key, value){
      data[key] = value;
      return this;
    };

    /**
     * @name financeTracker.txnBuilder.setValues
     * @methodOf financeTracker.txnBuilder
     * @param {Object} obj key value pairs
     * @returns {financeTracker.txnBuilder}
     */
    this.setValues = function(obj){
      _.extend(data, obj);
      return this;
    };

    /**
     * @name financeTracker.txnBuilder.start
     * @methodOf financeTracker.txnBuilder
     * @param {string} type income or expense
     * @returns {financeTracker.txnBuilder}
     */
    this.start = function(type){
      data = {};
      data.multiplier = type === 'income' ? 1 : -1;
      data.type = type;
      data.started = true;
      data.week = financeService.getLastWeek();
      return this;
    };

    /**
     * Send the transaction request and reset the data object
     * @name financeTracker.txnBuilder.finish
     * @methodOf financeTracker.txnBuilder
     * @returns {Promise.<Transaction>}
     */
    this.finish = function(){
      var amount = parseFloat(data.amount);
      if (_.isNaN(amount)){
        return $q.reject('Invalid amount');
      }

      /** @type {Transaction} **/
      var payload = _.pick(data, directMapKeys);
      payload.settledOn = dateService.toIsoDate(data.day);
      payload.categoryId = data.category.id;
      payload.amount = amount * (data.multiplier || 1) + '';

      return financeService.postTransaction(payload)
        .then(function(response){
          data = {};

          return response;
        });
    };
  }
  Builder.$inject = ['$q', 'services.date', 'financeTracker.service'];

  angular.module('financeTracker')
    .service('financeTracker.txnBuilder', Builder);
}());
/**
 * @namespace google
 */
angular.module('google', ['config']);
angular.module('google')
  .directive('googleAutocomplete', [
    '$parse',
    'google.maps',
    function($parse, googleMaps){

      return {
        link: function($scope, $element, $attr){
          var onChange = angular.noop;

          if ($attr.onPlaceChange){
            onChange = $parse($attr.onPlaceChange);
          }

          googleMaps.promise.then(function(api){
            var ac = new api.places.Autocomplete($element.get(0), { types: ['geocode'] });
            api.event.addListener(ac, 'place_changed', function(){
              var place = ac.getPlace();

              if (place !== null){
                place = googleMaps.mapResultToAddress(place);
                onChange($scope, { place: place });
              }
            });

          });

          // fastclick conflict fix
          $element.on('focus keyup', function(){
            setTimeout(function(){
              $('*', 'body > .pac-container').addClass('needsclick');
            }, 500);
          }).on('click', function(){
            this.select();

            if (_.isFunction(this.setSelectionRange)){
              this.setSelectionRange(0, 99999);
            }
          });

        }
      };
    }
  ]);

(function(){

  // style from https://snazzymaps.com/style/4237/red-hat-antwerp
  var customStyle = [
    {
      "featureType": "administrative",
      "elementType": "labels.text.fill",
      "stylers": [
        {
          "color": "#444444"
        }
      ]
    },
    {
      "featureType": "landscape",
      "elementType": "all",
      "stylers": [
        {
          "color": "#f2f2f2"
        }
      ]
    },
    {
      "featureType": "poi",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "off"
        }
      ]
    },
    {
      "featureType": "poi.business",
      "elementType": "geometry.fill",
      "stylers": [
        {
          "visibility": "on"
        }
      ]
    },
    {
      "featureType": "road",
      "elementType": "all",
      "stylers": [
        {
          "saturation": -100
        },
        {
          "lightness": 45
        }
      ]
    },
    {
      "featureType": "road.highway",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "simplified"
        }
      ]
    },
    {
      "featureType": "road.arterial",
      "elementType": "labels.icon",
      "stylers": [
        {
          "visibility": "off"
        }
      ]
    },
    {
      "featureType": "transit",
      "elementType": "all",
      "stylers": [
        {
          "visibility": "off"
        }
      ]
    },
    {
      "featureType": "water",
      "elementType": "all",
      "stylers": [
        {
          "color": "#b4d4e1"
        },
        {
          "visibility": "on"
        }
      ]
    }
  ];

  function MapDirective(googleMaps){
    return {
      scope: {
        center: '=',
        centerMarker: '=?',
        zoom: '@?',
        markers: '=?'
      },
      link: function($scope, $element){

        var map;
        var mapsApi;
        var markers = [];
        var centerMarker;
        var initialZoom =  parseInt($scope.zoom || '15');

        // Add map class so we can make css changes and not have it affect google maps css
        $element.addClass('map');

        googleMaps.promise.then(function(maps){
          mapsApi = maps;
          //var latLng = new maps.LatLng(parseFloat($scope.center.lat), parseFloat($scope.center.lng));
          var mapOptions = {
            //center: latLng,
            zoom: initialZoom,
            disableDefaultUI: true,
            styles: customStyle
          };

          map = new maps.Map($element[0], mapOptions);

          $scope.$watch('center', setCenter);
          $scope.$watch('markers', writeMarkers);
        });

        function setCenter(){
          map.setCenter($scope.center);
          if ($scope.centerMarker){
            if (centerMarker){
              googleMaps.clearMarkers([centerMarker]);
            }

            centerMarker = createMarker($scope.center);
          }
        }

        function createMarker(position){
          return new mapsApi.Marker({
            position: {
              lat: position.lat,
              lng: position.lng
            },
            map: map,
            draggable: false
          });
        }

        function writeMarkers(){
          // use these for setting the bounds on the map so all markers can be seen
          var maxLat, minLat, maxLng, minLng, swBound, neBound;

          maxLat = maxLng = -Number.MAX_VALUE;
          minLat = minLng = Number.MAX_VALUE;

          googleMaps.clearMarkers(markers);

          markers = _.map($scope.markers, function(marker){
            maxLat = Math.max(maxLat, marker.lat);
            minLat = Math.min(minLat, marker.lat);

            maxLng = Math.max(maxLng, marker.lng);
            minLng = Math.min(minLng, marker.lng);

            return createMarker(marker);
          });

          if (markers.length){
            swBound = new mapsApi.LatLng(minLat, minLng);
            neBound = new mapsApi.LatLng(maxLat, maxLng);

            map.fitBounds(new mapsApi.LatLngBounds(swBound, neBound));
            // make sure if there's only 1 marker it doesn't zoom all the way in
            map.setZoom(Math.min(map.getZoom(), initialZoom));
          }
        }
      }
    };
  }
  MapDirective.$inject = ['google.maps'];

  angular.module('google')
    .directive('googleMap', MapDirective);
}());
(function(){

  /**
   * @name google.maps
   * @param {ng.$q} $q
   * @param {config} config
   * @param {Object} configService
   */
  function MapsService($q, config, configService){
    var self = this;
    // this only gets executed once since it's a service
    var mapsReadyDeferred = $q.defer();
    var script = document.createElement('script');

    window.onMapsReady = function(){
      mapsReadyDeferred.resolve(window.google.maps);
    };

    script.type = 'text/javascript';
    script.src = 'https://maps.googleapis.com/maps/api/js?v=3&callback=onMapsReady&libraries=places&key=' + config.google.apiKey;

    //if (!configService.isLocal()){
    //  script.src += '&key=' + config.google.apiKey;
    //}

    // this is here for unit testing to succeed,
    // it is already included in karma.conf
    if (!window.google || !window.google.maps){
      document.body.appendChild(script);
    }

    /**
     * Get a fully qualified address from lat and lng
     * @name google.maps.getAddress
     * @memberOf google.maps
     * @param {{ lat: number?, lng: number?, address: string?}} options
     * @returns {Promise<Address>}
     */
    this.getAddress = function(options){
      var addressDeferred = $q.defer();

      mapsReadyDeferred.promise.then(function(maps){

        var geocoder = new maps.Geocoder();
        var params = {};

        if (options.lat && options.lng){
          params = { latLng: new maps.LatLng(options.lat, options.lng) };
        }
        else {
          params = { address: options.address };
        }

        geocoder.geocode(params, function(results, status){
          if (status === maps.GeocoderStatus.OK && results.length){
            var streetAddressResult = _.find(results, function(result){
              return _.isArray(result.types) && result.types[0] || null;
            });

            addressDeferred.resolve(self.mapResultToAddress(streetAddressResult));
          }

          else {
            addressDeferred.reject(status);
          }
        });
      });

      return addressDeferred.promise;
    };

    /**
     * @param {Address} addressObj
     * @returns {string}
     */
    this.getAddressString = function(addressObj){
      var str = '';
      if (addressObj.street){
        str = addressObj.street + ' ';

        if (addressObj.unit){
          str += addressObj.unit + ' ';
        }
      }

      str += addressObj.city + ', ' + addressObj.state;

      if (addressObj.zipcode){
        str += ' ' + addressObj.zipcode;
      }

      return $.trim(str);
    };

    this.promise = mapsReadyDeferred.promise;

    /**
     * @param {Address} address
     * @param {Address} [startingAddress] defaults to current location
     * @returns {string}
     */
    this.getDirectionsUrl = function(address, startingAddress){
      var start = 'Current+Location';

      if (startingAddress && startingAddress.street){
        start = encodeDirectionsAddress(startingAddress);
      }

      return '//www.google.com/maps/dir/' + start + '/' + encodeDirectionsAddress(address);
    };

    function encodeDirectionsAddress(address){
      return encodeURI([address.street, address.city, address.state, address.zipcode].join(' '));
    }

    /**
     *
     * @param {google.maps.geoCoderResult} result
     * @returns {Address}
     */
    this.mapResultToAddress = function(result){
      if (!result || !result.address_components) {
        return null;
      }

      var components = result.address_components;
      var streetNumber = findComponentByType(components, 'street_number');
      var streetName = findComponentByType(components, 'route');
      var city = findComponentByType(components, 'locality');
      var county = findComponentByType(components, 'administrative_area_level_2');
      var state = findComponentByType(components, 'administrative_area_level_1', true);
      var zipcode = findComponentByType(components, 'postal_code');

      return {
        street: streetNumber + ' ' + streetName,
        city: city,
        county: county,
        state: state,
        zipcode: zipcode,
        lat: result.geometry.location.lat(),
        lng: result.geometry.location.lng()
      };
    };

    /**
     * @param {google.maps.geoCoderAddressComponent[]} components
     * @param {string} type
     * @param {boolean} [useShort]
     * @returns {string}
     */
    function findComponentByType(components, type, useShort){
      var match = _.find(components, function(component){
        return _.isArray(component.types) && component.types.indexOf(type) > -1;
      });

      if (match){
        return useShort ? match.short_name : match.long_name;
      }

      return '';
    }

    /**
     * Remove markers from the map and clear the array to release from memory
     * @param {google.maps.marker[]} markers
     */
    this.clearMarkers = function(markers){
      _.each(markers, function(marker){
        marker.setMap(null);
      });

      markers.length = 0;
    };
  }
  MapsService.$inject = ['$q', 'config', 'config.service'];

  angular.module('google')
    .service('google.maps', MapsService);
}());

/**
 * @name google.maps.latLng
 * @function {number} lat
 * @function {number} lng
 */

/**
 * @name google.maps.geometry
 * @property {google.maps.latLng} location
 * @property {{ northeast: google.maps.latLng, southwest: google.maps.latLng }} viewport
 * @property {string} location_type
 */

/**
 * @name google.maps.geoCoderAddressComponent
 * @property {string} long_name
 * @property {string} short_name
 * @property {string[]} types
 */

/**
 * @name google.maps.geoCoderResult
 * @property {google.maps.geoCoderAddressComponent[]} address_components
 * @property {google.maps.geometry} geometry
 * @property {string} formatted_address
 * @property {string} place_id
 * @property {string[]} types
 */

/**
 * @name google.maps.marker
 * @property {Function} setMap
 */




/**
 * @namespace income
 */
angular.module('income', ['common', 'translate']);
/**
 * @namespace health
 */
angular.module('health', ['common', 'translate', 'search', 'doctor', 'member']);
angular.module('join', ['scrollTo', 'common']);
angular.module('join')
    .controller('joinCtrl',[
        '$state',
        '$window',
        'user.service',
        'baseUser',
        'baseHealthApp',
        function($state, $window, userService, userModel, applicationModel){
            var self = this;
            this.inputsVisible = false;
            this.model = {};

            this.showInputs = function() {
                self.inputsVisible = true;
            };

            this.create = function(model){
                if (model.form.$valid && model.username && model.password) {
                    return userService.createFromForm(model.username, model.password, userModel, applicationModel, model.form)
                        .then(function(){
                            // twitter remarketing conversion
                            if ($window.twttr && $window.twttr.conversion){
                                $window.twttr.conversion.trackPid('l6i0x', { tw_sale_amount: 0, tw_order_quantity: 0 });
                            }

                            $state.go('dashboard');
                        })
                        .catch(function(err){
                            if (err.message === 'user already exists'){
                                $state.go('account.login', { user: model.username });
                            }
                        });
                }
            };
        }
    ]);
/**
 * @namespace member
 */
angular.module('member', ['common', 'translate', 'session']);

(function () {

  /**
   *
   * @param $scope
   * @param $state
   * @param $stateParams
   * @param userModel
   * @param memberService
   * @param alertService
   * @param snackbarService
   * @param dateService
   * @param applicationModel
   * @constructor
   */
  function Ctrl($q, $scope, $state, $stateParams, userModel, memberService, alertService, snackbarService, dateService, applicationModel) {
    var self = this;
    this.render = false;

    // Clear data teaser
    alertService.setMessage(null);
    snackbarService.clear();

    // Get member and make a copy so user can cancel changes
    memberService.getById($stateParams.memberId)
      .then(function (member) {
        self.savedMember = member;
        $scope.member = angular.copy(member);
        self.render = true;
      });

    /**
     * Save member
     */
    this.save = function () {
      $q.when($scope.member.dob)
        .then(function (dob) {
          if (dob) {
            return dateService.getStartDateAge(dob, applicationModel);
          }
          return $scope.member.age;
        })
        .then(function (age) {
          $scope.member.age = age;

          if (!memberService.isValid($scope.member)) {
            $scope.member.invalid = true;
            return;
          }
          return memberService.saveMember(userModel, $scope.member);
        })
        .then(function (member) {
          if (member) {
            $scope.$emit('member-updated', member);
            $state.replace('^');
          }
        });
    };

    /**
     * Delete member
     */
    //this.deleteMember = function () {
    //  memberService.deleteMember($scope.member.id)
    //    .then(function (response) {
    //      $state.go('^');
    //    });
    //};

    // This logic is application specific, so should be handled in a route controller
    //$scope.dobUpdated = function (member) {
    //  dateService.getStartDateAge(member.dob, applicationModel)
    //    .then(function (startDateAge) {
    //      member.age = startDateAge;
    //    });
    //};
  }

  Ctrl.$inject = ['$q', '$scope', '$state', '$stateParams', 'baseUser', 'member.service', 'services.alert', 'snackbar.service', 'services.date', 'baseHealthApp'];

  angular.module('member')
    .controller('member.detail.controller', Ctrl);
}());

angular.module('member')
  .directive('shMember', [
    'config',
    'translate.service',
    function (config, translateService) {
      return {
        templateUrl: config.paths.partials + '/components/member/member-directive.html',
        scope: {
          member: '=',
          editMode: '=?',
          editDetail: '=?',
          added: '=?',
          isDisabled: '=?',
          disableRemove: '=?',
          onToggle: '&',
          hideToggle: '=?',
          removeMember: '&',
          editMember: '&',
          onAgeBlur: '&',
          allRequired: '@?',
          hideEdit: '=?'
        },
        link: function ($scope) {
          if ($scope.member.gender) {
            $scope.gender = $scope.member.gender === 'M' ? 'Male' : 'Female';
          }

          $scope.isDobRequired = function () {
            var required = false;
            if ($scope.allRequired === 'true' || $scope.allRequired === true) {
              required = true;
            }
            return !$scope.member.dob && required;
          };

          var relation = $scope.member.relation;
          if ($scope.member.type === 'primary') {
            //$scope.relation = 'Myself';
          }
          else if (relation) {
            translateService.translate('buy.applicant.relationships')
              .then(function (response) {
                var relationship = _.findWhere(response, {key: relation});
                $scope.relation = relationship.value;
              })
          }

          $scope.updateType = function (member) {
            member.invalid = false;
            if (member.relation === 'husband' || member.relation === 'wife') {
              member.type = 'spouse';
            } else {
              member.type = 'dependent';
            }
          };
        }
      };

    }
  ]);
(function () {

  /**
   *
   * @param $scope
   * @param $state
   * @param $timeout
   * @param memberService
   * @param utils
   * @constructor
   */
  function Ctrl($scope, $state, $timeout, memberService, utils) {
    var self = this;

    self.render = true;

    // Check if the primary user is complete for new accounts
    var primary = _.findWhere($scope.members.allMembers, {type: 'primary'});
    var isInNewMembers = _.findWhere($scope.members.newMembers, {type: 'primary'});
    if (!isInNewMembers && (!primary.gender || !primary.age)) {
      $scope.members.newMembers.push(primary);
    }

    /**
     * Checks if this member is added to the app
     * @param member
     */
    this.isAdded = function (member) {
      var memberIndex = _.findIndex($scope.members.appMembers, {id: member.id});

      if (memberIndex > -1) {
        if (member.status === 'coverage') {
          return true;
        } else if (!memberService.isMedicaid(member)) {
          return true;
        }
      }
      return false;
    };

    /**
     * Add spouse
     */
    this.addSpouse = function () {
      var newSpouse = {type: 'spouse', id: utils.uuid(), editMode: true, first_name: '', last_name: ''};
      if (!_.findWhere($scope.members.allMembers, {type: 'spouse'})) {
        $scope.members.allMembers.push(newSpouse);
        $scope.members.appMembers.push(newSpouse);
        $scope.members.newMembers.push(newSpouse);
      }
      $scope.members.allMembers = memberService.sortAllMembers($scope.members.allMembers);
      updateMessage();
    };

    /**
     *
     * @returns {boolean}
     */
    this.hasSpouse = function () {
      return !!_.findWhere($scope.members.allMembers, {type: 'spouse'});
    };

    /**
     * Add a dependent
     */
    this.addDependent = function () {
      var newDependent = {
        type: 'dependent',
        id: utils.uuid(),
        editMode: true,
        first_name: '',
        last_name: ''
      };
      $scope.members.allMembers.push(newDependent);
      $scope.members.appMembers.push(newDependent);
      $scope.members.newMembers.push(newDependent);
      $scope.members.allMembers = memberService.sortAllMembers($scope.members.allMembers);
      updateMessage();
    };

    /**
     * Toggle if the member should be on the application or not
     * @param member
     */
    this.toggleMember = function (member) {
      var memberIndex = _.findIndex($scope.members.appMembers, {id: member.id});

      // If the member is in app members
      if (memberIndex > -1) {
        // and if the member has medicaid status, remove medicaid status and add coverage status
        if (memberService.isMedicaid(member)) {
          member.member_application = null;
          member.status = 'coverage';
          $scope.members.appMembers[memberIndex] = member;
        } else {
          // and if the member doesn't have medicaid status, remove from array
          $scope.members.appMembers.splice(memberIndex, 1);
        }
      } else {
        // If the member is not in app members, add to app members
        member.status = 'coverage';
        $scope.members.appMembers.push(member);
      }
      updateMessage();
    };

    /**
     * Remove member
     * @param {Member} member
     */
    this.removeMember = function (member) {
      // If the member exists in the member table, delete from the member table
      //if (member.created_on) {
        memberService.deleteMember($scope.userModel, member.id)
          .then(function (response) {
            removeFromClient(member);
            updateMessage();
          });
      //} else {
      //  removeFromClient(member);
      //  updateMessage();
      //}
    };

    /**
     * Go to edit member page
     * @param member
     */
    this.editMember = function (member) {
      $state.go('.member', {memberId: member.id});
    };

    /**
     * Update message on age blur
     * @param member
     */
    this.onAgeBlur = function (member) {
      if (member && !member.age) {
        member.placeholder = 'Enter Age';
      }

      // delay the message update so the user can see the prices change
      $timeout(function () {
        updateMessage();
      }, 300);
    };

    /**
     * Checks if this person is a new member
     * @param member
     */
    this.isNewMember = function (member) {
      return _.findWhere($scope.members.newMembers, {id: member.id});
    };

    function updateMessage() {
      $scope.$emit('updated-app-members', {appMembers: $scope.members.appMembers});
      //$scope.updateMessage({appMembers: self.appMembers});
    }

    function removeFromClient(member) {
      $scope.members.appMembers = _.reject($scope.members.appMembers, {id: member.id});
      $scope.members.allMembers = _.reject($scope.members.allMembers, {id: member.id});
      $scope.members.newMembers = _.reject($scope.members.newMembers, {id: member.id});
    }

    this.isComplete = function (member) {
      return member.gender && _.isNumber(member.age);
    }
  }

  Ctrl.$inject = ['$scope', '$state', '$timeout', 'member.service', 'utils'];

  angular.module('member')
    .controller('member.controller', Ctrl);
}());

angular.module('member')
  .directive('shMemberManagement', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          members: '=',
          userModel: '='
        },
        templateUrl: paths.partials + '/components/member/member-management.html',
        controller: 'member.controller as memberCtrl'
      };
    }
  ]);
(function () {

  /**
   * @name member.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   * @param {session} session
   * @constructor
   */
  function Svc($q, $http, config, utils, session) {
    var self = this;
    var baseUrl = config.paths.services;
    var ageRanges = config.ages;
    var sessionKey = 'member';
    var memberAppSessionKey = 'member_application';

    if (!getFromSession()) {
      session.set(sessionKey, []);
    }

    if (!session.get(memberAppSessionKey)) {
      session.set(memberAppSessionKey, []);
    }


    /**
     * Gets all members for the user
     * @name member.service.get
     * @methodOf member.service
     * @param {user.model} userModel
     * @return {HttpPromise<Member[]>}
     */
    this.get = function (userModel) {
      if (!userModel.isLoggedIn) {
        return $q.when(getFromSession());
      }

      return $http.get(baseUrl + '/members')
        .then(utils.dataOrArray);
    };

    /**
     * @name member.service.getById
     * @methodOf member.service
     * @param {UUID} id
     * @returns {Promise.<Member>}
     */
    this.getById = function (id) {
      return $http.get(baseUrl + '/member', {params: {id: id}})
        .then(utils.dataOrObject);
    };

    /**
     * Checks if member is of status: coverage, medicaid, or household
     * @param {Member} member
     * @param {string} status
     * @returns {boolean}
     */
    this.isStatus = function (member, status) {
      if (member.status === status) {
        return true;
      }
      if (!member.member_application) {
        return false;
      }
      return member.member_application.type === status;
    };

    /**
     * @name member.service.isMedicaid
     * @param {Member} member
     * @returns {boolean}
     */
    this.isMedicaid = _.bind(this.isStatus, this, _, 'medicaid');

    /**
     * Filters out non medicaid members given an array
     * @param members
     * @returns {Array}
     */
    this.filterNonMedicaidAppMembers = function (members) {
      return _.filter(members, function (member) {
        return !self.isMedicaid(member);
      });
    };

    /**
     * @name member.service.getAppMembers
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @returns {HttpPromise.<Member[]>|boolean}
     */
    this.getAppMembers = function (userModel, app_id) {
      if (!userModel.isLoggedIn) {
        var allMembers = getFromSession();
        var appMembers = _.where(session.get(memberAppSessionKey), {ifp_app_id: app_id});

        var members = _.map(appMembers, function (appMember) {
          var match = _.find(allMembers, {id: appMember.member_id});
          if (match) {
            return _.extend(match, {member_application: appMember});
          }

          console.log('Member match not found for ', appMember);
        });

        // console.log(members);
        return $q.when(_.reject(members, _.isUndefined));
      }

      return $http.get(baseUrl + '/application/' + app_id + '/member')
        .then(utils.dataOrObject)
        .then(function (data) {
          return self.sortAllMembers(data.members) || [];
        });
    };

    /**
     * @name member.service.saveAppMembers
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @param {Member[]} members
     * @returns {HttpPromise.<Member[]>|boolean}
     */
    this.saveForApp = function (userModel, app_id, members) {
      if (!userModel.isLoggedIn) {
        setSessionAppMembers(app_id, members);

        members = _.map(members, function (member) {
          return _.omit(member, 'status');
        });

        return this.saveMembers(userModel, members);
      }

      return $http.post(baseUrl + '/application/' + app_id + '/member', {members: members})
        .then(utils.dataOrArray);
    };


    function setSessionAppMembers(app_id, appMembers) {

      // Clear out non app member's member_application.type to empty
      var allMembers = getFromSession();
      var remainingMembers = _.reject(allMembers, function (member) {
        return !!_.find(appMembers, {id: member.id});
      });
      _.each(remainingMembers, function (member) {
        _.extend(member.member_application, {type: ''});
      });
      session.set(sessionKey, allMembers);


      // Update member_application on app members
      var all = session.get(memberAppSessionKey);

      // remove all with app_id
      all = _.reject(all, {ifp_app_id: app_id});

      // then add back ones that are in the appMembers array
      _.each(appMembers, function (member) {
        var memberApp = {ifp_app_id: app_id, member_id: member.id, type: member.status || 'coverage'};
        member.member_application = memberApp;
        all.push(memberApp);
      });

      session.set(memberAppSessionKey, all);
    }


    /**
     * @name member.service.getMemberSet
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @returns {HttpPromise<{ allMembers: Member[], appMembers: Member[]}>}
     */
    this.getMemberSet = function (userModel, app_id) {
      var primaryTemplate = {
        type: 'primary',
        gender: null,
        age: null,
        id: userModel.getPrimaryId(),
        tobacco: false,
        first_name: '',
        middle_name: '',
        last_name: '',
        illnesses: [],
        visits: []
      };


      return $q.all([self.get(userModel), self.getAppMembers(userModel, app_id)])
        .then(function (responses) {
          // All members associated to user
          var all = {
            allMembers: responses[0] || [],
            appMembers: responses[1] || []
          };

          var existingPrimary = _.findWhere(all.allMembers, {type: 'primary'});
          if (!existingPrimary) {
            all.allMembers = all.appMembers = [primaryTemplate];
          } else {
            // Sort all members by primary, spouse, then dependents
            if (!_.findWhere(all.appMembers, {type: 'primary'})) {
              all.appMembers.push(existingPrimary);
            }
          }

          // Add member application status to all members
          _.each(all.appMembers, function (appMember) {
            var allMember = _.findWhere(all.allMembers, {id: appMember.id})
            if (allMember) {
              allMember.member_application = appMember.member_application;
            }
          });

          all.allMembers = self.sortAllMembers(all.allMembers);
          all.appMembers = self.sortAllMembers(all.appMembers);

          return all;
        });

    };

    /**
     * Sorts list: primary, spouse then dependents
     * @param allMembers
     */
    this.sortAllMembers = function (allMembers) {
      var primary = _.where(allMembers, {type: 'primary'});
      var spouse = _.where(allMembers, {type: 'spouse'});
      var dependents = _.where(allMembers, {type: 'dependent'});
      var members = _.where(allMembers, {type: ''});
      return _.union([], primary, spouse, dependents, members);
    };

    /**
     * @name member.service.saveMember
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {Member} member
     * @returns {Promise.<Member>}
     */
    this.saveMember = function (userModel, member) {
      if (!userModel.isLoggedIn) {
        var allMembers = getFromSession();
        var matchIndex = _.findIndex(allMembers, {id: member.id});
        if (matchIndex === -1) {
          allMembers.push(member);
        }
        else {
          allMembers.splice(matchIndex, 1, member);
        }

        session.set(sessionKey, allMembers);
        return $q.when(member);
      }

      return $http.post(baseUrl + '/member', {member: member})
        .then(utils.dataOrObject);
    };

    /**
     * @name member.service.saveMembers
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {Member[]} members
     * @returns {Promise.<Member[]>}
     */
    this.saveMembers = function (userModel, members) {
      if (!userModel.isLoggedIn) {
        _.each(members, _.partial(this.saveMember, userModel));
        return $q.when(members);
      }

      return $http
        .post(baseUrl + '/members', {
          members: members
        })
        .then(utils.dataOrArray);
    };

    /**
     * @name member.service.deleteMember
     * @methodOf member.service
     * @param {user.model} userModel
     * @param {string} member_id
     * @returns {HttpPromise.<boolean>}
     */
    this.deleteMember = function (userModel, member_id) {
      if (!userModel.isLoggedIn) {
        session.set(sessionKey, _.reject(getFromSession, {id: member_id}));
        return $q.when(true);
      }

      return $http.delete(baseUrl + '/member', {id: member_id})
        .then(utils.dataOrObject);
    };

    /**
     * @name member.service.getPrimary
     * @methodOf member.service
     * @param {user.model} userModel
     * @returns {HttpPromise<Member>}
     */
    this.getPrimary = function (userModel) {
      var self = this;

      return this.get(userModel)
        .then(function (members) {
          // solve for possibility of many members w/ type = primary
          var primaries = _.where(members, {type: 'primary'});

          if (primaries.length === 0) {
            return $q.reject('No valid primary member');
          }

          // get first valid primary or first primary
          return _.find(primaries, self.isValid) || primaries[0];
        });
    };

    /**
     * @name member.service.addAppMember
     * @methodOf member.service
     * @param {string} memberId
     * @param {string} appId
     * @param {string} [type]
     * @returns {Promise}
     */
    this.addAppMember = function (memberId, appId, type) {
      return $http.post(baseUrl + '/member/application', {
        id: memberId,
        appId: appId,
        type: type
      });
    };

    /**
     * @name member.service.isValid
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isValid = function (member) {
      return member && member.type &&
        _.isNumber(member.age) &&
        ageRanges[member.type] &&
        member.age >= ageRanges[member.type][0] &&
        member.age <= ageRanges[member.type][1] &&
        (member.gender === 'M' || member.gender === 'F');
    };

    /**
     * @name member.service.isComplete
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isComplete = function (member) {
      var requiredEveryone = member.first_name && member.last_name && member.gender && member.ssn && member.dob;
      if (member.type === 'primary') {
        return requiredEveryone && !!member.marital_status;

      }
      return requiredEveryone && !!member.relation;
    };

    /**
     * Return the current applicant model in the format that extras uses
     * @name member.service.asExtrasFormat
     * @methodOf member.service
     * @param {Member} member
     * @param {string} key
     * @returns {{id: UUID, value: string, dob: string}}
     */
    this.asExtrasFormat = function (member, key) {
      var app = {
        uuid: member.id,
        value: member.first_name + ' ' + member.last_name,
        dob: member.dob
      };
      app[key] = false;

      return app;
    };


    /**
     * @name member.service.isMarried
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isMarried = function (member) {
      return member.marital_status === 'married';
    };

    /**
     * @name member.service.isPrimary
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isPrimary = function (member) {
      return member && member.type === 'primary';
    };

    /**
     * @name member.service.isSpouse
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isSpouse = function (member) {
      return member && member.type === 'spouse';
    };

    /**
     * @name member.service.isDependent
     * @methodOf member.service
     * @param {Member} member
     * @returns {boolean}
     */
    this.isDependent = function (member) {
      return member && member.type === 'dependent';
    };

    /**
     * @name member.service.clearSession
     * @methodOf member.service
     */
    this.clearSession = function () {
      session.remove(sessionKey);
      session.remove(memberAppSessionKey);
    };

    /**
     * @name member.service.getFromSession
     * @methodOf member.service
     * @returns {Member[]}
     */
    function getFromSession() {
      return session.get(sessionKey);
    }

    this.getFromSession = getFromSession;


    /**
     * @name member.service.sortMembers
     * @methodOf member.service
     * @param {Member} member1
     * @param {Member} member2
     * @returns {number}
     * @private
     */
    function sortMembers(member1, member2) {
      // primary first
      if (this.isPrimary(member1)) {
        return -1;
      }
      if (this.isPrimary(member2)) {
        return 1;
      }
      // then spouse
      if (this.isSpouse(member1)) {
        return -1;
      }
      if (this.isSpouse(member2)) {
        return 1;
      }
      // dependent order doesn't matter, so leave natural ordering
      return 0;
    }

    /**
     * @name member.service.setOrder
     * @methodOf member.service
     * @param {Member[]} members
     * @returns {Member[]}
     */
    function setOrder(members) {
      return members.sort(_.bind(sortMembers, this));
    }

    this.setOrder = _.bind(setOrder, this);
  }

  Svc.$inject = ['$q', '$http', 'config', 'utils', 'session'];

  angular.module('member')
    .service('member.service', Svc);
}());


/**
 * @typedef {Object} Member
 * @property {UUID} id
 * @property {UUID} user_id
 * @property {string} type
 * @property {string} first_name
 * @property {string} middle_name
 * @property {string} last_name
 * @property {string} dob
 * @property {number} age
 * @property {string} relationship
 * @property {string} gender
 * @property {string} ssn
 * @property {string[]} illnesses
 * @property {boolean} tobacco
 * @property {string} marital_status
 * @property {object} risk_factors
 *
 * These are added by sequelize associations
 * @property {Address} address
 * @property {MemberProvider[]} member_providers
 * @property {MemberDrug[]} member_drugs
 */

/**
 * @typedef {Object} MemberApplication
 * @property {string} member_id
 * @property {string} ifp_app_id
 * @property {Date} esigned_on
 * @enum {string} type One of 'coverage', 'household'
 */

angular.module('modal', ['config']);
angular.module('modal')
  .directive('shModal', [
    'config.paths',
    'modal.service',
    function (paths, modalService) {
      return {
        templateUrl: paths.partials + '/components/modal/modal.html',
        scope: {},
        link: function ($scope) {
          $scope.render = modalService.getRender;
          $scope.title = modalService.getTitleKey;
          $scope.body = modalService.getBodyKey;
        }
      };
    }
  ]);
angular.module('modal')
  .service('modal.service', [
    function () {

      var self = this;

      this.push = function(config) {
        self.titleKey = config.titleKey;
        self.bodyKey = config.bodyKey;
        self.render = config.render;
      };

      this.setRender = function(render) {
        self.render = render;
      };

      this.getRender = function() {
        return self.render;
      };

      this.getTitleKey = function() {
        return self.titleKey;
      };


      this.getBodyKey = function() {
        return self.bodyKey;
      };

    }
  ]);

/**
 * @namespace partner
 */
angular.module('partner', ['config']);
(function(){

  /**
   * @name partner.service
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   */
  function Svc($http, config, utils){
    var serviceBase = config.paths.services + '/partner';

    /**
     * @name partner.service.requiresNotifyOptIn
     * @methodOf partner.service
     * @returns {Promise<boolean>}
     */
    this.requiresNotifyOptIn = function(){
      return $http.get(serviceBase + '/notify/opt-in-required')
        .then(utils.dataOrFalse);
    };

    /**
     * @name partner.service.notifyOptIn
     * @methodOf partner.service
     * @param {boolean} value
     * @returns {Promise<boolean>}
     */
    this.notifyOptIn = function(value){
      return $http.post(serviceBase + '/notify/opt-in', { optIn: value })
        .then(utils.dataOrFalse);
    };
  }
  Svc.$inject = ['$http', 'config', 'utils'];

  angular.module('partner')
    .service('partner.service', Svc);
}());
/**
 * @namespace notification
 */
angular.module('notification', ['config', 'common.services', 'session']);
(function(){

  /**
   * @name notification.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {session} session
   * @param {services.auth} authService
   * @param {utils} utils
   * @param {logger} logger
   */
  function Svc($q, $http, config, session, authService, utils, logger){
    var self = this;
    var url = config.paths.notification + '/messages';
    var sessionKey = 'notification-queue';
    /**
     * @type {Object<string, Notification[]>}
     */
    var queue = session.get(sessionKey) || {};
    
    /**
     * @typedef {Object} Notification
     * @property {UUID} id
     * @property {UUID} userId
     * @property {string} messageType
     * @property {Object} payload
     * @property {Date} generatedOn
     * @property {NotificationFormatting} formatted
     */

    /**
     * @typedef {Object} NotificationFormatting
     * @property {string} fullText
     * @property {string} safeText
     * @property {string} linkText
     * @property {string} linkUrl
     */

    /**
     * @name notification.service.shared
     * @memberOf notification.service
     * @type {Object<string, Notification>}
     * @private
     */
    var shared = {
      drugs: {
        "messageType": "FTUX_find_drugs",
        "payload": {}
      },
      doctors: {
        "messageType": "FTUX_find_doctor",
        "payload": {}
      },
      concierge: {
        "messageType": "FTUX_free_concierge",
        "payload": {}
      }
    };

    var mainTypes = ['Health','FTUX','BOR'];

    /**
     * @name notification.service.getShared
     * @methodOf notification.service
     * @returns {Object<string, Notification>}
     */
    this.getShared = function(){
      return angular.copy(shared);
    };

    /**
     * @name notification.service.get
     * @methodOf notification.service
     * @param {Object} params
     * @param {UUID} params.userId
     * @param {number} [params.limit=50]
     * @param {string} [params.mainTypes='Health,FTUX,BOR']
     * @param {boolean} [params.read]
     */
    this.get = function(params){
      if (!params.userId){
        return $q.reject('Invalid userId parameter');
      }

      if (!params.mainTypes){
        params.mainTypes = mainTypes.join(',');
      }

      return getRequestConfig()
        .then(function(config){
          return $http.get(url, _.extend(config, { params: params }));
        })
        .then(utils.dataOrArray)
        .catch(function(err){
          logger.error({
            message: 'Get notifications error',
            stack: err
          });

          return [];
        });
    };

    /**
     * @name notification.service.post
     * @methodOf notification.service
     * @param {Notification[]} notifications
     * @param {string} [userId]
     * @returns {Promise<boolean>}
     */
    this.post = function(notifications, userId){
      // if userId is passed in, set any notification's userId property to it
      if (_.isString(userId) && userId.length){
        _.each(notifications, function(n){
          n.userId = userId;
        });
      }

      return getRequestConfig()
        .then(function(config){
          return $http.post(url, notifications, config);
        })
        .then(function(res){
          return res && res.status === 201;
        })
        .catch(function(err){
          logger.error({
            message: 'Post notifications error',
            stack: err
          });

          return false;
        });
    };

    /**
     * @name notification.service.markAsRead
     * @methodOf notification.service
     * @param {UUID} notificationId
     * @returns {Promise<boolean>}
     */
    this.markAsRead = function(notificationId){
      return getRequestConfig()
        .then(function(config){
          return $http.post(url + '/' + notificationId + '/_read', null, config);
        })
        .then(function(res){
          return res && res.status === 200;
        })
        .catch(function(err){
          logger.error({
            message: 'Mark as read notifications error',
            stack: err
          });

          return false;
        });
    };

    /**
     * @name notification.service.enqueue
     * @methodOf notification.service
     * @param {string} key
     * @param {Notification} notification
     * @returns {boolean}
     */
    this.enqueue = function(key, notification){
      ensureArray(key);
      var index = findIndex(key, notification);
      // don't push the same notification
      if (index > -1){
        return false;
      }

      queue[key].push(notification);
      save();
      return true;
    };

    /**
     * @name notification.service.dequeue
     * @methodOf notification.service
     * @param {string} key
     * @param {Notification} notification
     * @returns {boolean}
     */
    this.dequeue = function(key, notification){
      ensureArray(key);
      var index = findIndex(key, notification);
      if (index < 0){
        return false;
      }

      queue[key].splice(index, 1);
      save();
      return true;
    };

    /**
     * Posts the full contents of the queue key
     * and deletes the key on success
     * @name notification.service.postQueue
     * @methodOf notification.service
     * @param {string} key
     * @returns {Promise<boolean>}
     */
    this.postQueue = function(key){
      ensureArray(key);

      if (!queue[key].length){
        return $q.when(false);
      }

      return this.post(queue[key])
        .then(function(success){
          if (success){
            self.clearQueue(key);
          }

          return success;
        });
    };

    /**
     * @name notification.service.clearQueue
     * @methodOf notification.service
     * @param {string} [key]
     */
    this.clearQueue = function(key){
      if (_.isString(key)){
        delete queue[key];
      }
      else {
        queue = {};
      }

      save();
    };

    /**
     * @name notification.service.getRequestConfig
     * @methodOf notification.service
     * @private
     * @returns {Promise<{ headers: { Authorization: string }}>}
     */
    function getRequestConfig(){
      return authService.getToken()
        .then(function(token){
          return {
            headers: {
              'jwt-internal-authorization': token
            }
          };
        });
    }


    function ensureArray(key){
      if (!_.isArray(queue[key])){
        queue[key] = [];
      }
    }

    /**
     * @name notification.service.findKey
     * @methodOf notification.service
     * @param {string} key
     * @param {Notification} notification
     * @returns {number}
     * @private
     */
    function findIndex(key, notification){
      return _.findIndex(queue[key], function(queueItem){
        return queueItem.messageType === notification.messageType;
      });
    }

    function save(){
      session.set(sessionKey, queue);
    }
  }
  Svc.$inject = ['$q', '$http', 'config', 'session', 'services.auth', 'utils', 'logger'];

  angular.module('notification')
    .service('notification.service', Svc);
}());
angular.module('plan', ['ui.router', 'config', 'common', 'application', 'search', 'health', 'doctor', 'drug', 'user', 'session']);

/**
 * @typedef {Object} HealthPlan

 * @property {number} id
 * @property {string} planId
 * @property {string} name
 * @property {string} fullName
 * @property {string} metalType platinum, gold, silver, bronze, catastrophic
 * @property {string} planType HMO, PPO, EPO, POS
 * @property {number} planYear
 * @property {string} state
 *
 * @property {number} issuerId
 * @property {number} formularyId
 *
 * @property {string} carrier
 * @property {number} carrierId
 * @property {string} carrierPlanId
 *
 * @property {number} networkId
 * @property {string} networkName
 * @property {string} networkQuality
 *
 * @property {boolean} qhpStatus
 * @property {boolean} hsaStatus
 * @property {boolean} displayActive
 * @property {boolean} txnActive
 * @property {boolean} adultDental
 *
 * @property {number} premiumMonth
 * @property {number} deductibleInd
 * @property {number} deductibleFam
 * @property {number} oonDeductibleInd
 * @property {number} oonDeductibleFam
 * @property {number} oopmaxInd
 * @property {number} oopmaxFam
 * @property {number} oonOopmaxInd
 * @property {number} oonOopmaxFam
 *
 * @property {string} urlBuy
 * @property {string} urlPdf
 *
 * @property {HealthPlanMods} mods
 * @property {Object} benefits
 */

/**
 * @typedef {Object} HealthPlanMods
 * @property {number} planId
 * @property {number} premium Unsubsidized premium
 * @property {number} premiumMonth
 * @property {number} premiumYear
 * @property {number} allInForecast
 *
 * @property {Object} oop
 * @property {number} oop.neighborsOop
 * @property {number} oop.drugsOop
 * @property {number} oop.totalOop
 *
 * @property {Object} providers
 * @property {Object[]} providers.providersAccepted
 * @property {number} providers.qtyNearby
 * @property {number} providers.totalAccepted
 *
 * @property {Object} ranks
 * @property {number} ranks.acceptedProvidersScore
 * @property {number} ranks.allInForecastScore
 * @property {number} ranks.drugsOopScore
 * @property {number} ranks.nearbyProvidersScore
 * @property {number} ranks.strideRank
 * @property {number} ranks.totalOopScore
 *
 * @property {Object} savings
 * @property {Object} savings.hsa
 * @property {number} savings.hsa.withdrawn
 * @property {number} savings.hsa.saved
 * @property {number} savings.subsidy
 *
 * @property {HealthPlanUserDrug[]} userDrugs
 *
 * @property {Object} visits
 * @property {HealthPlanLimits} limits
 */

/**
 * @typedef {Object} HealthPlanUserDrug
 * @property {number} id
 * @property {number} annualForecast
 * @property {string} product Name of drug
 * @property {string} ndc
 * @property {string} applicantId Equivalent to a member id
 * @property {string} benefitServiceType
 */

/**
 * @typedef {Object} HealthPlanLimits
 * @property {number} deductibleInd
 * @property {number} deductibleFam
 * @property {number} deductiblerxFam
 * @property {number} deductiblerxInd
 * @property {number} id
 * @property {number} oonOopmaxFam
 * @property {number} oonOopmaxInd
 * @property {number} oopmaxFam
 * @property {number} oopmaxInd
 * @property {number} planId
 */

/**
 * @typedef {Object} HealthPlanScenario
 *
 */

angular.module('plan')
  .service('plan.compare.service', [
    function () {

      /**
       * @name plan.compare.service
       */

      /**
       * @name plan.compare.service.plans
       * @memberOf plan.compare.service
       * @type {HealthPlan[]}
       */
      this.plans = [];

      /**
       * @name plan.compare.service.getPlans
       * @memberOf plan.compare.service
       * @returns {HealthPlan[]}
       */
      this.getPlans = function() {
        return this.plans;
      };

      /**
       * @name plan.compare.service.getCompareParams
       * @memberOf plan.compare.service
       * @returns {{pid1: number, pid2: number}}
       */
      this.getCompareParams = function() {
        return {
          pid1: this.plans[0] ? this.plans[0].id : null,
          pid2: this.plans[1] ? this.plans[1].id : null
        };
      };

      /**
       * @name plan.compare.service.getNumComparePlans
       * @memberOf plan.compare.service
       * @returns {Number}
       */
      this.getNumComparePlans = function() {
        return this.plans.length;
      };

      /**
       * @name plan.compare.service.getNumSelectedPlans
       * @memberOf plan.compare.service
       * @returns {number}
       */
      this.getNumSelectedPlans = function() {
          var count = 0;
          _.forEach(this.plans, function(plan) {
            if (plan.selected) {
              count++;
            }
          });
          return count;
      };

      /**
       * @name plan.compare.service.addComparePlan
       * @memberOf plan.compare.service
       * @param {HealthPlan} plan
       * @returns {boolean}
       */
      this.addComparePlan = function (plan) {
        if (this.plans.length < 2) {
            this.plans.push(plan);
            return true;
        }
        return false;
      };

      /**
       * @name plan.compare.service.removeComparePlan
       * @memberOf plan.compare.service
       * @param {HealthPlan} plan
       */
      this.removeComparePlan = function (plan) {
        var index = this.plans.indexOf(plan);
        if (index > -1) {
          this.plans.splice(index, 1);
        }
      };

      /**
       * @name plan.compare.service.removeAllComparePlans
       * @memberOf plan.compare.service
       */
      this.removeAllComparePlans = function () {
        _.forEach(this.plans, function(plan) {
          plan.selected = false;
        });
        this.plans = [];
      };
    }
  ]);

angular.module('plan')
  .controller('plan.list.controller', [
    '$scope',
    '$state',
    '$location',
    '$timeout',
    'plan.filter.service',
    'plan.sort.service',
    'plan.compare.service',
    'plan.utils',
    'application.model',
    'plan.search',
    'logger',
    'services.tracking',
    /**
     * @name plan.plan.list.controller
     * @param {object} $scope
     * @param {ui.router.state.$state} $state
     * @param {ng.$location} $location
     * @param {ng.$timeout} $timeout
     * @param {plan.filter.service} planFilterService
     * @param {plan.sort.service} planSortService
     * @param {plan.compare.service} planCompareService
     * @param {plan.utils} planUtils
     * @param {health.app} applicationModel
     * @param {plan.search} planSearch
     * @param {logger} logger
     * @param {services.tracking} trackingService
     */
      function ($scope, $state, $location, $timeout, planFilterService, planSortService, planCompareService, planUtils, applicationModel, planSearch, logger, trackingService) {
      var trackingPrefix = 'Plan Compare: ';

      // make a copy so as not to modify global plans array
      var _plans = $scope.allPlans.slice(0);
      var initialSort = $location.search().sort;
      var defaultKeys = ['rank', 'forecast', 'premium', 'myDocs', 'networkCount'];

      // Check if plans in the compare service are still in the list of all plans
      var comparePlans = planCompareService.getPlans().slice(0);
      _.forEach(comparePlans, function (plan) {
        if (!_.contains(_plans, plan)) {
          planCompareService.removeComparePlan(plan);
        }
      });

      $scope.modes = {compare: false};
      $scope.limit = 15;
      $scope.viewModel = {};
      $scope.providerCount = applicationModel.member_providers.length;
      $scope.providers = applicationModel.member_providers;

      $scope.totalPlanCount = _plans.length;
      $scope.topRank = planUtils.getTopRank(_plans);
      $scope.getInNetCount = planUtils.getInNetCount;

      planFilterService.updateList(_plans)
        .then(function(response) {
          
        });
      $scope.$on('filters-changed', filterPlans);

      $scope.getActiveFilterKeys = function () {
        return planFilterService.getActiveFilterGroupKeys();
      };

      $scope.sortKeys = [
        'rank',
        'deductibleInd',
        'premium',
        'oopMaxInd'
      ];

      if (applicationModel.getType() === 'all') {
        $scope.sortKeys[1] = 'deductibleFam';
        $scope.sortKeys[3] = 'oopMaxFam';
      }

      $scope.viewModel.sortValue = initialSort && _.find($scope.sortKeys, function (key) {
          return key.toLowerCase().indexOf(initialSort.toLowerCase()) === 0;
        }) || $scope.sortKeys[0];

      $scope.sort = function (userSort) {
        updateShowDefault();
        var val = $scope.viewModel.sortValue;
        planSortService.sort($scope.plans, val);

        if (userSort) {
          trackingService.mixpanelEvent(trackingPrefix + 'Sort By', {'Sort By': val});
        }
      };

      $scope.resetFilters = function () {
        planFilterService.reset();
        filterPlans();
      };

      $scope.pickPlan = function (plan) {
        planUtils.trackDetailView(plan);
        $state.go('.planDetail', planUtils.getDetailParams(plan));
      };

      $scope.showMore = function () {
        $scope.limit += 10;
        setVisiblePlans();
      };

      $scope.toggleCompare = function () {
        if ($state.current.name === 'personalPlans.list.compare') {
          var numComparePlans = planCompareService.getNumComparePlans();
          if (numComparePlans === 0) {
            $scope.modes.compare = false;
            $state.go('^');
          } else {
            var isOpen = false;
            // Toggle the compare dropdown
            if ($scope.viewModel.showCompareDropdown) {
              this.closeCompareDropdown();
            } else {
              $scope.viewModel.showCompareDropdown = true;
              isOpen = true;
            }

            trackingService.mixpanelEvent(trackingPrefix + 'Compare Drawer Click', {'Open': isOpen});
          }
        } else {
          $scope.modes.compare = true;
          $state.go('.compare');
        }
      };

      $scope.comparePlans = function () {
        $state.go('.h2h', planCompareService.getCompareParams());
      };

      function setVisiblePlans() {
        $scope.visiblePlanCount = Math.min($scope.limit, $scope.plans.length);
      }

      function updateShowDefault() {
        $scope.showDefault = _.contains(defaultKeys, $scope.viewModel.sortValue);
      }

      function filterPlans() {
        $scope.plans = planFilterService.filterActive(_plans);
        setVisiblePlans();
        $scope.sort();
      }


      filterPlans();
      $scope.render = true;
    }
  ]);
angular.module('plan')
  .factory('plan.search', [
    '$q',
    'utils',
    'plan.utils',
    'search.request',
    'search.carriers',
    'plan.sort.service',
    'services.date',
    'doctor.application.service',
    'drug.service',
    'user.model',
    'search.geo',
    /**
     * @name plan.search
     * @param {ng.$q} $q
     * @param {utils} utils
     * @param {plan.utils} planUtils
     * @param {search.request} searchRequest
     * @param {search.carriers} carrierSearch
     * @param {plan.sort.service} planSortService
     * @param {services.date} dateService
     * @param {doctor.application.service} doctorApplicationService
     * @param {drug.service} drugService
     * @param {user.model} userModel
     * @param {search.geo} geoSearch
     */

      function ($q, utils, planUtils, searchRequest, carrierSearch, planSortService, dateService, doctorApplicationService,
                drugService, userModel, geoSearch) {

      var _cachedDetailsApplication;
      var _cachedRecoApplication;
      var _details;
      var _mods;
      var _recommendation;
      var _scenarios;
      var _scenariosPlanId;
      var _recoReq;
      var _scenariosReq;
      var _cachedMerged;
      var _dateParams = planUtils.getDateParams();
      var _cachedProviderIds = [];
      var _cachedDrugIds = [];

      // this is a server GET, so angular is handling caching of the request
      /**
       * @param {health.app} applicationModel
       * @param {boolean} force
       * @returns {*}
       */
      function getDetails(applicationModel, force) {

        //// don't hit the server again if we already have list from this same application
        //if (!force &&
        //  _.isArray(_details) &&
        //  planUtils.isSameDetails(_cachedDetailsApplication, applicationModel.get()) &&
        //  planUtils.isSameDateParams(_dateParams)) {
        //  return $q.when(_details);
        //}

        _cachedDetailsApplication = angular.copy(applicationModel.get());
        _dateParams = planUtils.getDateParams();

        var appMembers = applicationModel.getCoveredMembers();

        var params = planUtils.getAppParams(applicationModel, null, appMembers);
        _.extend(params, _dateParams);

        return $q
          .all([
            searchRequest.get('/plan/eligible', {params: params}),
            carrierSearch.get(applicationModel.getAddress(), params.onexchange === true || undefined)
          ])
          .then(function (responses) {
            var carriers = responses[1];
            _details = responses[0].data || [];
            _details = _.map(_details, function (detail) {
              var plan = detail.plan;
              var carrier = _.findWhere(carriers, {id: plan.carrierId});

              if (carrier) {
                extendPlanWithCarrier(plan, carrier);
              }

              plan.premiumMonth = detail.totalMonthlyPremium;
              plan.ranks = {
                deductible: detail.deductibleRank,
                premium: detail.premiumRank,
                maxOop: detail.maxOopRank
              };

              if (!plan.benefits) {
                plan.benefits = {
                  visits: {
                    ben_primary: {},
                    ben_specialist: {}
                  }
                };
              }

              if (detail.limits) {
                //plan.limits = detail.limits;
                _.extend(plan, _.omit(detail.limits, ['id', 'planId']));
              }

              return plan;
            });

            return _details;
          });
      }

      /**
       *
       * @param {health.app} applicationModel
       * @param {boolean} force
       * @returns {*}
       */
      function getRecommendation(applicationModel, force) {
        if (!force &&
          planUtils.isSameMods(applicationModel, _cachedRecoApplication) &&
          planUtils.isSameDateParams(_dateParams)
        ) {
          return _recoReq ? _recoReq.promise : $q.when({data: {data: _recommendation}});
        }

        _cachedRecoApplication = angular.copy(applicationModel);
        _recoReq = $q.defer();
        _dateParams = planUtils.getDateParams();

        return searchRequest.postApp('/plan/recommendation', applicationModel, _dateParams)
          .then(function (response) {
            _recommendation = response && response.data && response.data.data;

            if (_recoReq !== null) {
              _recoReq.resolve(_recommendation);
              _recoReq = null;
            }

            return _recommendation;
          })
          .catch(function (err) {
            _cachedRecoApplication = null;
            return $q.reject(err);
          });

      }

      /**
       *
       * @param {health.app} applicationModel
       * @param {boolean} force
       * @returns {*}
       */
      function getMods(applicationModel, force) {
        return getRecommendation(applicationModel, force)
          .then(function () {
            _mods = _recommendation && _recommendation.planMods;
            return _mods;
          });
      }

      /**
       *
       * @param plans
       */
      function attachSpecialFlags(plans) {
        if (!plans || plans.length === 0) {
          return;
        }

        // Sort plans by stride rank
        planSortService.sort(plans, 'rank');

        //Remove any existing special flags
        _.each(plans, function (plan) {
          plan.special = null;
        });

        // Recommended plan (top stride rank)
        if (plans[0]) {
          plans[0].special = 'recommended';
        }

        if (plans.length < 3) {
          return;
        }

        // Find lowest premium plan
        var lowestPremiumIndex = findLowestPremiumPlan(plans);

        // Find Similar plan
        var similarIndex = findSimilarPlan(plans);
        var nextLowestIndex;

        // If lowest is also the same as recommended, show next stride rank of the next metal tier up that's a different carrier than the similar plan
        if (lowestPremiumIndex === 0) {
          nextLowestIndex = findNextTierSimilarPlan(plans, similarIndex);
        }
        if (lowestPremiumIndex === similarIndex) {
          similarIndex = findNextTierSimilarPlan(plans, similarIndex);
        }

        if (nextLowestIndex > 0 && plans[nextLowestIndex]) {
          plans[nextLowestIndex].special = 'lowestAlternative';
        } else if (plans[lowestPremiumIndex]) {
          plans[lowestPremiumIndex].special = 'lowest';
        }

        if (plans[similarIndex]) {
          plans[similarIndex].special = 'similar';
        }
      }

      function findLowestPremiumPlan(plans) {
        var lowestPremiumIndex = 0;
        var recommendedPremium = plans[0].mods.premiumMonth;
        var lowestPremium = recommendedPremium;
        var premium = recommendedPremium;

        for (var i = 0; i < plans.length; i++) {
          premium = plans[i].mods.premiumMonth;
          if (premium < lowestPremium) {
            lowestPremiumIndex = i;
            lowestPremium = premium;
          }

          // Add inNetCount as well
          plans[i].inNetCount = plans[i].mods && plans[i].mods.providers.totalAccepted || 0;
        }

        return lowestPremiumIndex;
      }

      /**
       * Next best stride rank that's not the same carrier
       * If only 1 carrier in rating region, show first Stride Rank plan of different planType
       */
      function findSimilarPlan(plans) {
        var i = 0;
        //var similarIndex = -1;
        var carriers = planUtils.getCarriers(plans);
        var planTypes = planUtils.getNetworks(plans);

        if (carriers.length < 2) {
          if (planTypes < 2) {
            return 1;
          } else {
            for (i = 0; i < plans.length; i++) {
              if (plans[i].planType !== plans[0].planType) {
                return i;
              }
            }
          }
        } else {
          for (i = 0; i < plans.length; i++) {
            if (plans[i].carrier !== plans[0].carrier) {
              return i;
            }
          }
        }

        // If none of the scenarios are hit, similar plan is next stride rank
        return 1;
      }

      /**
       * Find next Stride Rank of the next metal tier up and different from the similar plan
       * @param plans, similarIndex
       */
      function findNextTierSimilarPlan(plans, similarIndex) {
        var tierArray = planUtils.getTierArray();
        var recommendedMetalType = plans[0].metalType;
        var currentTierIndex = _.indexOf(tierArray, recommendedMetalType);
        var nextTierIndex = currentTierIndex === 0 ? 0 : currentTierIndex - 1;

        for (var i = nextTierIndex; i >= 0; i--) {
          for (var j = 0; j < plans.length; j++) {
            if (plans[j].metalType === tierArray[i] && j !== similarIndex) {
              return j;
            }
          }
        }

        // No alternatives found. Just get the next stride rank that isn't recommended and similar
        for (var k = 1; k < plans.length; k++) {
          if (k !== similarIndex) {
            return k;
          }
        }
      }

      /**
       * @param {health.app} applicationModel
       * @param {boolean} [force=false]
       * @param {number} [planYear]
       * @param {date} [buyDate]
       * @param {DateOnly} [effectiveDate]
       * @returns {Promise<HealthPlan[]>}
       */
      function getMerged(applicationModel, force, planYear, buyDate, effectiveDate) {

        if (_.isNumber(planYear) && _.isDate(buyDate)) {
          planUtils.setDateParams(buyDate, planYear);
        }

        // make sure the ages of the members are always based on effective date before making requests
        return applicationModel.setEffectiveAges(effectiveDate)
          .then(function(){
            return getDetails(applicationModel, force);
          })
          .then(function () {
            return getMods(applicationModel, force);
          })
          .then(doMerge)
          .then(function (plans) {
            _cachedMerged = plans;
            var myPlan = applicationModel.getPlan();
            // update current application plan info if it is still there
            if (!_.isEmpty(myPlan)) {
              var match = _.findWhere(plans, {id: myPlan.id});
              if (match) {
                applicationModel.get().plan = match;
              }
              else {
                applicationModel.get().plan = null;
              }
            }

            attachSpecialFlags(plans);

            // Return sorted plans
            return plans;
          });
      }

      function doMerge() {
        _.each(_details || [], function (detail) {
          detail.mods = _.findWhere(_mods || [], {planId: detail.id});
        });

        var matches = _.reject(_details, function(detail){ return _.isUndefined(detail.mods); });

        if (matches.length !== _details.length){
          console.log('No mods for plans ', _.difference(_details, matches));
        }

        return matches;
      }

      function checkPremiumChange(applicationModel) {
        var application = applicationModel.get();
        var plan = application.plan;
        var premiumMonthKey = 'premiumMonth';

        return getMerged(applicationModel)
          .then(function (plans) {
            var newPlan = _.findWhere(plans, {id: plan.id});

            return {
              changed: !newPlan || plan[premiumMonthKey] !== newPlan[premiumMonthKey],
              newPlan: newPlan,
              newPrice: newPlan && newPlan[premiumMonthKey] && newPlan[premiumMonthKey].toFixed(2) || -1,
              oldPrice: plan[premiumMonthKey].toFixed(2),
              planCount: plans.length
            };
          });
      }

      /**
       * @name plan.search.getScenarios
       * @methodOf plan.search
       * @param {HealthPlan} plan
       * @param {health.app} applicationModel
       * @returns {HttpPromise<HealthPlanScenario[]>}
       */
      function getScenarios(plan, applicationModel) {

        if (plan.id === _scenariosPlanId && planUtils.isSameMods(applicationModel, _cachedRecoApplication)) {
          return _scenariosReq ? _scenariosReq.promise : $q.when(_scenarios);
        }

        _scenariosPlanId = plan.id;
        _scenariosReq = $q.defer();

        return searchRequest.postApp('/plan/' + _scenariosPlanId + '/scenarios', applicationModel)
          .then(function (response) {
            var primaryScenarios = response && response.data && response.data[applicationModel.members[0].id];

            _scenarios = primaryScenarios &&
              _.map(_.keys(primaryScenarios), function (key) {
                return {
                  key: key,
                  insured: primaryScenarios[key].insured,
                  uninsured: primaryScenarios[key].uninsured
                };
              }) || [];

            if (_scenariosReq !== null) {
              _scenariosReq.resolve(_scenarios);
              _scenariosReq = null;
            }

            return _scenarios;
          });
      }

      /**
       * @name plan.search.getForCarrier
       * @methodOf plan.search
       * @param {Carrier} carrier
       * @returns {*}
       */
      function getForCarrier(carrier) {
        return searchRequest.get('/plan?carrierId=' + carrier.id)
          .then(utils.dataOrArray)
          .catch(function () {
            return [];
          });
      }

      function extendPlanWithCarrier(plan, carrier) {
        plan.carrier = carrier.name;
        plan.phone = carrier.phone;
        plan.address = carrier.address;
        plan.urlSite = carrier.url;
      }

      return {
        getDetails: getDetails,
        getMods: getMods,
        getMerged: getMerged,
        getRecommendation: getRecommendation,
        checkPremiumChange: checkPremiumChange,
        attachSpecialFlags: attachSpecialFlags,
        getMergedCached: function () {
          return _cachedMerged || [];
        },
        getScenarios: getScenarios,
        getForCarrier: getForCarrier,
        attachCarrier: extendPlanWithCarrier,

        /**
         * @name plan.search.getById
         * @methodOf plan.search
         * @param {number} id
         * @param {boolean} [fullDetails=false]
         */
        getById: function (id, fullDetails) {
          return searchRequest.get('/plan/' + id, {
              params: {
                detailed: fullDetails
              }
            })
            .then(utils.dataOrObject);
        },

        ///**
        // * @typedef {Object} plan.enrollmentData
        // * @property {EnrollmentPeriod} period
        // * @property {{ effectiveDate: string, periodType: string }} data
        // */

        ///**
        // * @name plan.search.getEnrollment
        // * @methodOf plan.search
        // * @param {health.app} applicationModel
        // * @returns {Promise<plan.enrollmentData>}
        // */
        //getEnrollment: function(applicationModel){
        //  var params = _.extend(planUtils.getAppParams(applicationModel.get()), planUtils.getDateParams());
        //  return searchRequest.get('/plan/eligible', {params: params})
        //    .then(utils.dataOrArray)
        //    .then(function(details){
        //      var planId = (applicationModel.getPlan() || {}).id;
        //
        //      var detail = _.find(details, function(d){
        //        return d.plan && d.plan.id === planId;
        //      });
        //
        //      if (!detail){
        //        detail = details[0];
        //      }
        //
        //      var enrollment = detail.enrollment || {};
        //
        //      return $q.all([
        //        enrollment,
        //        dateService.getEnrollmentPeriod({
        //          onExchange: applicationModel.hasSubsidy(),
        //          state: applicationModel.getState(),
        //          effectiveDate: enrollment.effectiveDate
        //        })
        //      ]);
        //    })
        //    .then(function(responses){
        //      return {
        //        data: responses[0],
        //        period: responses[1]
        //      };
        //    })
        //},
        ///**
        // * @name plan.search.checkEligibility
        // * @methodOf plan.search
        // * @param {health.app} applicationModel
        // * @param {Date} buyDate
        // * @param {number} year
        // * @returns {Promise.<Boolean>}
        // */
        //checkEligibility: function (applicationModel, buyDate, year) {
        //  var params = planUtils.getAppParams(applicationModel);
        //  params.buyDate = dateService.toIsoDate(buyDate);
        //  params.year = year;
        //
        //  return searchRequest.get('/plan/eligible', {params: params})
        //    .then(function (res) {
        //      return res && _.isArray(res.data) && res.data.length > 0;
        //    })
        //    .catch(function (err) {
        //      return false;
        //    });
        //},

        /**
         * @name plan.search.trackQuote
         * @methodOf plan.search
         * @param {health.app} applicationModel
         * @param {string} effectiveDate
         * @returns {HttpPromise<{ status: string }>}
         */
        trackQuote: function (applicationModel, effectiveDate) {
          var address = geoSearch.fromAddress(applicationModel.getAddress());
          var location = _.pick(address, ['county', 'city', 'region', 'cityCounty']);
          location.state = address.stateCode;
          location.zip = address.zipcode;

          return searchRequest.post('/tracking/quote', {
            effectiveDate: effectiveDate,
            onExchange: applicationModel.hasSubsidy(),
            location: location,
            members: _.map(applicationModel.getCoveredMembers(), function (member) {
              var applicant = _.pick(member, ['age', 'gender', 'type']);
              applicant.uuid = member.id;
              applicant.tobacco = member.tobacco === true;

              return applicant;
            })
          }, {
            transformResponse: function (d) {
              return {status: d};
            }
          });
        }
      };
    }
  ]);
angular.module('plan')
  .service('plan.sort.service', [
    'config.metalTiers',

    /**
     * @name plan.sort.service
     * @param {config.metalTiers} planMetals
     */

    function(planMetals){

      var sortFns = {
        forecast: function(a, b){
          return a.mods.oop.totalOop - b.mods.oop.totalOop || tieBreak(a, b);
        },
        deductibleInd: function(a, b){
          return a.deductibleInd - b.deductibleInd || tieBreak(a, b);
        },
        deductibleFam: function(a, b){
          return a.deductibleFam - b.deductibleFam || tieBreak(a, b);
        },
        networkCount: function(a, b){
          return b.mods.providers.qtyNearby - a.mods.providers.qtyNearby || tieBreak(a, b);
        },
        networkQuality: function(a, b){
          // TODO: fix this when plans come back w/ quality score
          return b.network.qualscore - a.network.qualscore || tieBreak(a, b);
        },
        oopMaxInd: function(a, b){
          return a.oopmaxInd - b.oopmaxInd || tieBreak(a, b);
        },
        oopMaxFam: function(a, b){
          return a.oopmaxFam - b.oopmaxFam || tieBreak(a, b);
        },
        metalType: function(a, b){
          return planMetals[a.metalType] - planMetals[b.metalType] || tieBreak(a, b);
        },
        premium: function(a, b){
          return a.mods.premiumYear - b.mods.premiumYear || tieBreak(a, b);
        },
        myDocs: function(a, b){
          return b.mods.providers.totalAccepted - a.mods.providers.totalAccepted || tieBreak(a, b);
        }
      };

      this.sort = function(list, sortOn){
        list.sort(_.isFunction(sortFns[sortOn]) ? sortFns[sortOn] : tieBreak);
      };

      function tieBreak(a, b){
        if (!a || !a.mods){
          return 1;
        }
        if (!b || !b.mods){
          return -1;
        }

        return a.mods.ranks.strideRank - b.mods.ranks.strideRank;
      }
    }
  ]);
angular.module('plan')
  .factory('plan.stats', [
    '$q',
    'utils',
    'search.request',
    'plan.utils',
    'services.subsidy',
    function ($q, utils, searchRequest, planUtils, subsidyService) {


      /**
       *
       * @param {Geo} location
       * @param {string} demos
       * @param {boolean} [onExchange]
       * @returns {*}
       */
      function getStats(location, demos, onExchange) {
        var params = {
          state: location.stateCode,
          region: location.region,
          countyFips: location.countyFips,
          demos: demos || 27, // TODO: add tobacco in here
          onexchange: !!onExchange
        };

        return getStatsWithParams(params);
      }

      /**
       *
       * @param params
       * @returns {*}
       */
      function getStatsWithParams(params) {
        var dateParams = planUtils.getDateParams();
        return searchRequest.get('/plan/stats', {params: _.extend(dateParams, params)})
          .then(utils.dataOrObject);
        //.then(function(res){
        //  // try falling back to 2015 data if there isn't any for 2016
        //  if (!res.planCount && dateParams.year === 2016 && planUtils.trySepDates()){
        //    return getStatsWithParams(params);
        //  }
        //
        //  return res;
        //});
      }


      /**
       *
       * @param applicationModel
       * @param errHigh
       * @param updatedApplicants
       * @returns {*}
       */
      function getAppStats(applicationModel, errHigh, updatedApplicants) {
        var params = planUtils.getAppParams(applicationModel, errHigh, updatedApplicants);
        return getStatsWithParams(params);
      }


      /**
       *
       * @param applicationModel
       * @param updatedApplicants
       * @returns {*}
       */
      function getAppStatsRange(applicationModel, updatedApplicants) {
        return $q.all([getAppStats(applicationModel, null, updatedApplicants), getAppStats(applicationModel, true, updatedApplicants)])
          .then(function (responses) {
            var min = responses[0], max = responses[1];
            return {
              minCost: min.minCost,
              maxCost: max.maxCost,
              medianCost: (min.medianCost + max.medianCost) / 2
            };
          });
      }

      /**
       * @name plan.utils.getCoveredMembersEstimate
       * @methodOf plan.utils
       * @param {number} income
       * @param {number} familySize
       * @param {health.app} applicationModel
       * @param {Member[]} appMembers
       * @returns {{ oldEstimate: SubsidyEstimate, newEstimate: SubsidyEstimate, oldMemberEligibility: SubsidyApplicantEligibilities, newMemberEligibility: SubsidyApplicantEligibilities, oldMemberStatuses: CoveredMemberStatus[], newMemberStatuses: CoveredMemberStatus[] }}
       */
       function getCoveredMembersEstimate(income, familySize, applicationModel, appMembers) {
        // Data object to return
        var membersSubsidyInfo = {
          oldEstimate: null,
          newEstimate: null,
          oldMemberEligibility: {},
          newMemberEligibility: {},
          oldMemberStatuses: [],
          newMemberStatuses: []
        };

        // Get eligibilities for all app members
        return getBenchmark(applicationModel, appMembers)
          .then(function (premium) {
            var benchmarkPremium = premium * 12 || 0;
            return subsidyService.getEstimate(applicationModel.getState(), income, familySize, planUtils.getApplicantParams(appMembers), benchmarkPremium);
          })
          .then(function (data) {
            var estimate = data.estimate;
            var eligibilities = data.eligibilities;
            var applicantEligibility = subsidyService.checkApplicants(eligibilities, estimate, appMembers);

            _.each(appMembers, function (member, index) {
              membersSubsidyInfo.oldMemberStatuses.push({
                member: member,
                eligibility: eligibilities[index]
              });
            });

            // set new* properties also so consumers don't have to check if it exists and fall back to old
            // these new* properties will get overwritten with new values if the second estimate call is needed
            membersSubsidyInfo.oldMemberEligibility = membersSubsidyInfo.newMemberEligibility = applicantEligibility;
            membersSubsidyInfo.oldEstimate = membersSubsidyInfo.newEstimate = estimate;
            membersSubsidyInfo.newMemberStatuses = membersSubsidyInfo.oldMemberStatuses.slice(0);

            // Calculate new subsidy amount with only eligible members and not medicaid members
            if (!applicantEligibility.subsidyMembers.length || applicantEligibility.subsidyMembers.length === appMembers.length) {
              applicationModel.setSubsidy(estimate.aptc, estimate.csr);
              return membersSubsidyInfo;
            }

            //Get new benchmark premium for subsidized members
            return getBenchmark(applicationModel, applicantEligibility.subsidyMembers)
              .then(function (premium) {
                var benchmarkPremium = premium * 12 || 0;

                // Get updated subsidy estimate
                return subsidyService.getEstimate(applicationModel.getState(), income, familySize,
                  planUtils.getApplicantParams(applicantEligibility.subsidyMembers), benchmarkPremium);
              })
              .then(function (data) {
                var newEstimate = data.estimate;
                var newEligibilities = data.eligibilities;
                membersSubsidyInfo.newMemberEligibility = subsidyService.checkApplicants(newEligibilities, newEstimate, applicantEligibility.subsidyMembers);
                membersSubsidyInfo.newEstimate = newEstimate;

                _.each(applicantEligibility.subsidyMembers, function (member, index) {
                  membersSubsidyInfo.newMemberStatuses.push({
                    member: member,
                    eligibility: newEligibilities[index]
                  });
                });
                applicationModel.setSubsidy(newEstimate.aptc, newEstimate.csr);
                return membersSubsidyInfo;
              });

          });
      }


      /**
       *
       * @param applicationModel
       * @param updatedApplicants
       * @returns {*}
       */
      function getBenchmark(applicationModel, updatedApplicants) {
        var params = updatedApplicants ? planUtils.getAppParams(applicationModel, null, updatedApplicants) : planUtils.getAppParams(applicationModel);
        params.onexchange = true;
        //var address = applicationModel.getAddress();
        //
        //var params = {
        //  state: address.state,
        //  region: address.region,
        //  demos: _.map(applicationModel.getApplicants(), function(member){
        //    return member.age || 27;
        //  }).join(','),
        //  onexchange: true
        //};

        return searchRequest.get('/plan/benchmark', {params: _.extend(planUtils.getDateParams(), params)})
          .then(function (response) {
            return response && response.data && response.data.totalMonthlyPremium;
          });
      }

      return {
        get: getStats,
        getForApp: getAppStats,
        getRangeForApp: getAppStatsRange,
        getCoveredMembersEstimate: getCoveredMembersEstimate,
        getBenchmark: getBenchmark
      };
    }
  ]);
angular.module('plan')
  .factory('plan.utils', [
    'utils',
    'config',
    'services.date',
    'services.tracking',
    /**
     * @name plan.utils
     * @param {utils} utils
     * @param {config} config
     * @param {services.date} dateService
     * @param {services.tracking} trackingService
     */
    function(utils, config, dateService, trackingService){
      var toDash = utils.toDash;
      var isEqual = angular.equals;
      var metalTiers = config.metalTiers;
      var ages = config.ages;
      var _buyDate;
      var _planYear;

      setOepDate();

      return {
        find: find,
        getDetailParams: getDetailParams,
        getByDetails: getByDetails,
        isSameDetails: isSameDetails,
        isSameMods: isSameMods,
        getInNetCount: getInNetCount,
        getAppParams: getAppParams,
        getAddressParams: getAddressParams,
        getApplicantParams: getMemberParams,
        setOepDate: setOepDate,

        /**
         * @typedef {object} plan.utils.dateParams
         * @property {string} buyDate ISO format local date 2015-11-01
         * @property {number} year
         */

        /**
         * @name plan.utils.getDateParams
         * @methodOf plan.utils
         * @returns {plan.utils.dateParams}
         */
        getDateParams: function(){
          return {
            buyDate: dateService.toIsoDate(_buyDate),
            year: _planYear
          };
        },

        /**
         * @name plan.utils.setDateParams
         * @methodOf plan.utils
         * @param {Date} buyDate
         * @param {number} planYear
         */
        setDateParams: function(buyDate, planYear){
          _buyDate = buyDate;
          _planYear = planYear;
        },

        ///**
        // * @name plan.utils.trySepDates
        // * @methodOf plan.utils
        // * @returns {boolean}
        // */
        //trySepDates: function(){
        //  if (!dateService.isAfterSepCutoff(new Date())){
        //    _buyDate = new Date();
        //    _planYear = 2015;
        //    return true;
        //  }
        //
        //  return false;
        //},

        ///**
        // * @name plan.utils.getOepBuyDate
        // * @methodOf plan.utils
        // * @returns {Date}
        // */
        //getOepBuyDate: function(){
        //  var now = new Date();
        //  var oep = new Date(2015, 10, 1);
        //  return now.getTime() > oep.getTime() ? now : oep;
        //},
        //
        /**
         * @name plan.utils.isSameDateParams
         * @methodOf plan.utils
         * @param {plan.utils.dateParams} dateParams
         * @returns {boolean}
         */
        isSameDateParams: function(dateParams){
          if (!_.isObject(dateParams)) {
            return false;
          }

          var buyDate = dateParams.buyDate;
          if (_.isDate(buyDate)){
            buyDate = dateService.toIsoDate(buyDate);
          }

          return _planYear === dateParams.year && buyDate === dateService.toIsoDate(_buyDate);
        },

        getCarriers: function(plans){
          /**
           * @type {Array<{ name: string, ids: number[] }>}
           */
          var carriers = [];
          _.each(plans, function(plan){
            var existing = _.findWhere(carriers, { name: plan.carrier });

            if (!existing){
              existing = { name: plan.carrier, ids: [] };
              carriers.push(existing);
            }

            if (!_.isArray(existing.ids)){
              existing.ids = [];
            }

            if (!_.contains(existing.ids, plan.carrierId)) {
              existing.ids.push(plan.carrierId);
            }
          });

          return carriers;
        },

        getNetworks: function(plans){
          return _.unique(_.pluck(plans, 'planType'));
        },

        getTiers: function(plans){
          return _.unique(_.pluck(plans, 'metalType')).sort(function(a, b){
            return metalTiers[a] - metalTiers[b];
          });
        },

        getTierArray: function() {
          return _.keys(metalTiers);
        },

        getTopRank: getTopRank,
        getTopPlan: function(plans){
          var topRank = getTopRank(plans);

          return _.find(plans, function(plan){
            return plan && plan.mods && plan.mods.ranks.strideRank === topRank;
          });
        },

        getSimilarPlan: function(plans) {
          return _.find(plans, function(plan){
            return plan && plan.special && plan.special === 'similar';
          });
        },

        getLowestPlan: function(plans) {
          return _.find(plans, function(plan){
            return plan && plan.special && (plan.special === 'lowest' || plan.special === 'lowestAlternative');
          });
        },

        allDocsAccepted: function(plan){
          return getInNetCount(plan) === getTotalProvidersCount(plan);
        },

        getMaxOopStats: function(plan, plans){
          var stats = {
            higher: 0,
            lower: 0,
            equal: 0
          };
          var oopKey = 'oopmaxInd';
          var oop = plan[oopKey];

          _.each(plans, function(p){
            if (plan === p) {
              return;
            }

            var _oop = p[oopKey];

            if (oop === _oop) {
              stats.equal++;
            }
            else if (oop > _oop) {
              stats.lower++;
            }
            else if (oop < _oop) {
              stats.higher++;
            }
          });

          return stats;
        },

        getNetworkCountRank: function(plan, plans){
          // can't just do a sort since there are probably going to be a bunch of plans tied with this one
          // instead, if you look to see how many are lower, you can figure out the index at the start of the ranking tier
          var qty = plan.mods.providers.qtyNearby;
          return _.filter(plans, function(p){
            return qty < p.mods.providers.qtyNearby;
          }).length + 1;
        },

        /**
         * @name plan.utils.trackDetailView
         * @methodOf plan.utils
         * @param {HealthPlan} plan
         */
        trackDetailView: function(plan){
          trackingService.mixpanel.people.increment('Plans Compared', 1);
          trackingService.mixpanelEvent('Plan Compare: View Plan', {
            'Plan Name': plan.carrier + ' ' + plan.name,
            'Stride Rank': plan.mods && plan.mods.ranks.strideRank || -1,
            'Subsidy Savings': plan.mods && plan.mods.savings.subsidy.toFixed(2) || -1,
            'Plan Flag': plan.special || ''
          });
        }
      };

      function getTotalProvidersCount(plan){
        var providers = plan.mods.providers;
        return providers && _.isArray(providers.providersAccepted) && providers.providersAccepted.length || 0;
      }

      function getInNetCount(plan){
        var providers = plan.mods.providers;
        return providers && providers.totalAccepted || 0;
      }

      function getTopRank(plans){
        var ranks = _.map(plans, function(plan){
          if (plan && plan.mods && angular.isDefined(plan.mods.planId)){
            return plan.mods.ranks.strideRank;
          }

          return Number.MAX_VALUE;
        });

        return _.min(ranks);
      }

      function find(plans, carrier, type, name){
        return _.find(plans, function(plan){
          return toDash(plan.carrier) === toDash(carrier) &&
            toDash(plan.planType) === toDash(type) &&
            toDash(plan.name) === toDash(name);
        });
      }

      function getAppParams(applicationModel, errHigh, updatedApplicants){
        var address = applicationModel.getAddress();
        var applicants = _.isArray(updatedApplicants) && updatedApplicants.length ? updatedApplicants : applicationModel.getCoveredMembers();
        var params = getAddressParams(address);
        var demos = getMemberParams(applicants, errHigh);
        var subsidy = applicationModel.data.subsidy;

        params.demos = demos || 'p27f';
        params.onexchange = subsidy && subsidy.amount > 0 || 'cross';

        if (params.onexchange === true && _.isNumber(subsidy.csr) && subsidy.csr > 0){
          params.csr = subsidy.csr;
        }

        return params;
      }

      /**
       * @name plan.utils.getAddressParams
       * @methodOf plan.utils
       * @param {Address} address
       * @returns {{ state: string, region: string|number, countyFips: string }}
       */
      function getAddressParams(address){
        return {
          state: address.state,
          region: address.region,
          countyFips: address.county_fips
        };
      }

      /**
       * @name plan.utils.getMemberParams
       * @methodOf plan.utils
       * @param {Member[]} members
       * @param {boolean} [errHigh=false]
       * @returns {string}
       */
      function getMemberParams(members, errHigh){
        if (!_.isArray(members) || !members.length){
          return '';
        }

        return _.map(members, function(member){
          var age = member.age;
          var memberType = member.type || 'dependent';
          var tobacco = member.tobacco ? 't' : 'f';
          var type = memberType.charAt(0);

          if (type === 'd') {
            type = '';
          }

          if (!_.isNumber(age)){
            age = ages[memberType][errHigh ? 1 : 0];
          }

          return type + age + tobacco;
        }).join(',');
      }

      // if the addresses are the same, subsidy is the same, and each applicant's age and tobacco is the same, the details will be the same
      function isSameDetails(app1, app2){
        return app1 && app2 &&
          _.isObject(app1.address) && _.isObject(app2.address) &&
          app1.address.region === app2.address.region &&
          app1.address.state === app2.address.state &&
          app1.address.county_fips === app2.address.county_fips &&
          isEqual(app1.data.subsidy, app2.data.subsidy) &&
          app1.members.length === app2.members.length &&
          _.every(app2.members, function(member){
            var match = _.findWhere(app1.members, { id: member.id });

            return match &&
              match.age === member.age &&
              match.tobacco === member.tobacco;
          });
      }
      
      function isSameMods(app1, app2){
        return isSameDetails(app1, app2) &&
          isEqual(app1.member_drugs, app2.member_drugs) &&
          isEqual(app1.member_providers, app2.member_providers) &&
          isEqual(app1.getIllnesses(), app2.getIllnesses());
      }

      function getByDetails(plans, carrier, type, name){
        return _.find(plans, function(plan){
          return utils.toDash(plan.carrier) === utils.toDash(carrier) &&
            utils.toDash(plan.planType) === utils.toDash(type) &&
            utils.toDash(plan.name) === utils.toDash(name);
        });
      }

      function getDetailParams(plan) {
        return {
          id: plan.id
        };

        //return {
        //  state: plan.state.substr(0, 2).toUpperCase(),
        //  carrier: toDash(plan.carrier),
        //  type: toDash(plan.planType),
        //  name: toDash(plan.name)
        //};
      }

      /**
       * @name plan.utils.setOepDate
       * @methodOf plan.utils
       */
      function setOepDate(){
        // default to 2016 plan preview
        _planYear = 2016;
        _buyDate = new Date();
      }
    }

  ]);
angular.module('plan')
  .directive('shStopLight', [
    'utils',
    function(utils){
      return {
        restrict: 'A',
        link: function($scope, $element, $attr){
          // assume plan is in the scope already
          if (!$scope.plan) return;
          var className;
          var rank = utils.traverse($scope.plan, $attr.key);

          if ($attr.key == 'metal'){
            switch ($scope.plan.metalType.toLowerCase()){
              case 'platinum':
              case 'gold':
                rank = 1;
                break;
              case 'silver':
              case 'bronze':
                rank = 2;
                break;
              default:
                rank = 3;
            }
          }
          else {
            rank = utils.traverse($scope.plan, $attr.key);
          }


          if      (rank == 1) className = 'green';
          else if (rank == 2) className = 'yellow';
          else if (rank == 3) className = 'red';

          if (className){
            $element.addClass('stop-light ' + className);
          }
        }
      }
    }

  ]);
angular.module('profile', ['config', 'search', 'application', 'user', 'plan', 'doctor', 'common.services', 'partner', 'cart', 'income', 'member']);
angular.module('profile')
  .factory('profile.details.form', [
    '$q',
    'application.model',
    'plan.utils',
    function($q, applicationModel, planUtils){

      return {
        setup: function($scope){
          if (!_.isFunction($scope.onChange)){
            $scope.onChange = function(){ return true; };
          }

          if (!_.isFunction($scope.onNoChange)){
            $scope.onNoChange = function(){ return true; };
          }

          var cachedApp = angular.copy(applicationModel);

          $scope.lock = false;

          $scope.submit = function (form) {
            if ($scope.lock) {
              return;
            }

            if (!form.$valid) {
              return $scope.$broadcast('submit-error');
            }

            $scope.lock = true;

            // quick check to see if any details changed
            // if not, the premium shouldn't be different
            if (planUtils.isSameDetails(applicationModel, cachedApp)){
              return $q.when($scope.onNoChange())
                .then(done);
            }

            return $q.when($scope.onChange())
              .then(done);
          };

          $scope.onSubmitError = function () {
            $scope.$broadcast('submit-error');
          };

          function done(success){
            $scope.serverError = !success;
            $scope.lock = false;
            return success;
          }
        }
      };

    }
  ]);
//angular.module('provider', ['ui.router', 'config', 'common']);
/**
 * @namespace questions
 */
angular.module('questions', ['application', 'common']);
angular.module('questions')
  .controller('questions.question.controller', [
    '$scope',
    '$state',
    '$stateParams',
    'utils',
    'application.model',
    'question.model',
    'baseModel', // passed in via resolve
    'questions', // passed in via resolve
    'applicants', // passed in via resolve
    function($scope, $state, $stateParams, utils, applicationModel, questionModel, baseModel, allQuestions, applicants){
      var stateData         = $state.current.data;
      var baseState         = $state.current.name;
      var history           = _.map($stateParams.steps.split(','), function(index){ return parseInt(index, 10); });
      var plan              = applicationModel.getPlan();

      // if there aren't any questions, go to completed state
      if (!allQuestions.length){
        return done();
      }

      // need to find the model to operate on
      // and the current question
      var result = questionModel.get(baseModel, allQuestions, applicants, history, true);
      var url = result.url;
      var model = result.model;
      var question = result.question;

      if (!question) {
        return $state.replace('404');
      }
      if (url.join(',') != $stateParams.steps){
        return reroute();
      }

      var key = question.key;

      $scope.question = question;
      $scope.model = model;
      $scope.tokens = stateData.tokens || {};
      $scope.tokens.applicantName = result.applicantName;
      $scope.tokens.previousAnswer = result.prevAnswer;

      var year = (new Date()).getFullYear();
      $scope.dateRange = [new Date(year - 10, 0, 1), new Date(year + 10, 11, 31)];

      if (plan){
        $scope.tokens.carrierName = plan.carrier;
        $scope.tokens.planName = plan.name;
      }

      // todo: move this to the service getters after fixing that loop junk
      if (question.type == 'form' && question.key){
        $scope.model = model[question.key] = model[question.key] || {};
      }
      else if (question.type === 'applicants' && question.applicants.length === 1){
        question.applicants[0][question.key] = applicants[0][question.key] = true;
      }

      $scope.select = function(answer){
        // wipe out other data if it's set as terminal
        if (answer.terminal){
          model[key] = { value: answer.value };
        }
        else {
          model[key].value = answer.value;
          if (answer.questions){
            url.push(1);
            return reroute();
          }
        }

        next();
      };

      $scope.toggle = function(option){
        option.value = !option.value;
        model[key][option.key] = _.omit(option, ['questions', 'key', 'text', 'name', 'id', '$$hashKey']);
      };

      $scope.toggleApplicant = function(applicant){
        applicant[question.key] = !applicant[question.key];
      };

      $scope.isValid = function(){
        if (!question.required) return true;
        var selected = questionModel.getSelected(model, question);
        return selected && selected.length;
      };

      $scope.subQuestion = goToFirstSubQuestion;

      function reroute(){
        $state.go(baseState, { steps: url.join(',') });
      }

      function goToFirstSubQuestion(){
        url.push(1, 1);

        var attempt = questionModel.get(baseModel, allQuestions, applicants, url);
        if (attempt.success){
          return reroute();
        }
        // no sub question, so take off the end 0 and go to next question

        url.pop();
        next();
      }

      function next(){
        $scope.$emit('question-done', { question: question, model: model });
        // loop back up through the url chain to find the next question
        while (url.length){
          // try incrementing the last segment
          url[url.length - 1]++;
          var attempt = questionModel.get(baseModel, allQuestions, applicants, url);
          // and see if there's a question at this new url and the urls match
          if (attempt.success){

            // if this question has sub questions, go to the first one
            if (
              attempt.question.questions &&
              (attempt.question.type == 'applicants' || attempt.question.type == 'multiOption')){

              attempt.url.push(1);

              var nextAttempt = questionModel.get(baseModel, allQuestions, applicants, attempt.url);

              if (nextAttempt.success){
                url = attempt.url;
                return reroute();
              }
            }
            else {
              return reroute();
            }


          }
          // if there's no question, chop off the end of the url to check if the parent question has any other questions
          url.pop();
        }

        // looping failed to find a suitable question, so we're totally done
        done();
      }
      
      function done(){
        $scope.$emit('questions-done');
        if (stateData.completedState){
          $state.go(stateData.completedState);  
        }
      }

    }
  ]);
angular.module('questions')
  .factory('question.model', [
    'questions.applicants',
    'questions.multi',
    'questions.option',
    function(applicantsModel, multiModel, optionModel){
      
      var getters = {
        option: optionModel,
        multiOption: multiModel,
        applicants: applicantsModel
//        form: function(model, question){
//          return question.key ? model[question.key] || model;
//        }
      };

      var setters = {
        option: optionModel.set,
        multiOption: multiModel.set,
        applicants: applicantsModel.set,
        // forms fields can act directly on the model if there is no key set on the question
        form: function(model, question){
          if (question.key){
            model[question.key] = model[question.key] || {};
          }

        }
      };
      
      return {
        getSelected: function(model, question){
          var getter = getters[type];
          return getter && getter.getSelected && getter.getSelected(model, question) || [];
        },
        // TODO: UGH make this not shitty?
        get: function(baseModel, questions, applicants, history, doSet){

          var url = [];
          var currentQuestions = questions;
          var currentHistory = angular.copy(history);
          var currentModel = baseModel;
          var currentQuestion;
          var questionNumber;
          var prevAnswer;
          var applicantName;


          (function loop(){

            // if there's no more steps we're done
            if (currentHistory.length){
              questionNumber = currentHistory.shift();
              currentQuestion = currentQuestions[questionNumber - 1];

              if (!currentQuestion) return;

              url.push(questionNumber);

              // if it's a question that can't have sub-questions, or there's no more questions, also done
              if (currentHistory.length && getters[currentQuestion.type]) {
                var newModel;
                // if there's more questions in the history
                // and the type can have multiple selections
                var multipleSelections = currentHistory.length && (currentQuestion.type == 'applicants' || currentQuestion.type == 'multiOption');
                var modelNumber = questionNumber;

                if (multipleSelections){
                  // advance the history to find the current selection
                  modelNumber = currentHistory.shift();
                }

                newModel = getters[currentQuestion.type].getModel(currentModel, currentQuestion, modelNumber - 1);

                if (newModel){
                  // get the label and next question before setting the current model to the new one
                  currentQuestions = getters[currentQuestion.type].getQuestions(currentModel, currentQuestion, modelNumber - 1);
                  prevAnswer = getters[currentQuestion.type].getLabel(currentModel, currentQuestion, modelNumber - 1);

                  if (currentQuestion.type == 'applicants'){
                    applicantName = prevAnswer;  
                  }
                  
                  
                  currentModel = newModel;

                  // if there's another question, go through this again and don't let it fall through to set
                  if (currentQuestions && currentQuestions.length){
                    // add the extra history state for selection index onto the url
                    if (multipleSelections) {
                      url.push(modelNumber);
                    }

                    return loop();
                  }
                }
              }

              // getting the next model failed, so this is the correct model we're on
              // make sure it's there if set is enabled
              if (doSet && currentQuestion && setters[currentQuestion.type]){
                setters[currentQuestion.type](currentModel, currentQuestion, applicants)
              }
            }

          }());

          return {
            model: currentModel,
            prevAnswer: prevAnswer,
            question: currentQuestion,
            applicantName: applicantName,
            url: url,
            success: angular.equals(history, url) && !!currentQuestion && !!currentModel
          }
        }
      }

    }

    
    
  ])

  .factory('questions.applicants', [
    function(){

      function getModel(model, question, index){
        return model.applicants && getSelected(model.applicants, question.key)[index];
      }

      function getSelected(applicants, key){
        return _.filter(applicants, function(applicant){
          return applicant[key]
        });
      }
      
      return {
        getModel: getModel,
        getSelected: function(model, question){
          return model.applicants && getSelected(model, question.key) || [];
        },
        getLabel: function(model, question, index){
          var selected = getModel(model, question, index);
          return selected && selected.value;
        },
        getQuestions: function(model, question){
          return question.questions;
        },
        set: function(model, question, applicants){
          var key = question.key;
          // create the list based on current applicants and any saved state
          question.applicants = _.map(applicants, function(applicant){
            var savedApplicant = _.findWhere(model.applicants, { id: applicant.id });
            var qApplicant;

            if (savedApplicant){
              qApplicant = angular.copy(savedApplicant);
            }
            else {
              qApplicant = {
                uuid: applicant.id,
                value: applicant.first_name + ' ' + applicant.last_name,
                dob: applicant.dob
              };

              qApplicant[key] = false;
            }

            return qApplicant;
          });

          // curate the saved list to reflect the current applicants
          model.applicants = question.applicants;
        }
      }
      
    }
  ])

  .factory('questions.multi', [
    function(){

      function getModel(model, question, index){
        var currentKey = getSelectedKeys(model, question)[index];
        return currentKey && model[question.key][currentKey];
      }

      function getSelectedKeys(model, question){
        var keys = _.pluck(question.options, 'key');
        
        return _.filter(keys, function(key){
          return model[question.key][key] && model[question.key][key].value;
        });
      }
      
      function getCurrentOption(model, question, index){
        var currentKey = getSelectedKeys(model, question)[index];
        return _.findWhere(question.options, { key: currentKey });
      }

      return {
        getModel: getModel,
        getOption: getCurrentOption,
        getSelected: function(model, question){
          return _.map(getSelectedKeys(model, question), function(key){
            return model[key];
          })
        },
        getLabel: function(model, question, index){
          var option = getCurrentOption(model, question, index);
          return option && option.text;
        },
        getQuestions: function(model, question, index){
          var currentOption = getCurrentOption(model, question, index);
          return currentOption && currentOption.questions;
        },
        set: function(model, question){
          var key = question.key;
          model[key] = model[key] || {};
          
          _.each(question.options, function(option){
            var modelAnswer = model[key][option.key];
            if (!modelAnswer){
              modelAnswer = model[key][option.key] = {
                value: false
              };
            }

            // make sure the value is boolean
            option.value = !!modelAnswer.value;
            // and extend any saved sub-data
            _.extend(option, modelAnswer);
          });
        }
      }

    }
  ])

  .factory('questions.option', [
    function(){

      function getModel(model, question){
        return getSelected(model, question) && model[question.key];
      }

      function getSelected(model, question){
        return model[question.key] && _.findWhere(question.options, { value: model[question.key].value })
      }

      return {
        getModel: getModel,
        getLabel: function(model, question){
          var selected = getSelected(model, question);
          return selected && selected.text;
        },
        getQuestions: function(model, question){
          var selected = getSelected(model, question);
          return selected && selected.questions;
        },
        set: function(model, question){
          var key = question.key;
          model[key] = model[key] || {};
          _.each(question.options, function(option){
            option.selected = option.value === model[key].value;
          });
        }
      }

    }
  ]);
(function(){

  /**
   * @typedef {Object} Question
   * @property {string} key
   * @property {string} display_text
   * @property {string} response_type
   * @property {string} category
   * @property {string[]} answers
   */

  /**
   * @name questions.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config.paths} paths
   * @constructor
   */
  function Svc($q, $http, paths){
    var path = paths.services + '/questions';

    /**
     * @name questions.service.getByKeys
     * @methodOf questions.service
     * @param {string[]} keys
     * @param {string} [category]
     */
    this.getByKeys = function(keys, category){
      return $http.get(path, { params: { keys: keys.join(','), category: category }, cache: true })
        .then(function(response){
          return response.data;
        });
    };
  }
  Svc.$inject = ['$q', '$http', 'config.paths'];

  angular.module('questions')
    .service('questions.service', Svc);
}());
angular.module('scrollTo', []);
angular.module('scrollTo')
  .directive('shScrollTo', [
    '$timeout',
    'scrollTo.service',
    function($timeout, scrollToService){

      return {
        restrict: 'A',
        link: function($scope, $element, $attr){

          if (angular.isDefined($attr.shIf)){

            $scope.$watch($attr.shIf, function(newValue){
              if (newValue === true){
                go();
              }
            });
          }
          else {
            go();
          }

          function go(){
            // timeout allows for view content to be in place before scrolling to it
            // it's also less jarring to the user if they see the top of the page on load
            // and then see the page scroll, instead of loading and scrolling at the same time
            $timeout(function(){
              scrollToService.goToElement($element, $attr.offset, $attr.duration);
            }, $attr.delay || 0)
          }


        }
      }
    }
  ]);
angular.module('scrollTo')
  .factory('scrollTo.service', [
    '$q',
    function($q){
      var defaultDuration = 500;
      var $page = $('html,body');
      var $header = $('header.site');

      return {
        // only scrolling vertically for now
        go: go,

        goToElement: function($element, offset, duration){
          offset = offset || 0;

          if (!angular.isDefined(duration)){
            duration = defaultDuration;
          }

          if ($header.css('position') == 'fixed'){
            offset -= $header.outerHeight();
          }

          var top = $element.offset().top + offset;
          var stepFn = function(position, tween){
            tween.end = $element.offset().top + offset;
          };

          return go(top, duration, stepFn);
        }
      };

      function go(top, duration, stepFn){
        var deferred = $q.defer();
        if (!angular.isDefined(duration)){
          duration = defaultDuration;
        }

        if (window.scrollY === top){
          deferred.resolve(false);
        }
        else {
          $page.animate(
            { scrollTop: top },
            {
              duration: duration,
              step: stepFn || angular.noop,
              complete: function(){
                deferred.resolve(true);
              }
            }
          );
        }


        return deferred.promise;
      }
    }
  ]);
/**
 * Set of services that interacts with the scala layer
 * @module search
 * @namespace search
 */

angular.module('search', ['config', 'common.services', 'google', 'address'])

  /**
   * Shared methods used to query the scala layer
   * @name search.request
   */
  .service('search.request', [
    '$http',
    'config.paths',
    'address.service',
    function($http, paths, addressService){
      var searchBase = paths.search;
      var applicationWhiteList = [
        'hsa',
        'subsidy'
      ];

      /**
       * Get the resource from the server
       * @name search.request.get
       * @methodOf search.request
       * @param {string} path
       * @param {Object} [options]
       * @param {boolean} [options.cache=true]
       * @returns {HttpPromise}
       */
      this.get = function(path, options){
        return $http.get(searchBase + path, angular.extend({ cache: true }, options || {}));
      };

      /**
       * Post the resource to the server
       * @name search.request.post
       * @methodOf search.request
       * @param {string} path
       * @param {Object} data
       * @param {Object} [options]
       * @returns {HttpPromise}
       */
      this.post = function(path, data, options){
        return $http.post(searchBase + path, data, options);
      };

      /**
       * Post the health application json to the server
       * @name search.request.postApp
       * @methodOf search.request
       * @param {string} path
       * @param {health.app} applicationModel
       * @param {Object} [params]
       * @returns {HttpPromise}
       */
      this.postApp = function(path, applicationModel, params){
        var payload = _.isObject(params) ? params : {};
        var appData = applicationModel.get();

        _.each(applicationWhiteList, function(key){
          payload[key] = _.isEmpty(appData[key]) ? null : angular.copy(appData[key]);
        });

        payload.appId = applicationModel.getId() || null;
        payload.address = addressService.toGeo(applicationModel.address);
        payload.address.state = payload.address.stateCode;
        payload.address.zip = payload.address.zipcode; // TODO: remove

        payload.applicants = _.map(applicationModel.getCoveredMembers(), function(applicant){
          var ret = {
            gender: applicant.gender,
            type: applicant.type,
            uuid: applicant.id,
            tobacco: applicant.tobacco === true,
            age: applicant.age
          };

          ret.drugs = _.map(_.where(applicationModel.member_drugs, { member_id: applicant.id }), function(member_drug){

            /** @type {drug.model} */
            var drug = member_drug.drug_json;

            //// do everything as a per month for now
            //var freq = { timePeriodId: 3 };
            //var count = drug.fillQty / (drug.durationDays / 30);

            // do everything as a per year so it's always an int
            var freq = { timePeriodId: 4 };
            var fillCount = drug.fillCount;

            // for old drugs that don't have a fillCount attached
            if (!fillCount){
              fillCount = Math.floor(365 / drug.durationDays);
            }

            var count = drug.fillQty * fillCount;

            if (drug.qtyDivisible){
              freq.intake = count;
            }
            else {
              freq.fills = count;
            }

            var serverDrug = {
              id: drug.id,
              dose_id: drug.dose.id,
              ndc: drug.dose.ndc,
              name: drug.product,
              freq: freq
            };

            setTimePeriodId(serverDrug);

            return serverDrug;

          });

          // prefer provider_id for newer resources
          //ret.providers = _.map(applicant.providers, function(p){ return p.provider_id || p.id; });
          ret.providers = _.pluck(_.where(applicationModel.member_providers, { member_id: applicant.id }), 'provider_id');
          ret.illnesses = _.isArray(applicant.illnesses) ? applicant.illnesses.slice(0, 4) : [];

          return ret;
        });

        return $http.post(searchBase + path, payload);
      };


      var timePeriodsOld = [
        'daily',
        'weekly',
        'monthly',
        'yearly'
      ];
      var timePeriodsNew = [
        'DAY',
        'WEEK',
        'MONTH',
        'YEAR'
      ];

      function setTimePeriodId(drug){
        if (!angular.isDefined(drug.freq.timePeriodId)){

          var timePeriod = drug.freq.timePeriod;
          if (timePeriodsOld.indexOf(timePeriod) > -1){
            drug.freq.timePeriodId = timePeriodsOld.indexOf(timePeriod) + 1;
          }
          else if (timePeriodsNew.indexOf(timePeriod) > -1){
            drug.freq.timePeriodId = timePeriodsNew.indexOf(timePeriod) + 1;
          }
        }

        drug.freq.timePeriodId = parseInt(drug.freq.timePeriodId);
      }
    }
  ]);
(function(){

  /**
   * @typedef {Object} Carrier
   * @property {number} id
   * @property {number} brandId
   * @property {number} externalId
   * @property {number} hiosId
   * @property {string} name
   * @property {string} state
   * @property {string} product
   * @property {string} logoUrl
   */

  /**
   * @typedef {Object} CarrierBrand
   * @property {number} id
   * @property {string} name e.g. "Anthem"
   * @property {number[]} carriers These are the carrier IDs associated with the brand
   */

  /**
   * Carrier information
   * @name search.carriers
   * @memberOf search
   * @param {ng.$q} $q
   * @param {utils} utils
   * @param {search.request} searchRequest
   * @param {logger} logger
   */
  function Svc($q, utils, searchRequest, logger){

    /**
     * Get carriers for a given state and region
     * @name search.carriers.get
     * @methodOf search.carriers
     * @param {Address} address
     * @param {boolean} [onExchange]
     * @param {number} [planYear]
     * @returns {Promise.<Carrier[]|Error>}
     */
    this.get = function(address, onExchange, planYear){
      if (!_.isObject(address)){
        return $q.reject(new Error('Invalid address parameter for search.carriers.get'));
      }

      var params = {
        state: address.state,
        region: address.region,
        countyFips: address.county_fips,
        onExchange: _.isBoolean(onExchange) ? onExchange : undefined,
        planYear: planYear
      };

      return searchRequest.get('/carrier', { params: params })
        .then(utils.dataOrArray)
        .catch(function(err){
          logger.error({
            message: err && err.message || 'Error fetching carriers',
            reqParams: params
          });
          return [];
        });
    };

    /**
     * Get brands for a given state
     * @name search.carriers.getBrands
     * @methodOf search.carriers
     * @param {Address} address
     * @param {number} [planYear]
     * @returns {Promise.<CarrierBrand[]|Error>}
     */
    this.getBrands = function(address, planYear){
      if (!_.isObject(address)){
        return $q.reject(new Error('Invalid address parameter for search.carriers.getBrand'));
      }

      var params = _.pick(address, ['state', 'region', 'countyFips']);
      params.planYear = planYear;

      return searchRequest.get('/brand', { params: params })
        .then(utils.dataOrArray)
        .catch(function(err){
          logger.error({
            message: err && err.message || 'Error fetching brands',
            reqParams: params
          });
          return [];
        });
    };
  }
  Svc.$inject = ['$q', 'utils', 'search.request', 'logger'];

  angular.module('search')
    .service('search.carriers', Svc);
}());
//angular.module('search')
//  .factory('search.drugs', [
//    '$q',
//    'search.request',
//    function($q, searchRequest){
//      var url = '/drug';
//
//      function assureArray(response){
//        return response && _.isArray(response.data) ? response.data : [];
//      }
//
//      return {
//        search: function(drugName){
//          // return promise with empty array when no drug name so we don't try to hit the server
//          if (!drugName || drugName.length < 3) return $q.when([]);
//
//          return searchRequest.get(url, { params: { nameLike: drugName } })
//            .then(assureArray)
//        },
//
//        getDosages: function(drugId){
//          return searchRequest.get(url + '/' + drugId + '/dosages')
//            .then(assureArray)
//        },
//
//        getQuote: function(drug, zipcode){
//          var params = {
//            zip5: zipcode,
//            timePeriod: drug.freq.timePeriodId,
//            intake: drug.freq.intake,
//            fills: drug.freq.fills
//          };
//
//          return searchRequest.get(url + '/' + drug.id + '/dosages/' + drug.dose.ndc + '/quote', { params: params });
//        }
//
////        getPrice: function(drug){
////          return search({
////            url: paths.services + '/drug/price',
////            params: {
////              name: drug.name,
////              id: drug.id,
////              dosage: drug.dose.dosage.name,
////              dosid: drug.dose.dosage.id
////            }
////          });
////        },
//
////        getDrugCosts: function(plans){
////          var min = Number.MAX_VALUE;
////          var max = 0;
////          var avg;
////
////          var allTotal = _.reduce(plans, function(memo, plan){
////            var total = _.reduce(plan.mods.userDrugs, function(mem, drug){
////              return mem + drug.cost;
////            }, 0);
////
////            min = Math.min(min, total);
////            max = Math.max(max, total);
////
////            return memo + total;
////          }, 0);
////
////          avg = allTotal / plans.length;
////
////          return {
////            min: min,
////            max: max,
////            avg: avg,
////            total: allTotal
////          }
////        },
////
////        getRxDeductibleRange: function(plans){
////          var min = Number.MAX_VALUE;
////          var max = 0;
////
////          _.each(plans, function(plan){
////            var deductible = plan.amounts.deductibleRx;
////            min = Math.min(min, deductible);
////            max = Math.max(max, deductible);
////          });
////
////          return {
////            min: min,
////            max: max
////          }
////        }
//      };
//    }
//  ]);
//

(function(){

  /**
   * @typedef {Object} Geo
   * @property {number} [id]
   * @property {string} [street]
   * @property {string} [unit]
   * @property {string} city
   * @property {string} [county]
   * @property {string} state
   * @property {string} zipcode
   * @property {string|number} [region]
   * @property {string} countyFips
   * @property {string} [stateCode]
   * @property {number} [lat]
   * @property {number} [lng]
   */


  /**
   * @name search.geo
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {ng.$window} $window
   * @param {config} config
   * @param {config.service} configService
   * @param {search.request} searchRequest
   * @param {utils} utils
   * @param {google.maps} maps
   * @param {address.service} addressService
   */
  function GeoSearchService($q, $http, $window, config, configService, searchRequest, utils, maps, addressService){
    var self = this;


    /**
     * @name search.geo.getByZip
     * @memberOf search.geo
     * @param zipcode
     * @returns {Promise<Address[]>}
     */
    this.getByZip = function(zipcode){
      return searchRequest.get('/geo/counties?zipcode=' + (zipcode || ''))
        .then(handleResponse);
    };

    /**
     * @name search.geo.getByIp
     * @memberOf search.geo
     * @param {string} [ip]
     * @returns {Promise<Address[]>}
     */
    this.getByIp = function(ip){
      return searchRequest.get('/geo/counties' + (ip ? '?' + ip : ''), { cache: false })
        .then(handleResponse);
    };

    /**
     * Get the state config from contentful
     * @name search.geo.getStateConfig
     * @memberOf search.geo
     * @param {string} stateCode
     * @returns {Object|null}
     */
    this.getStateConfig = function(stateCode){
      if (!_.isString(stateCode) || stateCode.length !== 2){
        return $q.when(null);
      }

      return $http
        .get(config.paths.services + '/content/state/' + stateCode.toUpperCase(), { cache: true })
        .then(function(response){
          return response && response.data && response.data.data || null;
        });
    };

    this.getStates = function(){
      return $http
        .get(config.paths.services + '/content/states', { cache: true })
        .then(function(response){
          return response.data;
        });
    };

    /**
     * See if we support the state
     * @name search.geo.checkValidState
     * @memberOf search.geo
     * @param {string} stateCode
     * @returns {Promise<boolean>}
     */
    this.checkValidState = function(stateCode){
      return self.getStateConfig(stateCode)
        .then(function(config){
          return !!config;
        });
    };

    /**
     * Get the state exchange configuration from contentful
     * @name search.geo.getStateExchange
     * @memberOf search.geo
     * @param {string} stateCode
     * @returns {Object}
     */
    this.getStateExchange = function(stateCode){
      return self.getStateConfig(stateCode)
        .then(function(stateConfig){
          if (!stateConfig.stateExchange) {
            return {};
          }

          return configService.getEntry(stateConfig.stateExchange.id, 10)
        });
    };

    /**
     * Attempts to use the browsers geolocation API and then use those coordinates
     * to query the google maps GeoCoding API to fill out the address
     * @name search.geo.geoLocate
     * @memberOf search.geo
     * @returns {Promise<Address|Error>}
     */
    this.geoLocate = function(){
      var deferred = $q.defer();

      if (self.canGeoLocate()){
        $window.navigator.geolocation.getCurrentPosition(function(position){

          maps.getAddress({ lat: position.coords.latitude, lng: position.coords.longitude })
            .then(function(result){
              deferred.resolve(result);
            })
            .catch(function(){
              deferred.reject('No results');
            });


        }, function(err){
          deferred.reject(err);
        });
      }
      else {
        deferred.reject('No Support');
        //self.getByIp()
        //  .then(function(results){
        //    deferred.resolve(results);
        //  });
      }

      return deferred.promise;
    };

    /**
     * Checks the browsers capability to use geoLocation
     * @name search.geo.canGeoLocate
     * @memberOf search.geo
     * @returns {boolean}
     */
    this.canGeoLocate = function(){
      return 'geolocation' in $window.navigator;
    };

    /**
     * Format the Scala service response
     * @name search.geo.handleResponse
     * @memberOf search.geo
     * @param {ng.$http.response} response
     * @returns {Address[]}
     * @private
     */
    function handleResponse(response){
      if (response && _.isArray(response.data)){
        return _.map(response.data, function(data){
          return _.extend(self.toAddress(data), {
            city: utils.capitalize(data.city),
            county: utils.capitalize(data.county)
          });
        });
      }

      return [];
    }


    /**
     * @name search.geo.toAddress
     * @methodOf search.geo
     * @param {Geo} geo
     * @returns {Address}
     */
    this.toAddress = addressService.fromGeo;

    /**
     * @name search.geo.fromAddress
     * @methodOf search.geo
     * @param {Address} address
     * @returns {Geo}
     */
    this.fromAddress = addressService.toGeo;
  }
  GeoSearchService.$inject = ['$q', '$http', '$window', 'config', 'config.service', 'search.request', 'utils', 'google.maps', 'address.service'];

  angular.module('search')
    .service('search.geo', GeoSearchService);
}());
/**
 * @typedef {Object} Illness
 * @property {number} id
 * @property {string} name
 */

angular.module('search')
  .factory('search.illnesses', [
    'search.request',
    function(searchRequest) {
      return {
        get: function () {
          return searchRequest.get('/illness')
            .then(function (response) {
              return response && response.data ? response.data : [];
            });
        }
      }
    }
  ]);


//angular.module('search')
//  .factory('search.visits', [
//    '$http',
//    '$q',
//    'config.paths',
//    function($http,$q, paths){
//      var _url = paths + '/visit/search';
//
//      return {
//        getForApplicant: function(applicant){
//          return $http.post(url, { user: applicant })
//            .then(function(repsonse){
//              console.log(response)
//            })
//        }
//      };
//    }
//  ]);
(function(){

  /**
   * @name session
   * @param {ng.$window} $window
   */
  var Session = function($window){

    var self = this;
    var storageObject = {};
    var hasStorage = testHasStorage();

    /**
     * @name session.set
     * @methodOf session
     * @param {string} key
     * @param {*} value
     * @param {string[]} [props]
     */
    self.set = function(key, value, props){

      // optionally only save passed in props on the session object
      if (_.isArray(props)){
        value = _.extend((self.get(key) || {}), _.pick(value, props));
      }

      // stringify everything, even strings, so JSON.parse used in get method will always succeed
      if (hasStorage){
        $window.localStorage.setItem(key, angular.toJson(value));
      }
      else {
        storageObject[key] = angular.toJson(value);
      }
    };

    /**
     * @name session.get
     * @methodOf session
     * @param {string} key
     * @returns {*}
     */
    self.get = function(key){
      if (hasStorage){
        return angular.fromJson($window.localStorage.getItem(key));
      }

      return angular.fromJson(storageObject[key]);
    };

    /**
     * @name session.remove
     * @methodOf session
     * @param {string} key
     */
    self.remove = function(key){
      if (hasStorage){
        $window.localStorage.removeItem(key);
      }
      else {
        delete storageObject[key];
      }
    };

    /**
     * @name session.clear
     * @methodOf session
     */
    self.clear = function(){
      if (hasStorage){
        $window.localStorage.clear();
      }
      else {
        storageObject = {};
      }
    };

    function testHasStorage(){
      var result = false;

      // Uber android app doesn't support localStorage http://stackoverflow.com/questions/5899087/android-webview-localstorage
      if (!$window.localStorage){
        return result;
      }

      // iOS incognito can read from localStorage but can't write https://spin.atomicobject.com/2013/01/23/ios-private-browsing-localstorage/
      var testKey = 'ls_test_key';

      try {
        var testDate = (new Date()).toString();
        $window.localStorage.setItem(testKey, testDate);
        result = $window.localStorage.getItem(testKey) === testDate;
        $window.localStorage.removeItem(testKey);
      }
      catch (e) {}

      return result;
    }

  };
  Session.$inject = ['$window'];

  angular.module('session', []).service('session', Session);
}());



angular.module('sidebar', ['scrollTo', 'common']);
(function(){

  function SidebarController($scope, sidebarService){
    var self = this;
    _.each(['isOpen', 'hide', 'show', 'toggle'], function(prop){
      this[prop] = sidebarService[prop];
    }, this);

    $scope.$on('$stateChangeSuccess', sidebarService.hide);
    $scope.$on('doc-click', function(ngEvent, jqEvent){
      var $el = $('.sidebar');
      if (self.isOpen() && !$el.is(jqEvent.target) && !$(event.target).is('.sidebar-toggle') && !$.contains($el[0], jqEvent.target)) {
        $scope.$apply(function(){
          self.hide();
        });
      }
    });
  }
  SidebarController.$inject = ['$scope', 'sidebar.service'];

  angular.module('sidebar')
    .controller('sidebar.controller', SidebarController);
}());
(function(){

  /**
   * Controls the sidebar functionality
   * @name sidebar.service
   * @param {ng.$rootScope} $rootScope
   * @param {Object} scrollToService
   * @constructor
   */
  function SidebarService($rootScope, scrollToService){
    var isOpen = false;

    this.show = show;
    this.hide = hide;

    /**
     * @name sidebar.service.isOpen
     * @returns {boolean}
     */
    this.isOpen = function(){
      return isOpen;
    };

    /**
     * Toggle the visibility of the sidebar
     * @name sidebar.service.toggle
     */
    this.toggle = function(){
      if (isOpen){
        hide();
      }
      else {
        show();
      }
    };

    /**
     * Hide the sidebar
     * @name sidebar.service.hide
     */
    function hide(){
      isOpen = false;
    }

    /**
     * Show the sidebar and scroll to top
     * @name sidebar.service.show
     */
    function show(){
      scrollToService.go(0, 100);
      isOpen = true;
    }

    $rootScope.$on('delayed-resize', function(){
      if (isOpen){
        $rootScope.$apply(hide);
      }
    });
  }
  SidebarService.$inject = ['$rootScope', 'scrollTo.service'];

  angular.module('sidebar')
    .service('sidebar.service', SidebarService);
}());
angular.module('snackbar', [])

/**
 * @namespace snackbar
 */

  .factory('snackbar.service', [
    '$timeout',
    function($timeout){

      var queue = [];
      var defaultDuration = 3;
      var defaultDelay = 0.5;

      /**
       * @typedef {object} SnackbarItem
       * @property {string} key
       * @property {boolean} [removable=true]
       * @property {object} [tokens]
       * @property {number} [duration=3] in seconds
       * @property {number} [delay=0.5] in ms
       * @property {ng.$timeout} [timeout]
       * @property {function} [onDismiss]
       */

      /**
       * @name snackbar.service
       */
      var exports = {
        /**
         * @name snackbar.service.getQueue
         * @returns {SnackbarItem[]}
         */
        getQueue: function(){
          return queue;
        },
        /**
         * @name snackbar.service.push
         * @param {SnackbarItem} config
         */
        push: function(config){
          var item = _.extend({
            tokens: {},
            removable: true
          }, config);

          // don't push in the same item multiple times
          if (contains(item)) {
            return;
          }

          if (!_.isNumber(config.duration)){
            config.duration = defaultDuration;
          }

          if (!_.isNumber(config.delay)){
            config.delay = defaultDelay;
          }

          // a negative duration will not trigger a timer
          if (config.duration > -1){
            item.timeout = $timeout(function(){
              exports.remove(item);
            }, config.duration * 1000);
          }

          if (queue.length){
            exports.clear();
          }

          $timeout(function(){
            queue.push(item);
          }, config.delay);
        },
        /**
         * @name snackbar.service.remove
         * @param {SnackbarItem} item
         */
        remove: function(item){
          var index = _.indexOf(queue, item);

          if (item.timeout) {
            $timeout.cancel(item.timeout);
          }

          if (_.isFunction(item.onDismiss)) {
            item.onDismiss();
          }

          if (index > -1) {
            $timeout(function(){
              queue.splice(index, 1);
            });
          }
        },
        /**
         * @name snackbar.service.clear
         */
        clear: function(){
          _.each(queue, function(item){
            exports.remove(item);
          });
        }
      };

      return exports;

      function contains(item){
        return _.some(queue, function(qItem){
          return qItem.key === item.key &&
            qItem.removable === item.removable &&
            _.isEqual(qItem.tokens, item.tokens);
        });
      }
    }
  ])


  // there should be only one snackbar-container on the page
  .directive('snackbarContainer', [
    'config.paths',
    'snackbar.service',
    function(paths, snackbarService){
      return {
        templateUrl: paths.partials + '/components/snackbar/snackbar.html',
        link: function($scope, $element){

          // TODO: is this needed in any browsers? doesn't look like it matters in chrome
          // can't just cue off the length of the array, since we need to wait til ng-leave
          // finishes before removing the active class
          $scope.$watch(function(){ return $element.children().length; }, function(value){
            if (value){
              $element.addClass('active');
            }
            else {
              $element.removeClass('active');
            }
          });

          $scope.queue = snackbarService.getQueue();
          $scope.remove = snackbarService.remove;
        }
      };
    }
  ]);
(function () {

  /**
   *
   * @param $scope
   * @param financeService
   * @constructor
   */
  function Ctrl($scope, financeService, trackingService) {

    $scope.trackSkip = function(){
      trackingService.mixpanelEvent('Skipped guided flow');
    }

    /**
     * Saves the finance information
     * @name estimation.source.controller.save
     * @methodOf estimation.source.controller
     */
    this.save = function () {
      financeService.update($scope.source.finances);
      financeService.saveForApp($scope.source.appId, {deep: true})
        .then(function (response) {
          $scope.source.finances = response;
          $scope.onNext();
        });
    };

    /**
     * Gets the number of estimation (finances) from the estimation source
     * @name estimation.source.controller.getNumFinances
     * @methodOf estimation.source.controller
     * @returns {Number}
     */
    this.getNumFinances = function () {
      if (!$scope.source) {
        return 0;
      }

      return _.filter($scope.source.finances, function (finance) {
        return !finance.delete && finance.type === $scope.financeType;
      }).length;
    };


    this.getHeaderLabel = function() {
      var currentMember = $scope.source.member;
      if (currentMember) {
        switch (currentMember.type) {
          case 'primary':
            return 'my'; // or 'your' depending on if it's the header?
          case 'spouse':
            // first_name || your spouse's
            return (currentMember.first_name || "my spouse") + "'s";
          case 'dependent':
            // first_name || your 20 year old's || household member's
            var ageMemberLabel = currentMember.age ? "my " + currentMember.age + " year old" : null;
            return (currentMember.first_name || ageMemberLabel || "My household member") + "'s";
          default:
            return "my household member's";
        }
      }
    };

    this.getLabel = function () {
      var currentMember = $scope.source.member;
      if (currentMember) {
        switch (currentMember.type) {
          case 'primary':
            return 'your'; // or 'your' depending on if it's the header?
          case 'spouse':
            // first_name || your spouse's
            return currentMember.first_name || "your spouse" + "'s";
          case 'dependent':
            // first_name || your 20 year old's || household member's
            var ageMemberLabel = currentMember.age ? "your " + currentMember.age + " year old" : null;
            return (currentMember.first_name || ageMemberLabel || "household member") + "'s";
          default:
            return "household member's";
        }
      }
    };

  }

  Ctrl.$inject = ['$scope', 'finance.service', 'services.tracking'];

  angular.module('profile')
    .controller('estimation.source.controller', Ctrl);
}());
angular.module('profile')
  .directive('shFinanceSource', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          source: '=',
          onNext: '=',
          form: '=',
          isOnboarding: '=?',
          financeType: '=',
          unit: '@',
          requireOne: '=?'
        },
        templateUrl: paths.partials + '/components/subsidy/finance-source.html',
        controller: 'estimation.source.controller as financeSourceCtrl'
      };
    }
  ]);
angular.module('translate', ['config', 'common']);
angular.module('translate')
  .directive('shTranslate', [
    '$filter',
    'translate.service',
    function($filter, translateService){
      return {
        restrict: 'A',
        link: function($scope, $element, $attr){
          var _formatObj = null;
          var _value = '';

          function translate(){
            if ($attr.shTranslate){
              translateService.translate($attr.shTranslate)
                .then(function(value){
                  _value = value;
                  updateHtml();
                });
            }
          }

          function updateFormat(formatObj){
            if (angular.isDefined(formatObj)){
              _formatObj = $scope.$eval(formatObj);
              updateHtml();
            }
          }

          function updateHtml(){
            var html = _value;
            if (_formatObj != null){
              html = $filter('format')(html, _formatObj);
            }

            $element.html(html);
          }

          $attr.$observe('shTranslate', translate);
          $attr.$observe('formatWith', updateFormat);
          $scope.$on('locale-updated', translate);
        }
      };

    }
  ])

  .directive('shTranslateArray', [
    'translate.service',
    function(translateService){
      return {
        scope: true,
        link: function($scope, $element, $attr){
          $attr.$observe('shTranslateArray', function(value){
            translateService.translate(value)
              .then(function(array){
                $scope.array = _.isArray(array) ? array : [];
              });
          });
        }
      };
    }
  ])

  .directive('shTranslateKvpArray', [
    'translate.service',
    function(translateService){


      return {
        scope: true,
        link: function($scope, $element, $attr){
          $attr.$observe('shTranslateKvpArray', function(value){
            translateService.translate(value)
              .then(function(obj){
                var keys = _.keys(obj);

                $scope.array = _.map(keys, function(key){
                  return {
                    key: key,
                    value: obj[key]
                  };
                });
              });

          });
        }
      };
    }
  ])

  .directive('shTranslateArrayValue', [
    'translate.service',
    function(translateService){
      return {
        scope: true,
        link: function($scope, element, $attr){
          var debouncedUpdate = _.debounce(function update(){
            translateService.translate($attr.shTranslateArrayValue)
            .then(function(array){
              var query = {};
              query[$attr.objKey] = $attr.objValue;
              $scope.arrayItem = _.findWhere(array, query);
            });
          }, 100);

          $attr.$observe('shTranslateArrayValue', debouncedUpdate);
          $attr.$observe('objKey', debouncedUpdate);
          $attr.$observe('objValue', debouncedUpdate);
        }
      };
    }
  ])

  // useful for when a link is embedded within a translation string
  .directive('shLinkClick', [
    '$parse',
    function($parse){
      return {
        link: function($scope, $element, $attr){
          $element.on('click', 'a', function(e){
            e.preventDefault();
            $parse($attr.shLinkClick)($scope);
          });
        }
      };
    }
  ]);
angular.module('translate')
  .filter('translate', [
    'translate.service',
    function(translateService){
      function filter(key){
        return translateService.tryTranslate(key);
      }
      filter.$stateful = true;

      return filter;
    }
  ]);
angular.module('translate')
  .service('translate.service', [
    '$q',
    '$http',
    'utils',
    'config.service',
    'config.paths',
    function($q, $http, utils, configService, paths){
      var self = this;
      var _cache = {};
      var _pending = {};
      var _brand = configService.getBrand();

      // key should be in the format user.account.login
      // user.json is the file to load and user will be
      // the key of the stored object, which will then have
      // an account: { login: 'Text' } object
      self.translate = function(key){

        var parts = key.split('.');
        var filename = parts.shift();

        return getTranslation(filename)
          .then(function(translationObj){
            return utils.traverse(translationObj, parts);
          })
      };

      // this method will try to get from the cache without using any
      // requests/promises, useful for items that will be called frequently
      // in digest cycle, like filters
      self.tryTranslate = function(key){
        if (!angular.isDefined(key)) return;

        var locale = getLocale();
        // if the locale doesn't exist in the cache, or the file for the locale doesn't exist in the cache
        // go get that translation, but don't wait for it here, it will get pulled in with the next digest
        if (!_cache[locale] || !_cache[locale][key.split('.')[0]]) self.translate(key);

        return utils.traverse(_cache, getLocale() + '.' + key) || '';
      };

      function getTranslation(filename){
        var pending;
        var locale = getLocale();

        // if it's already been requested and cached, just return that object
        if (_cache[locale] && _cache[locale][filename]){
          return $q.when(_cache[locale][filename]);
        }

        pending = getPendingRequest(locale, filename);
        // if it's already been requested, but waiting for response, return that pending request promise
        if (pending){
          return pending.promise;
        }

        // create the deferred so subsequent calls don't repeat the json fetch
        setPendingRequest(locale, filename);

        return $http
          .get(paths.translations + '/' + _brand + '/' + locale.replace('_', '-') +  '/' + filename + '.json', { cache: true })
          .then(function(response){
            var json = response.data;

            // add it to the cache
            _cache[locale] = _cache[locale] || {};
            _cache[locale][filename] = json;

            // resolve the pending request for anyone waiting
            getPendingRequest(locale, filename).resolve(json);
            // get rid of it
            clearPendingRequest(locale, filename);

            // return the object for the initial request
            return json;
          });
      }

      function setPendingRequest(locale, filename){
        var pendingDeferred = $q.defer();
        _pending[locale] = _pending[locale] || {};
        _pending[locale][filename] = pendingDeferred;
      }

      function getPendingRequest(locale, filename){
        return _pending[locale] && _pending[locale][filename] ? _pending[locale][filename] : false;
      }

      function clearPendingRequest(locale, filename){
        if (_pending[locale] && _pending[locale][filename]){
          delete _pending[locale][filename];
        }
      }

      function getLocale(){
        // replace - with _ for direct accessing of the _cache object
        return configService.getLocale().replace('-', '_');
      }
    }
  ])

angular.module('user', ['ui.router', 'common', 'config', 'application', 'search', 'session']);
angular.module('user')
  .service('user.model', [
    '$q',
    '$window',
    '$location',
    'utils',
    'services.auth',
    'session',
    'services.tracking',
    'user.service',
    'config.service',
    'drug.service',
    'search.geo',
    'application.service',
    /**
     * @param {ng.$q} $q
     * @param {ng.$window} $window
     * @param {ng.$location} $location
     * @param {utils} utils
     * @param {services.auth} authService
     * @param {session} sessionService
     * @param {services.tracking} trackingService
     * @param {user.service} userService
     * @param {config.services} configService
     * @param {drug.service} drugService
     * @param {search.geo} geoSearch
     * @param {application.service} applicationService
     */

      function ($q, $window, $location, utils, authService, sessionService, trackingService, userService, configService, drugService, geoSearch, applicationService) {

      /**
       * @name user.model
       * @property {bor.model} bor
       * @property {string} workingAppId
       * @property {string} activeAppId
       * @property {string} email
       * @property {Address} geo
       * @property {boolean} isLoggedIn
       * @property {boolean} isVerified
       * @property {boolean} isAliased
       * @property {string} locale
       * @property {UUID} oid
       * @property {UserPartnerData} partnerData
       * @property {UUID} primaryMemberId
       * @property {string} ref
       * @property {*} settings
       * @property {string} site
       * @property {string} source
       * @property {string} username
       */

      var self = this;

      self.getLocale = function () {
        return self.locale;
      };

      /**
       * @returns {string}
       */
      self.getPrimaryId = function () {
        return self.primaryMemberId;
      };

      /**
       * @name user.model.setRef
       * @methodOf user.model
       * @param {string} ref
       * @returns {boolean}
       */
      self.setRef = function (ref) {
        if (!self.ref) {
          self.ref = '';
        }

        var retVal = false;
        var values = self.ref.split('|');

        if (values[0] !== ref) {
          values.unshift(ref);
          self.ref = values.slice(0, 10).join('|').replace(/\|$/, '');
          retVal = true;
        }

        return retVal;
      };

      self.setSite = function (site) {
        var retVal = false;

        // only set the domain if it's empty
        if (!self.site || self.site === '') {
          self.site = site;
          retVal = true;
        }

        return retVal;
      };

      /**
       * @name user.model.getGeo
       * @methodOf user.model
       * @returns {Address}
       */
      self.getGeo = function () {
        return _.isArray(self.geo) ? self.geo[0] : self.geo;
      };

      /**
       * Get geo object from the server based on IP if not set yet
       * @name user.model.fetchGeo
       * @methodOf user.model
       * @returns {Promise<Address>}
       */
      self.fetchGeo = function () {
        if (!_.isEmpty(self.getGeo())) {
          return $q.when(self.getGeo());
        }

        return geoSearch.getByIp()
          .then(function (results) {
            if (results && results.length) {
              self.geo = results[0];
            }
            else {
              self.geo = null;
            }

            return self.geo;
          });
      };

      self.get = function () {
        var val = _.pick(self, ['ref', 'site', 'source', 'locale', 'settings', 'primaryMemberId', 'bor', 'workingAppId']);
        val.geo = self.getGeo();
        return val;
      };

      self.getId = function () {
        return self.oid;
      };

      self.save = function (overwrite) {
        var payload = self.get();
        // this should only be set by the server, don't overwrite
        delete payload.primaryMemberId;

        // avoid potential overwrite of server value if no values set on client
        if (!_.isString(payload.currentAppId) || !payload.currentAppId.length) {
          delete payload.currentAppId;
        }

        return userService.save(payload)
          .then(function (data) {
            return overwrite && data && data.user && self.fromServer(data.user) || self;
          });
      };

      self.saveLocale = function () {
        var locale = configService.getLocale();
        if (locale !== self.locale) {
          self.locale = locale;
          self.save();
        }
      };

      self.savePlan = function (plan) {
        return userService.savePlan(plan)
          .then(function (response) {
            return self.fromServer(response.data.user);
          });
      };

      /**
       * @name user.model.getPartnerData
       * @methodOf user.model
       * @param {string} key
       * @returns {*}
       */
      self.getPartnerData = function (key) {
        var data = self.partnerData || {};

        if (!_.isUndefined(data[key])) {
          return data[key];
        }

        if (data.attributes && !_.isUndefined(data.attributes[key])) {
          return data.attributes[key];
        }

        return null;
      };

      /**
       * @name user.model.getTaxData
       * @methodOf user.model
       * @returns {UserTaxData}
       */
      self.getTaxData = function () {
        return {
          income: self.getPartnerData('yearlyIncome'),
          familySize: self.getPartnerData('householdSize')
        };
      };

      self.fromServer = function (jsonObj) {
        _.each([
          'oid',
          'ref',
          'site',
          'username',
          'locale',
          'email',
          'geo',
          'isLoggedIn',
          'isAliased',
          'isVerified',
          'partnerData',
          'primaryMemberId',
          'workingAppId',
          'activeAppId',
          'settings',
          'source',
          'bor'
        ], function (key) {
          self[key] = jsonObj[key];
        });

//        applicationModel.set(jsonObj.application);
        authService.setAuthenticated(self.isLoggedIn);
        authService.setVerified(self.isVerified);
//        authService.setAppComplete(applicationModel.isComplete());
        configService.setLocale(self.locale);

        return self;
      };

      /**
       * @param {string} key
       * @returns {*|null}
       */
      self.getSetting = function (key) {
        if (_.isObject(self.settings) && !_.isUndefined(self.settings[key])) {
          return self.settings[key];
        }

        return null;
      };

      self.setSetting = function (key, value) {
        if (!_.isObject(self.settings)) {
          self.settings = {};
        }

        self.settings[key] = value;
        // TODO: once there is a separate endpoint for settings, don't do a wholesale save of the user
        return self.save(true);
      };

      self.syncFromServer = function () {
        return userService.get().then(function (data) {
          if (data && data.user) {
            self.fromServer(data.user);
          }

          return self;
        });
      };

      /**
       * @name user.model.setTrackingVars
       * @methodOf user.model
       * @returns {Promise<user.model>}
       */
      self.setTrackingVars = function () {
        var ref = trackingService.getRefCode();

        // returns true if the user domain is empty
        var saveUser = self.setSite(trackingService.getSite());

        // returns true if the user ref gets updated
        if (ref && self.setRef(ref)) {
          saveUser = true;
        }

        if (saveUser) {
          return self.save(true);
        }

        return $q.when(self);
      };

      self.login = function (username, password) {
        return userService.login(username, password, self)
          .then(trackingService.tryAlias)
          .then(function(){ return self; });
      };

      self.logout = function () {
        return userService.logout()
          .then(sessionService.clear)
          .then(function () {
            $window.location.href = '//' + $location.host() + ':' + $location.port();
          });
      };

      /**
       * @name user.model.setWorkingApp
       * @methodOf user.model
       * @param {string} app_id
       * @returns {Promise<user.model>}
       */
      self.setWorkingApp = function (app_id) {
        self.workingAppId = app_id;
        return self.save(true);
      };


      /**
       * @name user.model.activeHealth
       * @memberOf user.model
       * @type {ifp_app}
       */
      this.activeHealth = null;

      /**
       * @name user.model.activeHealthStatus
       * @memberOf user.model
       * @type {ifp_enroll_status}
       */
      this.activeHealthStatus = null;

      /**
       * @name user.model.isActiveHealthComplete
       * @methodOf user.model
       * @returns {boolean}
       */
      this.isActiveHealthComplete = function () {
        return _.get(self, 'activeHealthStatus.isComplete', false);
      };

      /**
       * @name user.model.setActiveHealth
       * @methodOf user.model
       * @param {ifp_app} app
       * @returns {ifp_app}
       */
      this.setActiveHealth = function(app){
        if (_.isObject(app)){
          this.activeHealth = app;
          this.activeAppId = app.app_id;
          this.activeHealthStatus = _.get(app, 'ifp_enroll_statuses[0]');
          return app;
        }

        return null;
      };

      /**
       * @name user.model.fetchActiveHealth
       * @methodOf user.model
       * @returns {HttpPromise<ifp_app>}
       */
      this.fetchActiveHealth = function () {
        return applicationService.getActive(this, 'health')
          .then(this.setActiveHealth);
      };
    }
  ]);

/**
 * @typedef {object} UserPartnerData
 * @property {boolean} active
 * @property {string} age
 * @property {object} attributes
 * @property {string} createdOn Date string
 * @property {string} dob Date string
 * @property {string} email
 * @property {boolean} enrolled
 * @property {string} gender
 * @property {number} id
 * @property {string} partner
 * @property {string} partnerId
 * @property {boolean} signedUp
 * @property {string} tier
 * @property {string} updatedOn Date string
 * @property {string} userId
 * @property {string} zip5
 * @property {string} zipcode
 */

/**
 * @typedef {object} UserTaxData
 * @property {number} familySize
 * @property {number} income
 */
angular.module('user')
  .factory('user.service', [
    '$q',
    '$http',
    '$location',
    '$rootScope',
    '$state',
    'config.paths',
    'services.tracking',
    'application.service',
    'utils',
    function ($q, $http, $location, $rootScope, $state, paths, trackingService, applicationService, utils) {
      var serviceBase = paths.services;
      var url = serviceBase + '/user';

      /**
       * @name user.service
       * @type {{get: Function, save: Function, savePlan: Function, login: Function, logout: Function, create: Function, createFromForm: Function, verify: Function, resendVerify: Function, requestResetPassword: Function, resetPassword: Function, changePassword: Function}}
       */
      var svc = {
        get: function () {
          return $http.get(url + '?ts=' + (new Date()).getTime()).then(function (response) {
            return response.data;
          });
        },

        save: function (userData) {
          return $http.post(url, {user: userData})
            .then(function (response) {
              return response && response.data;
            });
        },

        savePlan: function (plan) {
          return $http.post(url + '/plan', {plan: plan});
        },

        login: function (username, password, userModel) {

          return $http
            .post(url + '/login', {email: username, password: password})
            .then(function (res) {
              if (_.get(res, 'data.status') !== 'OK'){
                return $q.reject(_.get(res, 'data.message', 'Error creating account'));
              }

              userModel.fromServer(res.data.data.user);
              $rootScope.$broadcast('user-login', userModel);
              return userModel;
            });
        },

        logout: function () {
          trackingService.mixpanel.track('Logged Out');

          if (window.mixpanel && window.mixpanel.cookie) {
            window.mixpanel.cookie.clear();
          }

          return $http.get(url + '/logout');
        },

        create: function (email, password, source, userModel) {
          return $http
            .post(url + '/create', {email: email, password: password, source: source || 'account'})
            .then(function (response) {
              if (!response || !response.data || response.data.status !== 'OK' || !response.data.user) {
                return $q.reject(response && response.data || 'Account create error');
              }

              userModel.fromServer(response.data.user);

              // Alias anonymous user to authenticated user
              return trackingService.alias(userModel);
            })
            .then(function () {

              trackingService.mixpanel.track('Signed Up', {
                'Source': source
              });
              // https://mixpanel.com/help/reference/javascript-full-api-reference#mixpanel.identify
              // identify() should not be called to link anonymous activity to subsequent activity when a unique ID
              // is first assigned. Use alias() when a unique ID is first assigned (registration), and use identify()
              // to identify the user with that unique ID on an ongoing basis (e.g., each time a user logs in after
              // registering). Do not call identify() at the same time as alias().
              //trackingService.mixpanel.identify(email, {
              //  name: email
              //});

              return userModel;
            });
        },

        createFromForm: function (username, password, userModel, applicationModel, form) {
          if (form && form.$valid) {
            var data = $state.current.data || {};

            // look for source on the current route data, e.g. buyAccount.create
            var source = $state.params.source ? $state.params.source : data.source;
            var createSuccessRoute = data.createSuccessRoute || $location.url() + '/success';

            return svc.create(username, password, source, userModel)
              .then(function () {
                trackingService.virtualPageView(createSuccessRoute);
                return applicationService.createAppsFromSession();
              })
              .then(function (apps) {
                var healthApp = _.find(apps, { type: 'health' });
                applicationModel.setFromDb(healthApp);
                return userModel.setWorkingApp(healthApp.app_id);
              })
              .then(function(){
                $rootScope.$broadcast('user-create', userModel);
              });
          }

          return $q.reject('Invalid form');
        },

        verify: function (code) {
          return $http
            .get(serviceBase + '/verify/' + code)
            .then(function (response) {
              return response && response.data && response.data.status === 'OK' ? response.data.user : false;
            });
        },

        resendVerify: function () {
          return $http.get(serviceBase + '/verify/resend');
        },

        requestResetPassword: function (email) {
          return $http.post(serviceBase + '/password/reset', {email: email});
        },

        resetPassword: function (code, email, password) {
          return $http.post(serviceBase + '/password/reset/' + code, {email: email, password: password});
        },

        changePassword: function (oldPassword, newPassword) {
          return $http.post(serviceBase + '/password/change', {oldPassword: oldPassword, newPassword: newPassword});
        },



//        resetApp: function(){
//          return $http.get(url + '/new-app')
//            .then(function(response){
//              return response && response.data && response.data.user ? response.data.user : false;
//            });
//        }
      };

      return svc;
    }
  ]);

/**
 * @name visit
 * @constructor
 */
angular.module('visit', ['ui.router', 'config', 'common', 'doctor', 'plan', 'translate', 'member']);

(function(){

  /**
   * @typedef {Object} VisitService
   * @property {string} type
   * @property {string} name
   */

  /**
   * @typedef {Object} VisitPlan
   * @property {UUID} id
   * @property {UUID} user_id
   * @property {UUID} member_id
   * @property {string} ifp_app_id
   * @property {string} type
   * @property {number} provider_id
   * @property {Date} appointment_date
   * @property {Date} reminder_date
   * @property {number[]} recommended_benefits
   * @property {number[]} suggested_benefits
   * @property {number[]} requested_benefits
   * @property {number[]} additional_services
   * @property {string} notes
   *
   * @property {string} status
   */

  /**
   * @typedef {Object} VisitType
   * @property {string} key
   * @property {string[]} questionKeys
   */

  /**
   * @typedef {Object} VisitBenefitCriteria
   * @property {string} attribute
   * @property {string} operator
   * @property {*} reference
   * @property {boolean} all
   * @property {string} strength
   */

  /**
   * @typedef {Object} VisitBenefitService
   * @property {number} id
   * @property {string} serviceName
   * @property {string} visitType
   * @property {string} visitSubType
   * @property {string} url
   * @property {string} recommendationText
   * @property {boolean} selected
   */

  /**
   * @typedef {Object} VisitBenefitRecommendation
   * @property {number} id
   * @property {number} serviceId
   * @property {string} strength
   * @property {number} ageMax
   * @property {number} ageMin
   * @property {VisitBenefitCriteria[]} criteria
   * @property {string} gender
   * @property {string} text
   * @property {string} link
   * @property {boolean} selected
   */

  /**
   * @typedef {Object} VisitBenefit
   * @property {string} bestStrength
   * @property {VisitBenefitCriteria[]} matchingCriteria
   * @property {VisitBenefitRecommendation} recommendation
   * @property {VisitBenefitService} service
   */

  /**
   * @name visit.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config.paths} paths
   * @param {utils} utils
   * @param {*} translateService
   * @constructor
   */
  function Svc($q, $http, paths, utils, translateService){
    var self = this;

    /**
     * @name visit.service.getEligibleTypes
     * @methodOf visit.service
     * @returns {Promise<VisitPlan[]>}
     */
    this.getPlans = function(){
      return $http.get(paths.services + '/visit-plans')
        .then(utils.dataOrArray);
    };

    /**
     * @name visit.service.getPlan
     * @methodOf visit.service
     * @param {string} id
     * @returns {Promise<VisitPlan>}
     */
    this.getPlan = function(id){
      return $http.get(paths.services + '/visit-plan', { cache: false, params: { plan_id: id } })
        .then(utils.dataOrObject);
    };

    /**
     * @name visit.service.getPlanTypes
     * @methodOf visit.service
     * @param {Member} [member]
     * @returns {Promise<VisitType[]>}
     */
    this.getPlanTypes = function(member){

      var params = {};

      if (member){
        params.age = member.age;
        params.gender = member.gender;
      }

      return $http.get(paths.services + '/visit-plan/types', { params: params })
        .then(utils.dataOrArray);
    };

    /**
     * @name visit.service.savePlan
     * @methodOf visit.service
     * @param {VisitPlan} plan
     * @returns {Promise<VisitPlan>}
     */
    this.savePlan = function(plan){

      return $http.post(paths.services + '/visit-plan', { plan: plan })
        .then(utils.dataOrObject)
        .catch(function(e){
          console.error(e);
          throw e;
        });
    };

    ///**
    // * @name visit.service.getRecommendationById
    // * @methodOf visit.service
    // * @param {number} id
    // * @returns {Promise<VisitBenefitRecommendation>}
    // */
    //this.getRecommendationById = function(id){
    //  return $http.get(paths.search + '/preventive/recommendations/' + id, { cache: true }).then(utils.dataOrObject);
    //};

    /**
     * @name visit.service.getRecommendationsById
     * @methodOf visit.service
     * @param {number|number[]} ids
     * @returns {Promise<VisitBenefitRecommendation[]>}
     */
    this.getRecommendationsById = function(ids){
      if (_.isNumber(ids)){
        ids = [ids];
      }

      return $http.get(paths.search + '/preventive/recommendations', { params: { ids: ids.join(',') }, cache: true })
        .then(utils.dataOrArray)
        .then(this.translateRecommendations);
    };

    ///**
    // * @name visit.service.getServiceById
    // * @methodOf visit.service
    // * @param {number} id
    // * @returns {Promise<VisitBenefitService>}
    // */
    //this.getServiceById = function(id){
    //  return $http.get(paths.search + '/preventive/services/' + id, { cache: true }).then(utils.dataOrObject);
    //};

    /**
     * @name visit.service.getServicesById
     * @methodOf visit.service
     * @param {number[]} ids
     * @returns {Promise<VisitBenefitService[]>}
     */
    this.getServicesById = function(ids){
      if (_.isNumber(ids)){
        ids = [ids];
      }

      return $http.get(paths.search + '/preventive/services', { params: { ids: ids.join(',') }, cache: true })
        .then(utils.dataOrArray)
        .then(this.translateServices);
    };

    /**
     * @name visit.service.getServices
     * @methodOf visit.service
     * @param {number} age
     * @param {string} gender 'M' or 'F'
     * @param {string} [visitType]
     * @param {boolean} [pregnant=false]
     */
    this.getServices = function(age, gender, visitType, pregnant){
      if (!_.isBoolean(pregnant)){
        pregnant = false;
      }

      return $http.get(paths.search + '/preventive/services', { params: { age: age, gender: gender, visitType: visitType, pregnant: pregnant }, cache: true })
        .then(utils.dataOrArray)
        .then(this.translateServices);
    };

    /**
     * @name visit.service.getRecommendations
     * @methodOf visit.service
     * @param {Object} payload
     * @param {number} payload.age
     * @param {string} payload.visitType 'physical' or 'womanWellness'
     * @param {string} payload.gender 'm' or 'f'
     * @param {boolean} [payload.pregnant=false]
     * @param {string[]} payload.illnesses
     * @param {object} payload.attributes
     * @returns {Promise<VisitBenefitRecommendation[]>}
     */
    this.getRecommendations = function(payload){
      return $http.post(paths.search + '/preventive/recommendations/recommend', payload)
        .then(utils.dataOrArray)
        .then(this.transformRecommendations)
        .then(this.translateRecommendations);
    };

    this.translateRecommendations = function(recommendations){
      return translateService.translate('visitServices')
        .then(function(translations){
          return _.each(recommendations, function(rec){
            var translation = translations[rec.serviceId.toString()] || {};
            rec.serviceName = translation.serviceName;
          });
        });
    };


    this.transformRecommendations = function(responses){
      return _.map(responses, function(response){
        var recommendation = response.recommendation;
        recommendation.strength = response.bestStrength;
        return recommendation;
      });
    };

    /**
     * @name visit.service.attachServicesText
     * @methodOf visit.service
     * @param {VisitBenefitService[]} services
     */
    this.translateServices = function(services){

      if (!_.isArray(services) || !services.length){
        return [];
      }
      var keys = ['serviceName', 'text', 'link'];

      return translateService.translate('visitServices')
        .then(function(translations){
          return _.each(services, function(service){
            var translation = translations[service.id.toString()] || {};
            _.extend(service, _.pick(translation, keys));
          });
        });
    };
  }
  Svc.$inject = ['$q', '$http', 'config.paths', 'utils', 'translate.service'];

  angular.module('visit')
    .service('visit.service', Svc);
}());
'use strict';

angular.module('routes.about', ['ui.router', 'config', 'common', 'translate'])
  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths){
      $stateProvider.state('about', {
        url: '/about',
        parent: 'base',
        templateUrl: paths.partials + '/routes/about/about.html',
        controller: 'routes.about.controller',
        data: {
          htmlClass: 'about-page',
          scrollTop: true,
          pageTitle: 'About Us',
          pageDescription: 'What is a "health insurance recommendation engine"? Come find out.'
        }
      });
    }
  ]);
'use strict';

angular.module('routes.about')
  .controller('routes.about.controller', [
    '$scope',
    'translate.service',
    function($scope, translateService){

      $scope.$watch(
        function(){ return translateService.tryTranslate('about.founders.people') },
        function(people){
          $scope.people = people;
        }
      );

    }
  ]);
angular.module('routes.alex', ['ui.router', 'config', 'translate'])
  .config([
    '$stateProvider',
    'config.paths',

    function($stateProvider, paths) {
      $stateProvider.state('alex', {
        parent: 'base',
        url: '/alex',
        templateUrl: paths.partials + '/routes/alex/alex.html',
        data: {
          scrollTop: true
        },
        controllerAs: 'alexCtrl',
        controller: ['$state', '$scope', 'translate.service', function ($state, $scope, translateService) {
          var self = this;
          this.activeIndex = 0;
          this.videoConfigs = [];
          this.activeVideoConfig = null;

          this.setActiveIndex = function(index){
            this.activeIndex = index;
            this.activeVideoConfig = this.videoConfigs[index];
          };

          translateService.translate('alex')
            .then(function(strings){
              $scope.imageSet = strings.imageSet;
              $scope.scenarios = strings.scenarios;
              $scope.activeScenario = strings.scenarios[0];

              $state.current.data.pageTitle = strings.shareTitle;
              $state.current.data.pageDescription = strings.shareDescription;
              $state.current.data.pageImage = strings.ogImageUrl;

              self.videoConfigs = strings.videos;
              self.setActiveIndex(0);
            });

          $scope.currentSlide = 0;

          $scope.setScenario = function (scenario) {
            $scope.activeScenario = scenario;
          };

          $scope.hideLightbox = function () {
            $scope.showModal = false;
          };

          $scope.showLightbox = function (index) {
            $scope.modalInit = true;
            $scope.showModal = true;
            $scope.currentSlide = index;
          };

        }]
      });
    }
  ]);
(function(){

  /**
   * @namespace routes.bor
   */

  /**
   * @name routes.bor.config
   * @param {ui.router.state.$stateProvider} $stateProvider
   * @param {config} config
   * @constructor
   */

  function BorConfig($stateProvider, config){
    var partials = config.paths.partials;
    var stepKeyPrefix = 'brokerOfRecord.steps.';

    $stateProvider
      .state('bor', {
        url: '/add-my-insurance?source',
        parent: 'sidebar',
        //abstract: true,
        redirectTo: 'bor.intro',
        views: {
          'main@sidebar': {
            templateUrl: partials + '/routes/bor/bor.html',
            controller: 'routes.bor.controller as bor'
          },
          'side@sidebar': {
            templateUrl: partials + '/components/sidebar/steps/default.html',
            controller: 'sidebar.steps.controller as stepsController'
          },
          'steps@bor': {
            templateUrl: partials + '/components/sidebar/steps/mobile.html',
            controller: 'sidebar.steps.controller as stepsController'
          }
        },
        data: {
          scrollTop: true,
          authenticate: true,
          invalidState: 'bor.intro',
          steps: [
            {
              name: 'bor.intro',
              key: stepKeyPrefix + 'start',
              propsSet: []
            },
            {
              name: 'bor.source',
              key: stepKeyPrefix + 'source',
              propsSet: ['geo', 'onExchange', 'source']
            },
            {
              name: 'bor.carrier',
              key: stepKeyPrefix + 'carrier',
              propsSet: ['carrier']
            },
            {
              name: 'bor.plan',
              key: stepKeyPrefix + 'plan',
              propsSet: ['plan']
            },
            {
              name: 'bor.coverage',
              key: stepKeyPrefix + 'details',
              propsSet: ['premium', 'coverageStart']
            },
            {
              name: 'bor.choose',
              key: stepKeyPrefix + 'confirm',
              propsSet: []
            },
            {
              name: 'bor.basic',
              key: stepKeyPrefix + 'info',
              propsSet: []
            },
            {
              name: 'bor.specific',
              key: stepKeyPrefix + 'policy',
              propsSet: ['memberId']
            },
            {
              name: 'bor.eSign',
              key: stepKeyPrefix + 'esign',
              propsSet: ['eSignDate']
            }
          ]
        },
        resolve: {
          PrimaryMember: ['baseUser', 'member.service', function(userModel, memberService){
            return memberService.getPrimary(userModel)
              .catch(function(){
                return {};
              });
          }]
        }
      })
      .state('bor.intro', {
        url: '/intro',
        templateUrl: partials + '/routes/bor/intro.html',
        data: {
          next: 'bor.source'
        }
      })
      .state('bor.inProgress', {
        url: '/not-yet',
        templateUrl: partials + '/routes/bor/unsupported.html',
        data: {
          next: 'dashboard'
        }
      })
      .state('bor.source', {
        url: '/source',
        templateUrl: partials + '/routes/bor/source/source.html',
        controller: 'routes.bor.sourceCtrl as sourceCtrl',
        data: {
          next: 'bor.carrier'
        }
      })
      .state('bor.carrier', {
        url: '/carrier',
        templateUrl: partials + '/routes/bor/carrier/carrier.html',
        controller: 'routes.bor.carrierCtrl as carrierCtrl',
        data: {
          next: 'bor.plan'
        },
        resolve: {
          states: ['search.geo', function(geoSearch){
            return geoSearch.getStates();
          }]
        }
      })
      .state('bor.plan', {
        url: '/plan',
        templateUrl: partials + '/routes/bor/plan/plan.html',
        controller: 'routes.bor.planCtrl as planCtrl',
        data: {
          next: 'bor.coverage'
        },
        resolve: {
          plans: ['plan.search', 'routes.bor.model', function(planSearch, borModel){
            return planSearch.getForCarrier(borModel.get('carrier'));
          }]
        }
      })
      .state('bor.coverage', {
        url: '/coverage',
        templateUrl: partials + '/routes/bor/coverage/coverage.html',
        controller: 'routes.bor.coverageCtrl as coverageCtrl',
        data: {
          next: 'bor.choose'
        }
      })
      .state('bor.choose', {
        url: '/choose',
        templateUrl: partials + '/routes/bor/choose/choose.html',
        data: {
          next: 'bor.basic',
          quitState: 'dashboard'
        }
      })
      .state('bor.choose.info', {
        views: {
          explain: {
            templateUrl: partials + '/routes/bor/explain.html'
          }
        }
      })
      .state('bor.basic', {
        url: '/basics',
        templateUrl: partials + '/routes/bor/basic/basic.html',
        controller: 'routes.bor.basicCtrl as basicCtrl',
        data: {
          next: 'bor.specific'
        }
      })
      .state('bor.specific', {
        url: '/policy',
        templateUrl: partials + '/routes/bor/specific/specific.html',
        //controller: 'routes.bor.specificCtrl as specificCtrl',
        data: {
          next: 'bor.eSign'
        }
      })
      .state('bor.eSign', {
        url: '/e-sign',
        templateUrl: partials + '/routes/bor/e-sign/e-sign.html',
        controller: 'routes.bor.eSignCtrl as eSignCtrl',
        data: {
          next: 'bor.complete'
        }
      })
      .state('bor.eSign.info', {
        views: {
          'explain': {
            templateUrl: partials + '/routes/bor/explain.html'
          }
        }
      })
      .state('bor.complete', {
        url: '/complete',
        templateUrl: partials + '/routes/bor/complete.html',
        data: {
          next: 'dashboard',
          persist: true
        }
      })
      .state('bor.support', {
        url: '/support',
        templateUrl: partials + '/routes/bor/support.html',
        data: {
          next: 'dashboard',
          persist: true
        }
      });

  }

  BorConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.bor', ['ui.router', 'config', 'search', 'plan', 'user', 'sidebar', 'translate', 'routes.bor.landing', 'notification', 'session', 'member'])
    .config(BorConfig);

}());

(function(){

  /**
   * @name routes.bor.controller
   * @param {ui.router.state.$state} $state
   * @param {*} $stateParams
   * @param {ng.$rootScope.Scope} $scope
   * @param {routes.bor.model} borModel
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl($state, $stateParams, $scope, borModel, trackingService){
    var self = this;
    var steps = $state.getData().steps;
    this.model = borModel;
    this.next = $state.goNext;

    trackingService.setPeopleProps({
      'Broker of Record Start Source': $stateParams.source || 'Dashboard'
    }, true);

    $scope.$on('$stateChangeSuccess', function($event, toState){
      var props = [];
      var stepIndex = getStepIndex(toState);
      if (stepIndex > -1){
        props = _.flatten(_.pluck(steps.slice(0, getStepIndex(toState)), 'propsSet'));
      }

      var isValid = borModel.isValid(props);
      self.render = isValid;

      if (!isValid){
        $state.go($state.getData().invalidState);
      }
    });

    $scope.$on('$stateChangeStart', function($event, toState, toStateParams, fromState){
      if (isBorState(toState) && isBorState(fromState)){
        var fromStepIndex = getStepIndex(fromState);
        if (fromStepIndex > -1){
          borModel.save(steps[fromStepIndex].propsSet || []);
        }
      }
    });

    function getStepIndex(state){
      return _.findIndex(steps, function(step){
        return step.name && state.name.indexOf(step.name) === 0;
      });
    }
    function isBorState(state){
      return state && _.isString(state.name) && state.name.indexOf('bor') === 0;
    }
  }
  Ctrl.$inject = ['$state', '$stateParams', '$scope', 'routes.bor.model', 'services.tracking'];

  angular.module('routes.bor')
    .controller('routes.bor.controller', Ctrl);
}());
(function(){

  /**
   * @name routes.bor.model
   * @param {session} session
   * @constructor
   */
  function Model(session){
    var sessionKey = 'bor';
    var isObject = _.isObject;
    var isString = _.isString;


    /**
     * @typedef {Object} BorModelData
     * @property {boolean} onExchange
     * @property {Object} source
     * @property {Address} geo
     * @property {Carrier} carrier
     * @property {HealthPlan} plan
     * @property {string} dob
     * @property {string} firstName
     * @property {string} lastName
     * @property {string} memberId
     * @property {string} coverageStart
     * @property {number} premium
     * @property {Date} eSignDate
     */

    /**
     * @name routes.bor.model.data
     * @memberOf routes.bor.model
     * @type {BorModelData}
     */
    this.data = {
      onExchange: null,
      source: null,
      geo: null,
      carrier: null,
      plan: null,
      dob: null,
      firstName: null,
      lastName: null,
      memberId: null,
      coverageStart: null,
      premium: null,
      eSignDate: null
    };

    this.dataKeys = _.keys(this.data);

    /**
     * @name routes.bor.model.validators
     * @memberOf routes.bor.model
     * @type {Object<string, Function>}
     */
    this.validators = {
      onExchange: _.isBoolean,
      source: isObject,
      geo: isObject,
      carrier: isObject,
      plan: isObject,
      dob: isString,
      firstName: isString,
      lastName: isString,
      memberId: isString,
      eSignDate: _.isDate,
      coverageStart: isString,
      premium: _.isNumber
    };

    /**
     * @name routes.bor.model.optionalKeys
     * @memberOf routes.bor.model
     * @type {string[]}
     */
    this.optionalKeys = [ 'memberId', 'eSignDate', 'coverageStart', 'premium' ];

    /**
     * @name routes.bor.model.restore
     * @methodOf route.bor.model
     * @param {Object} borData
     */
    this.restore = function(borData){
      if (isObject(borData)){
        this.dataKeys.forEach(function(key){
          if (!_.isUndefined(borData[key])){
            this.data[key] = borData[key];
          }
        }, this);
      }
    };

    /**
     * @name routes.bor.model.set
     * @methodOf route.bor.model
     * @param {string} key
     * @param {*} value
     * @returns {boolean}
     */
    this.set = function(key, value){
      if (value === null || this.validate.apply(this, arguments)){
        this.data[key] = value;
        return true;
      }

      return false;
    };

    /**
     * @name routes.bor.model.get
     * @methodOf routes.bor.model
     * @param {string} path
     * @param {*} defaultValue
     * @returns {*}
     * @type Function
     */
    this.get = _.partial(_.get, this.data);

    /**
     * @name routes.bor.model.validate
     * @methodOf route.bor.model
     * @param {string} key
     * @param {*} value
     * @returns {boolean}
     */
    this.validate = function(key, value){
      return this.validators[key] &&
          // consider it valid if it passes it's validator
          // or if it is optional and hasn't been set
        (this.validators[key](value) || (_.contains(this.optionalKeys, key) && _.isEmpty(value)));
    };

    /**
     * @name routes.bor.model.isValid
     * @methodOf route.bor.model
     * @param {string[]} [keys]
     * @returns {boolean}
     */
    this.isValid = function(keys){
      if (!_.isArray(keys)){
        keys = this.dataKeys;
      }

      if (keys.length === 0){
        return true;
      }

      return _.every(keys, function(key){
        // consider it valid if it passes it's validator
        var isValid = this.validate(key, this.data[key]);
        
        if (!isValid){
          console.log(key, this.data[key]);
        }

        return isValid;
      }, this);
    };

    /**
     * @name routes.bor.model.save
     * @methodOf route.bor.model
     * @param {string[]} [keys]
     * @returns {boolean}
     */
    this.save = function(keys){
      if (!_.isArray(keys)){
        keys = this.dataKeys;
      }

      if (!this.isValid(keys)){
        return false;
      }

      session.set(sessionKey, this.data, keys);
      return true;
    };

    /**
     * @name routes.bor.model.clear
     * @methodOf route.bor.model
     */
    this.clear = function(){
      session.remove(sessionKey);
    };

    // try to restore from saved data in the session
    this.restore(session.get(sessionKey) || null);
  }
  Model.$inject = ['session'];


  angular.module('routes.bor')
    .service('routes.bor.model', Model);
}());
angular.module('routes.buy', [
    'ui.router',
    'config',
    'user',
    'search',
    'translate',
    'scrollTo',
    'plan',
    'questions',
    'billing',
    'application',
    'cart',
    'dental',
    'member'
  ])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {
      var partials = paths.partials;
      var partialBase = partials + '/routes/buy/';

      $stateProvider
        .state('buy', {
          url: '/apply',
          parent: 'purchase',
          controller: 'routes.buy.controller as buy',
          templateUrl: partialBase + 'buy.html',

          data: {
            scrollTop: true,
            authenticate: true,
            unAuthState: 'planAccount.create',
            step: 'apply'
          },
          resolve: {
            plan: ['baseUser', 'baseHealthApp', function (userModel, applicationModel) {
              return applicationModel.getPlan();
            }],
            isOep: ['services.date', 'baseHealthApp', function (dateService, applicationModel) {
              return dateService.isOepAsync({
                onExchange: applicationModel.hasSubsidy(),
                state: applicationModel.getState()
              });
            }]
          }
        })

        .state('buy.qualify', {
          url: '/qualify',
          controller: 'profile.qualify.controller',
          templateUrl: partials + '/components/profile/qualify/event.html',
          data: {
            status: 'qualify',
            nextState: 'buy.address'
          }
        })

        .state('buy.qualify.date', {
          url: '/date',
          templateUrl: partials + '/components/profile/qualify/event-date.html'
        })

        .state('buy.address', {
          url: '/address',
          controller: 'routes.buy.address.controller',
          templateUrl: partialBase + 'application/address.html',
          data: {
            status: 'address',
            showBackToPlan: true
          }
        })
        .state('buy.address.priceChange', {
          url: '/change/:oldPrice/:newPrice',
          templateUrl: partialBase + 'application/price-change.html',
          data: {
            nextState: 'buy.applicants'
          }
        })
        .state('buy.applicants', {
          url: '/applicants',
          controller: 'routes.buy.applicants.controller as applicantsCtrl',
          templateUrl: partialBase + 'application/applicants.html',
          data: {
            status: 'applicants'
          }
        })
        .state('buy.applicants.member', {
          url: '/:memberId',
          controller: 'routes.buy.applicants.member.controller as memberDetailCtrl',
          templateUrl: paths.partials + '/components/member/member-detail.html',
          data: {
            backState: 'buy.applicants',
            backKey: 'shared.buttons.cancel'
          }
        })
        .state('buy.applicants.priceChange', {
          url: '/change/:oldPrice/:newPrice',
          templateUrl: partialBase + 'application/price-change.html',
          data: {
            nextState: 'buy.extras'
          }
        })

        //.state('buy.extras', {
        //  url: '/extras',
        //  templateUrl: partialBase + 'extras/extras.html',
        //  controller: 'routes.buy.extras.controller',
        //  data: {
        //    status: 'extras',
        //    nextState: 'buy.billing'
        //  },
        //  resolve: {
        //    questions: ['baseUser', 'application.model', 'application.service', function(baseUser, applicationModel, applicationService){
        //      return applicationService.getExtras(applicationModel);
        //    }],
        //    applicants: ['baseHealthApp', function(applicationModel){
        //      return applicationModel.getMembers();
        //    }]
        //  }
        //})
        //.state('buy.extras.question', {
        //  url: '/:steps',
        //  controller: 'questions.question.controller',
        //  templateUrl: partials + '/components/questions/question.html',
        //  resolve: {
        //    baseModel: ['baseHealthApp', function(applicationModel){
        //      return applicationModel.getExtras();
        //    }]
        //  }
        //})

        .state('buy.billing', {
          url: '/billing',
          controller: 'billing.combined.controller',
          templateUrl: partials + '/components/billing/debit.html',
          data: {
            status: 'billing',
            nextState: 'buy.confirm',
            postBilling: true
          }
        })
        .state('buy.billing.credit', {
          url: '/credit',
          templateUrl: partials + '/components/billing/credit.html'
        })
        .state('buy.billing.notAccepted', {
          url: '/not-accepted',
          templateUrl: partials + '/components/billing/not-accepted.html'
        })

        .state('buy.confirm', {
          url: '/agreement',
          controller: 'routes.buy.confirm.controller',
          templateUrl: partialBase + 'confirm/confirm.html',
          data: {
            status: 'confirm'
          }
        })
        .state('buy.eSign', {
          url: '/e-sign',
          controller: 'profile.eSign.controller',
          templateUrl: partials + '/components/profile/e-sign/e-sign.html'
        })

        .state('buy.submitted', {
          url: '/complete',
          controller: 'routes.buy.submitted.controller as submittedCtrl',
          templateUrl: partialBase + 'submitted/submitted.html'
        });
    }
  ]);
angular.module('routes.buy')
  .controller('routes.buy.controller', [
    '$scope',
    '$state',
    '$timeout',
    '$interval',
    '$filter',
    'utils',
    'baseUser',
    'baseHealthApp',
    'application.service',
    'services.auth',
    'cart.service',
    'logger',
    'services.date',
    'plan', /* need to wait for the plan resolve */
    'isOep',
    function ($scope, $state, $timeout, $interval, $filter, utils, userModel, applicationModel, applicationService,
              authService, cartService, logger, dateService, plan, isOep) {

      if (!cartService.apps || !cartService.apps.length){
        return $state.replace('cart');
      }

      this.render = false;
      var currentState = $state.current;
      var stepOrder = $scope.steps.apply.steps;
      var redirectStateName = null;
      var inBuyFlow = false;

      $scope.navItems = stepOrder;
      $scope.application = applicationModel.get();
      $scope.cartPlan = cartService;

      var checkRedirect = function (toState) {

        // let auth service take care of rerouting here
        if (!authService.isAuthenticated()) {
          return;
        }

        //var application = applicationModel.get();
        //var status = applicationModel.getStatus();
        //if (status === 'application' || status === 'onboarding') {
        //  status = 'address';
        //}
        //var appStatusState = $state.get(getFullStateName(status));
        //var stepIndex = getStepIndex(toState.data.status);
        //var now = new Date();
        var plan = applicationModel.getPlan();

        // if there's no plan, we can bail immediately
        if (!applicationModel.hasPlan()) {
          return redirect('recommended');
        }

        // wipe the plan off if returning customer's plan is 2015 and it's no longer SEP
        else if (!plan.planYear || plan.planYear < 2016) {
          applicationModel.setPlan(userModel, null);
          return redirect('recommended');
        }

        // they're logged in, qualified and picked a subsidy
        //else if (applicationModel.getPlan().qhpStatus && applicationModel.hasSubsidy()) {

        //we just care about qhpStatus now
        else if (applicationModel.getPlan().qhpStatus) {
          return redirect('subsidy');
        }

        // if they have a 2015 plan
        // or if they've picked a 2016 plan and it's not open enrollment yet
        //else if (plan.planYear === 2015 || (plan.planYear === 2016 && now.getFullYear() !== 2016 && !isOpenEnrollment)) {
        //  return redirect(getFullStateName('preOep'));
        //}

        inBuyFlow = true;

        if (!isOep && !applicationModel.hasLifeEvent()) {
          return redirect(getFullStateName('qualify'));
        }

        // send to beginning
        //else {
        return redirect(getFullStateName('address'));
        //}

        //// if app status doesn't allow them to be in the state
        //else if (stepIndex === -1 || stepIndex > getStepIndex(status)){
        //  return redirect((appStatusState && appStatusState.name) || getFullStateName(stepOrder[0].key));
        //}

        //else {
        //  return redirect(getFullStateName(stepOrder[0].key));
        //}

        //return false;
      };

      // initial landing on a "buy" page, make sure status allows them to be there
      checkRedirect(currentState);
      this.render = true;

      if (inBuyFlow){
        $scope.$on('$destroy', function(){
          if (!$state.is('cart')){
            cartService.clearApps();
          }
        });
      }

      function redirect(toStateName) {
        var doRedirect = false;
        if (!$state.includes(toStateName) && redirectStateName !== toStateName) {
//          console.log('rerouting to ' + toStateName);
          doRedirect = true;
          redirectStateName = toStateName;
          $state.replace(toStateName);
        }


        return doRedirect;
      }
      //
      //function getStepIndex(status) {
      //  return utils.indexOf(stepOrder, function (step) {
      //    return step.key === status;
      //  });
      //}

      function getFullStateName(partialName) {
        return 'buy.' + partialName;
      }

    }
  ]);
angular.module('routes.cart', ['ui.router', 'cart', 'plan', 'common', 'search', 'routes.subsidy'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {

      $stateProvider.state('cart', {
        url: '/cart?offer',
        //templateUrl: paths.partials + '/routes/cart/cart.html',
        //controller: 'routes.cartCtrl as cartCtrl',
        parent: 'base',
        templateUrl: paths.partials + '/routes/cart/cart.html',
        controller: 'routes.cartCtrl as cartCtrl',
        //views: {
        //  '': {
        //
        //  }
        //  //'purchase@cart': {
        //  //  templateUrl: paths.partials + '/routes/cart/cart-purchase.html',
        //  //  //controller: 'routes.cartCtrl as cartCtrl',
        //  //},
        //  //'progress@cart': {
        //  //  templateUrl: paths.partials + '/routes/cart/cart-progress.html',
        //  //  //controller: 'routes.cartCtrl as cartCtrl',
        //  //}
        //},
        resolve: {
          Deadline: ['baseHealthApp', 'plan.deadlineSvc', function (healthApp, planDeadlineSvc) {
            return planDeadlineSvc.getStateEnrollment(healthApp);
          }],
          EffectiveDate: ['baseHealthApp', 'services.date', function (healthApp, dateService) {
            return dateService.getEffectiveDate({
              onExchange: healthApp.hasSubsidy(),
              state: healthApp.getState()
            });
          }],
          Apps: ['cart.service', function(cartService){
            return cartService.getApps();
          }],
          FFMWrapperActive: ['routes.ffm.service', function(ffmService){
            return ffmService.getConfig()
              .then(function(config){
                return config.isActive;
              });
          }]
        },
        data: {
          authenticate: true,
          unAuthState: 'planAccount.create',
          scrollTop: true,
          step: 'plan'
        }
      });
    }
  ]);

(function () {

  /**
   * @name routes.cartCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {user.model} userModel
   * @param {cart.service} cartService
   * @param {services.tracking} trackingService
   * @param {{ stateConfig: object, enrollment: EnrollmentPeriod, periods: { current: EnrollmentPeriod, next: EnrollmentPeriod } }} Deadline
   * @param {Date} EffectiveDate
   * @param {application.model} applicationModel
   * @param {ifp_app[]} Apps
   * @param {boolean} FFMWrapperActive
   * @param {member.service} memberService
   * @param {application.service} applicationService
   * @param {address.service} addressService
   */
  function Ctrl($q, $state, userModel, cartService, trackingService, Deadline, EffectiveDate, applicationModel, Apps, FFMWrapperActive, memberService, applicationService, addressService) {
    var self = this;
    this.render = false;
    this.enrollment = Deadline.periods.current;
    this.enrollmentPeriods = Deadline.periods;
    this.stateConfig = Deadline.stateConfig;
    this.apps = Apps;

    if (!Apps.length){
      return $state.replace('dashboard');
    }

    // skip all cart/checkout routes and go just to ffm
    if (this.stateConfig && this.stateConfig.ffm && !FFMWrapperActive &&
      applicationModel.hasSubsidy() &&
      applicationModel.hasPlan() && applicationModel.getPlan().qhpStatus === true) {
      return $state.replace('ffm');
    }

    var healthApp = cartService.getAppByType('health');
    var dentalApp = cartService.getAppByType('dental');
    this.dentalApp = dentalApp;

    this.hasDentalIncluded = function () {
      return _.get(healthApp, 'plan.adultDental') === true;
    };

    this.hasPlanType = function (type) {
      return cartService.hasAppType(type)
    };

    this.getAppLength = function () {
      return cartService.apps.length;
    };

    this.shouldDisable = function () {
      return cartService.apps.length === 0;
    };

    if (_.isArray(Apps) && Apps.length) {
      trackingService.mixpanelEvent(trackingService.propEnum.cartView, cartService.getTrackingPayload());
    }

    this.goNextJustHealth = function () {
      // Remove the dental plan as the health plan has dental already
      if (dentalApp) {
        cartService.removeApp(userModel, dentalApp.app_id);
      }
      $state.go('buy');
    };

    this.addDental = function () {
      return applicationService.getWorking(userModel, 'dental')
        .then(function (app) {
          if (!app) {
            return applicationService.createWithResources({}, null, healthApp.members, null, null, 'dental');
          }

          return app;
        })
        .then(function (app) {
          if (app.address) {
            return app;
          }

          return addressService.saveForApp(userModel, app.app_id, healthApp.address)
            .then(function (address) {
              app.address = address;
              return app;
            });
        })
        .then(function (app) {
          return $state.go('dental.location', { source: 'cart' });
        });
    };

    // check to see if any members were removed from the health app but are still on the dental app
    //if (dentalApp && healthApp){
    //
    //  var invalidApplicants = _.reject(dentalApp.applicants, function(dentalApplicant){
    //    return !!_.findWhere(healthApp.applicants, { id: dentalApplicant.id });
    //  });
    //
    //  if (invalidApplicants.length){
    //    this.membersChanged = true;
    //    dentalApp.members = _.difference(dentalApp.applicants, invalidApplicants);
    //  }
    //
    //  dentalService.getSortedPlans(cartService.getAddress().state, planUtils.getApplicantParams(dentalApp.members))
    //    .then(function(plans){
    //      var match = _.find(plans, function(detail){
    //        return detail.plan && detail.plan.id === dentalApp.plan.id;
    //      });
    //
    //      if (!match){
    //        self.invalidDental = true;
    //      }
    //      else if (match.totalMonthlyPremium !== dentalApp.premiumMonth){
    //        self.priceChanged = true;
    //        dentalApp.premiumMonth = match.totalMonthlyPremium;
    //      }
    //
    //      self.render = true;
    //    });
    //}
    //
    //else {
    //  self.render = true;
    //}

    this.render = true;

    this.goNext = function () {

      if (cartService.hasAppType('health')) {
        return $state.go('buy');
      }
      else {
        return $state.go('checkout');
      }

      //var requests = [];
      //
      //if (this.membersChanged){
      //  requests[0] = memberService.saveForApp(userModel, dentalApp.app_id, dentalApp.members)
      //    .then(function (response) {
      //      if (response) {
      //        trackingService.setPeopleProp(trackingService.propEnum.dentalMembers, response.count);
      //      }
      //    });
      //}
      //
      //if (this.priceChanged){
      //  requests[1] = applicationService.postPlan(userModel, dentalApp.app_id, dentalApp.plan);
      //}
      //
      //return $q.all(requests)
      //  .then($state.go('buy'));
    };

    this.removeDentalPlan = function (nextState) {
      return applicationService.deletePlan(userModel, dentalApp.app_id)
        .then(function () {
          $state.go(nextState);
        });
    };
    //cartService.checkPriceChanges();
  }

  Ctrl.$inject = ['$q', '$state', 'baseUser', 'cart.service', 'services.tracking', 'Deadline', 'EffectiveDate', 'baseHealthApp', 'Apps', 'FFMWrapperActive', 'member.service', 'application.service', 'address.service'];

  angular.module('routes.cart')
    .controller('routes.cartCtrl', Ctrl);
}());

/**
 * @namespace routes.checkout
 */
angular.module('routes.checkout', ['ui.router', 'member', 'application', 'common', 'cart', 'address', 'billing', 'user', 'bor'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {
      var partials = paths.partials;
      var checkoutPartials = partials + '/routes/checkout';

      $stateProvider.state('checkout', {
        url: '/checkout',
        parent: 'sidebar',
        views: {
          'main@sidebar': {
            templateUrl: checkoutPartials + '/checkout.html',
            controller: 'routes.checkoutCtrl as checkoutCtrl'
          },
          'side@sidebar': {
            templateUrl: partials + '/components/sidebar/steps/default.html',
            controller: 'sidebar.steps.controller as stepsController'
          },
          'steps@checkout': {
            templateUrl: partials + '/components/sidebar/steps/mobile.html',
            controller: 'sidebar.steps.controller as stepsController'
          }
        },
        resolve: {
          CartApps: ['baseUser', 'cart.service', function(userModel, cartService){
            return cartService.getApps();
          }]
        },
        data: {
          scrollTop: true,
          authenticate: true,
          steps: [
            {
              name: 'checkout.address',
              text: 'Home address'
            },
            {
              name: 'checkout.members',
              text: 'Member details'
            },
            {
              name: 'checkout.billing',
              text: 'Billing information'
            },
            {
              name: 'checkout.legal',
              text: 'Legal agreements'
            },
            {
              name: 'checkout.eSign',
              text: 'E-signature'
            },
            {
              name: 'checkout.complete',
              text: 'Confirmation'
            }
          ]
        }
      })
        .state('checkout.address', {
          url: '/address',
          controller: 'routes.checkout.addressCtrl as addressCtrl',
          templateUrl: checkoutPartials + '/address/address.html',
          data: {
            next: 'checkout.members'
          }
        })
        .state('checkout.members', {
          url: '/members',
          controller: 'routes.checkout.membersCtrl as membersCtrl',
          templateUrl: checkoutPartials + '/members/members.html',
          data: {
            next: 'checkout.billing'
          }
        })
        .state('buy.members.member', {
          url: '/:memberId',
          controller: 'routes.checkout.member.detailCtrl as memberDetailCtrl',
          templateUrl: checkoutPartials + '/members/member.html',
          data: {
            backState: 'buy.members',
            backKey: 'shared.buttons.cancel'
          }
        })
        .state('checkout.billing', {
          url: '/billing',
          controller: 'routes.checkout.billingCtrl as billingCtrl',
          templateUrl: checkoutPartials + '/billing/billing.html',
          data: {
            next: 'checkout.legal'
          }
        })
        .state('checkout.billing.credit', {
          url: '/credit',
          templateUrl: checkoutPartials + '/billing/credit.html'
        })
        .state('checkout.billing.debit', {
         url: '/checking',
         templateUrl: checkoutPartials + '/billing/debit.html'
        })
        .state('checkout.billing.debit.credit', {
          redirectTo: 'checkout.billing.credit'
        })
        .state('checkout.legal', {
          url: '/legal',
          controller: 'routes.checkout.legalCtrl as legalCtrl',
          templateUrl: checkoutPartials + '/legal/legal.html',
          data: {
            next: 'checkout.eSign'
          }
        })
        .state('checkout.eSign', {
          url: '/e-sign',
          controller: 'routes.checkout.eSignCtrl as eSignCtrl',
          templateUrl: checkoutPartials + '/e-sign/e-sign.html',
          data: {
            next: 'checkout.complete'
          }
        })
        .state('checkout.complete', {
          url: '/complete',
          controller: 'routes.checkout.completeCtrl as completeCtrl',
          templateUrl: checkoutPartials + '/complete/complete.html'
        });
    }
  ]);

(function(){

  /**
   * @name routes.checkoutCtrl
   * @param {ui.router.state.$state} $state
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function CheckoutCtrl($state, CartApps){
    this.apps = CartApps;
    this.render = true;

    if (!CartApps.length){
      return $state.replace('cart');
    }

    this.carriers = _.map(CartApps, function(app){
      return _.get(app, 'app_json.plan.carrier');
    });

    // TODO: this is just for ease of development. remove this check and always start at address
    if ($state.is('checkout')){
      $state.replace('checkout.address');
    }
  }
  CheckoutCtrl.$inject = ['$state', 'CartApps'];

  angular.module('routes.checkout')
    .controller('routes.checkoutCtrl', CheckoutCtrl);
}());
angular.module('routes.cms', ['ui.router', 'config', 'content'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function($stateProvider, $urlRouterProvider, paths){

      $urlRouterProvider
        .when('/jobs', '/jobs/open-positions')
        .when('/legal', '/legal/privacy-policy');

      createSection('legal');
      createSection('jobs');
      createSection('guide', '/health-insurance/guide', '/routes/cms/guide-section.html');

      function createSection(stateName, stateUrl, mainTemplateUrl){
        $stateProvider
          .state(stateName, {
            parent: 'sidebar',
            url: stateUrl || ('/' + stateName),
            data: {
              scrollTop: true
            },
            resolve: {
              sectionModel: ['content.service', function(contentService){
                return contentService.resolveSection(stateName);
              }]
            },
            views: {
              'main@sidebar': {
                templateUrl: paths.partials + (mainTemplateUrl || '/routes/cms/section.html'),
                controller: sectionController(stateName)
              },
              'side@sidebar': {
                templateUrl: paths.partials + '/routes/cms/sidebar.html',
                controller: sectionController(stateName)
              }
            }
          })
          .state(stateName + '.page', {
            url: '/:pageKey',
            templateUrl: paths.partials + '/routes/cms/page.html',
            controller: ['$scope', '$state', '$stateParams', 'content.service', function($scope, $state, $stateParams, contentService){
              var page = contentService.getPageByKey($scope.sectionModel, $stateParams.pageKey);
              $scope.page = page;

              if (page.fields){
                $state.current.data.pageTitle = $scope.sectionModel.fields.name + ' - ' + page.fields.title;
                $state.current.data.pageDescription = page.fields.description;
              }
            }]
          })
          .state(stateName + '.page.subPage', {
            url: '/:subPageKey',
            templateUrl: paths.partials + '/routes/cms/subPage.html',
            controller: ['$scope', '$state', '$stateParams', 'content.service', function($scope, $state, $stateParams, contentService){
              var subPage = contentService.getSubPageByKey($scope.sectionModel, $stateParams.pageKey, $stateParams.subPageKey);
              $scope.subPage = subPage;

              if (subPage.fields){
                $state.current.data.pageTitle = $scope.sectionModel.fields.name + ' - ' + $scope.page.fields.title + ' - ' + subPage.fields.title;
                $state.current.data.pageDescription = subPage.fields.description;
              }

            }]
          });
      }

      function sectionController(stateName){
        return ['$scope', '$state', 'sectionModel', function($scope, $state, sectionModel){
          $scope.stateName = stateName;
          $scope.sectionModel = sectionModel;

          $state.current.data.pageTitle = sectionModel.fields.name;
          $state.current.data.pageDescription = sectionModel.fields.description;
        }];
      }
    }
  ]);
(function () {

  /** @namespace routes.dashboard */

  function DashboardConfig($stateProvider, config) {
    var partials = config.paths.partials;
    var dashboardPartials = partials + '/routes/dashboard';

    $stateProvider
      .state('dashboard', {
        url: '/dashboard',
        parent: 'sidebar',
        views: {
          'main@sidebar': {
            templateUrl: dashboardPartials + '/dashboard.html',
            controller: 'routes.dashboard.controller as dashboard'
          },
          'side@sidebar': {
            templateUrl: dashboardPartials + '/nav.html',
            controller: 'routes.dashboard.nav.controller as dashboardNav'
          },
          'finance@dashboard': {
            templateUrl: dashboardPartials + '/finance-tracker/sub-section.html',
            controller: 'routes.dashboard.financeTrackerCtrl as financeCtrl'
          },
          'visitPlans@dashboard': {
            templateUrl: dashboardPartials + '/visits/sub-section.html',
            controller: 'routes.dashboard.visitsCtrl as visitsCtrl'
          },
          'health-preview@dashboard': {
            templateUrl: dashboardPartials + '/health/preview/main.html',
            controller: 'routes.dashboard.health.controller as healthCtrl'
          },
          'dental-preview@dashboard': {
            templateUrl: dashboardPartials + '/dental/preview/main.html',
            controller: 'routes.dashboard.dental.controller as dentalCtrl'
          },
          'new-app@dashboard': {
            templateUrl: dashboardPartials + '/health/new-plan.html',
            controller: 'application.newCtrl as newCtrl'
          },
          'drugs@dashboard': {
            templateUrl: dashboardPartials + '/drugs/preview.html',
            controller: 'routes.dashboard.drugs.controller as drugsController'
          }
        },

        data: {
          scrollTop: true,
          authenticate: true,
          previewModule: true
        },
        resolve: {
          stateConfig: ['baseHealthApp', 'search.geo', function (applicationModel, geoSearch) {
            var state = applicationModel.getState();
            if (!state) {
              return null;
            }

            return geoSearch.getStateConfig(state);
          }],
          EnrollmentPeriods: ['services.date', 'baseHealthApp', function (dateService, applicationModel) {
            return dateService.getEnrollmentPeriods({
              onExchange: applicationModel.hasSubsidy(),
              state: applicationModel.getState() || 'CA'
            });
          }],
          isOep: ['EnrollmentPeriods', function (enrollmentPeriods) {
            return enrollmentPeriods.current && enrollmentPeriods.current.period_type === 'oep';
          }],
          DentalApps: ['baseUser', 'application.service', function (userModel, applicationService) {
            return applicationService.query(userModel, {type: 'dental'});
          }],
          ActiveHealth: ['baseUser', 'application.service', function (userModel, applicationService) {
            if (userModel.activeAppId){
              return applicationService.getActive(userModel, 'health');
            }

            return applicationService.getWorking(userModel, 'health');
          }],
          ActiveBor: ['baseUser', 'bor.service', function(userModel, borService){
            return borService.getLatest();
          }],
          //Notifications: ['baseUser', 'notification.service', function(userModel, notificationService){
          //  return notificationService.get({ userId: userModel.getId(), read: false })
          //    .catch(function(err){
          //      return [];
          //    });
          //}],
          DrugHealthCtx: ['ActiveHealth', 'baseHealthApp', 'health.app', 'userDrugModel', function (ActiveHealth, currentHealthApp, healthApp, userDrugModel) {
            var model = currentHealthApp;

            if (ActiveHealth) {
              model = new healthApp();
              model.setFromDb(ActiveHealth);
            }
            userDrugModel.setHealthApp(model);

            return model;
          }]
        }
      })
      .state('dashboard.coverage', {
        abstract: true,
        url: '/coverage',
        template: '<div ui-view></div>'
      })
      .state('dashboard.care', {
        abstract: true,
        url: '/care',
        template: '<div ui-view></div>'
      })
      .state('dashboard.care.drugs', {
        url: '/drugs',
        controller: 'routes.dashboard.drugs.controller as drugsController',
        templateUrl: dashboardPartials + '/drugs/drugs.html',
        data: {
          previewModule: false
        }
      })
      .state('dashboard.care.drugs.pharmacy', {
        url: '/:drugId',
        controller: 'pharmacy.detail.controller as pharmacyDetailController',
        templateUrl: dashboardPartials + '/drugs/pharmacy.html',
        resolve: {
          pharmacy: ['$stateParams', 'drug.service', 'baseUser', function ($stateParams, drugService, userModel) {
            return drugService.getAllForUser(userModel)
              .then(function(allDrugs){
                var drug = _.findWhere(allDrugs, { id: +$stateParams.drugId });
                return _.get(drug, 'drug_json.pharmacy', null);
              });
          }]
        }
      })
      .state('dashboard.care.drugs.edit', {
        url: '/edit',
        abstract: true,
        templateUrl: partials + '/routes/drug/pick.html',
        controller: 'drug.picker.controller',
        data: {
          invalidState: 'dashboard.care.drugs'
        }
      })
      .state('dashboard.care.drugs.edit.dose', {
        url: '/dose',
        controller: 'drug.dose.controller as doseController',
        templateUrl: partials + '/routes/drug/pick-dose.html',
        data: {
          nextState: 'dashboard.care.drugs.edit.quantity'
        }
      })
      .state('dashboard.care.drugs.edit.quantity', {
        url: '/quantity',
        controller: 'drug.fill.controller as fillController',
        templateUrl: partials + '/routes/drug/pick-fill.html',
        data: {
          nextState: 'dashboard.care.drugs.edit.refills'
        }
      })
      .state('dashboard.care.drugs.edit.refills', {
        url: '/fill-count',
        controller: 'drug.refill.controller as refillController',
        templateUrl: partials + '/routes/drug/pick-refills.html',
        data: {
          nextState: 'dashboard.care.drugs.edit.pharmacy'
        }
      })
      .state('dashboard.care.drugs.edit.pharmacy', {
        url: '/pharmacy',
        templateUrl: partials + '/routes/drug/pick-pharmacy-list.html',
        controller: 'pharmacy.list.controller as pharmacyListController',
        data: {
          nextState: 'dashboard.care.drugs.edit.pharmacy.detail'
        }
      })
      .state('dashboard.care.drugs.edit.pharmacy.detail', {
        url: '/detail',
        templateUrl: partials + '/routes/drug/pick-pharmacy.html',
        controller: 'pharmacy.detail.controller as pharmacyDetailController',
        data: {
          nextState: 'dashboard.care.drugs.edit.complete'
        },
        resolve: {
          pharmacy: ['drug.editor', function (drugEditor) {
            return drugEditor.getPharmacy();
          }]
        }
      })
      .state('dashboard.care.drugs.edit.complete', {
        url: '/complete',
        template: '',
        controller: ['$scope', '$state', 'drug.editor', 'drug.service', 'baseUser', function ($scope, $state, drugEditor, drugService, userModel) {
          var self = this;
          var drug = drugEditor.complete();
          self.drugs = $scope.drugsController.drugs;

          drugService.saveDrug(userModel, drug)
            .then(function (response) {
              if (response) {
                var index = _.findIndex(self.drugs, { id: response.id });
                if (index > -1) {
                  self.drugs[index] = response;
                } else {
                  self.drugs.push(response);
                }
              }

              $state.replace('dashboard.care.drugs');
            });
        }]
      })
      .state('dashboard.care.doctors', {
        url: '/doctors',
        templateUrl: dashboardPartials + '/doctors/doctors.html',
        controller: 'routes.dashboard.doctors.controller as doctorsController',
        data: {
          previewModule: false
        },
        resolve: {
          PrimaryMember: ['member.service', 'baseUser', function (memberService, userModel) {
            return memberService.getPrimary(userModel);
          }],
          UserDoctors: ['doctor.service', 'baseUser', 'ActiveHealth', function (doctorService, userModel, ActiveHealth) {
            return doctorService.getMergedForUser(userModel, _.get(ActiveHealth, 'app_json.plan.networkId', null));
          }]
        }
      })
      .state('dashboard.care.doctors.search', {
        url: '/search',
        views: {
          '': {
            templateUrl: dashboardPartials + '/doctors/search/template.html'
          },
          'search@dashboard.care.doctors.search': {
            templateUrl: partials + '/components/doctor/search/form.html',
            controller: 'routes.dashboard.doctor.searchCtrl as searchCtrl'
          },
          'results@dashboard.care.doctors.search': {
            templateUrl: partials + '/components/doctor/search/results/list.html',
            controller: 'routes.dashboard.doctor.resultsCtrl as resultsCtrl'
          }
        },
        data: {
          termPlaceholder: 'profile.placeholders.addDoc',
          geoPlaceholder: 'visit.plan.doctor.geoPlaceholder'
        },
        params: {
          previousState: '^'
        }
      });
  }

  DashboardConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.dashboard', ['ui.router', 'config', 'search', 'user', 'application', 'drug', 'doctor', 'financeTracker', 'health',
      'routes.dashboard.health',
      // 'routes.dashboard.financeTracker', 
      'routes.dashboard.visits', 'routes.dashboard.dental', 'routes.dashboard.document', 'notification', 'member', 'bor'])
    .config(DashboardConfig);

}());

(function () {

  /**
   * @name dashboard.controller
   * @param {ng.$rootScope.scope} $scope
   * @param {user.model} userModel
   * @param {application.model} applicationModel
   * @param {ifp_app} ActiveHealth
   * @param {boolean} isOep
   * @param {config.service} configService
   * @param {ifp_app[]} DentalApps
   * @param {dashboard.service} dashboardService
   * @param {broker_of_record} ActiveBor
   * @constructor
   */
  function DashboardController($scope, userModel, applicationModel, ActiveHealth, isOep,
                               configService, DentalApps, dashboardService, ActiveBor) {

    var self = this;
    var optIn = userModel.getSetting('optIn') || {};
    var showConfirm = {};
    var hasExternalPlan = !!userModel.bor;

    userModel.setActiveHealth(ActiveHealth);
    this.service = dashboardService;
    this.user = userModel;

    // Notifications
    //this.notifications = Notifications;

    self.dismissWelcome = function () {
      userModel.setSetting('dashWelcome', false);
      self.showWelcome = false;
    };

    if (userModel.getSetting('dashWelcome') === null) {
      self.showWelcome = true;
      userModel.setSetting('dashWelcome', true);
    } else {
      self.dismissWelcome();
    }

    self.getName = applicationModel.getPrimary() && applicationModel.getPrimary().name && applicationModel.getPrimary().name.first;

    self.health = {
      isOpenEnrollment: isOep,
      externalPlan: hasExternalPlan,
      showXSell: !(applicationModel.hasPlan() || hasExternalPlan)
    };

    self.shouldShowOptIn = function (type) {
      return optIn[type] !== true;
    };

    self.shouldShowConfirm = function (type) {
      return showConfirm[type] === true;
    };

    self.optIn = function (type) {
      optIn[type] = showConfirm[type] = true;
      userModel.setSetting('optIn', optIn);
    };

    self.showReturnBtn = configService.isEnabled('returnBtn');

    self.brand = configService.getBrand();
    self.financeSettings = userModel.getSetting('finance') || {};
    //self.financeEnabled = !configService.isProd() || self.financeSettings.enabled;
    self.financeEnabled = self.financeSettings.enabled;

    if (configService.isPartner() && !configService.isEnabled('finance')) {
      this.hideFinance = true;
    }

    $scope.$on('$stateChangeStart', function($event, toState){
      if (toState.name === 'chat'){
        $event.preventDefault();

        if (window.zE){
          window.zE.activate();
        }
      }
    });

    $scope.$on('$stateChangeSuccess', function(){
      self.isBorLatest = dashboardService.isBorLatest(ActiveHealth, applicationModel, ActiveBor);
    });

    self.render = true;
  }

  DashboardController.$inject = ['$scope', 'baseUser', 'baseHealthApp', 'ActiveHealth', 'isOep',
    'config.service', 'DentalApps', 'dashboard.service', 'ActiveBor'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.controller', DashboardController);
}());

// This should contain logic for pulling in notification count
// and possibly restricting different parts of the navigation
// based on logged in / verification status

(function () {

  /**
   * @param {user.model} userModel
   * @param {config.service} configService
   * @param {dashboard.service} dashboardService
   * @param {application.model} applicationModel
   * @param {ifp_app[]} DentalApps
   * @param {document.service} documentService
   * @param {ifp_app} ActiveHealth
   * @constructor
   */
  function DashboardNavController(userModel, configService, dashboardService, applicationModel, DentalApps, documentService, ActiveHealth) {
    var self = this;

    //this.financeSettings = userModel.getSetting('finance') || {};
    //this.financeEnabled = !configService.isProd() || this.financeSettings.enabled;
    //
    //if (configService.isPartner() && !configService.isEnabled('finance')) {
    //  this.financeEnabled = false;
    //}

    this.service = dashboardService;
    this.appSubmitted = applicationModel.isComplete();
    this.showDental = !!_.find(DentalApps, function (app) {
      return app.submitted_on !== null && !app.cancel_date;
    });

    documentService.getDocTags({ appId: ActiveHealth.app_id })
      .then(function (response) {
        if (response && response.length && response.length > 0) {
          self.showDoc = true;
        }
      });
  }

  DashboardNavController.$inject = ['baseUser', 'config.service', 'dashboard.service', 'baseHealthApp', 'DentalApps', 'document.service', 'ActiveHealth'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.nav.controller', DashboardNavController);
}());
(function(){
  /**
   * @name dashboard.service
   */
  function DashboardService(){
    /**
     * @name dashboard.service.completedHealthApps
     * @memberOf dashboard.service
     * @type {ifp_app[]}
     */
    this.completedHealthApps = [];

    /**
     * @name dashboard.service.hasVisitPlans
     * @memberOf dashboard.service
     * @type {boolean}
     */
    this.hasVisitPlans = false;

    /**
     * @name dashboard.service.isBorLatest
     * @methodOf dashboard.service
     * @param {ifp_app} activeHealth
     * @param {ifp_app} currentHealth
     * @param {broker_of_record} activeBor
     * @returns {boolean}
     */
    this.isBorLatest = function(activeHealth, currentHealth, activeBor){
      var result = false;
      if (activeBor && activeBor.e_sign_date){
        var borEsignDate = new Date(activeBor.e_sign_date);
        var healthSubmittedOnDate = activeHealth.submitted_on ? new Date(activeHealth.submitted_on) : null;

        if (
          (currentHealth.app_id !== activeHealth.app_id || !_.get(activeHealth, 'ifp_enroll_statuses[0].isComplete', false)) &&
          currentHealth.members && currentHealth.members.length){
          result = false;
        }
        else if (!_.isDate(healthSubmittedOnDate)){
          result = true;
        }
        else {
          result = borEsignDate.getTime() > healthSubmittedOnDate.getTime();
        }
      }

      return result;
    };
  }
  DashboardService.$inject = [];
  angular.module('routes.dashboard').service('dashboard.service', DashboardService);
}());

angular.module('routes.dental', ['ui.router', 'search', 'translate', 'snackbar', 'dental', 'cart', 'member', 'doctor'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function ($stateProvider, $urlRouterProvider, paths) {
      var partialBase = paths.partials;

      $stateProvider
        .state('dentalLanding', {
          parent: 'base',
          url: '/get-dental',
          templateUrl: partialBase + '/routes/dental/landing/template.html',
          controller: 'routes.dental.landingCtrl as landingCtrl'
        })
        .state('dental', {
          url: '/dental?source',
          redirectTo: 'dental.location',
          parent: 'sidebar',
          //controller: 'routes.dental.controller as dentalCtrl',
          //templateUrl: partialBase + '/routes/dental/dental.html',
          views: {
            'main@sidebar': {
              templateUrl: partialBase + '/routes/dental/dental.html',
              controller: 'routes.dental.controller as dentalCtrl'
            },
            'side@sidebar': {
              templateUrl: partialBase + '/components/sidebar/steps/default.html',
              controller: 'sidebar.steps.controller as stepsController'
            },
            'steps@dental': {
              templateUrl: partialBase + '/components/sidebar/steps/mobile.html',
              controller: 'sidebar.steps.controller as stepsController'
            }
          },
          data: {
            scrollTop: true,
            steps: [
              {
                name: 'dental.location',
                key: 'dental.text.nav.location'
              },
              {
                name: 'dental.family',
                key: 'dental.text.nav.family'
              },
              {
                name: 'dental.dentists',
                key: 'dental.text.nav.dentists'
              },
              {
                name: 'dental.plans',
                key: 'dental.text.nav.plans'
              }
            ]
          },

          resolve: {
            DentalApp: ['baseUser', 'application.service', function (userModel, applicationService) {
              return applicationService.getWorking(userModel, 'dental')
                .then(function(dentalApp){
                  // if there's no incomplete dental app, make one
                  if (!dentalApp || !dentalApp.app_id || applicationService.isComplete(dentalApp)){
                    return applicationService.save(userModel, { type: 'dental' });
                  }
                  return dentalApp;
                });
            }]
          }
        })
        .state('dental.location', {
          url: '/location?zipcode',
          controller: 'routes.dental.location.controller as locationCtrl',
          templateUrl: partialBase + '/routes/dental/location/location.html'
        })
        .state('dental.family', {
          url: '/family',
          controller: 'routes.dental.family.controller as familyCtrl',
          templateUrl: partialBase + '/routes/dental/family/family.html',
          resolve: {
            AllMembers: ['baseUser', 'member.service', function(userModel, memberService){
              return memberService.get(userModel);
            }]
          }
        })
        .state('dental.family.member', {
          url: '/member/:memberId',
          data: {
            backState: 'dental.family',
            backKey: 'shared.buttons.cancel'
          },
          controller: 'member.detail.controller as memberDetailCtrl',
          templateUrl: partialBase + '/components/member/member-detail.html'
        })
        .state('dental.dentists', {
          url: '/dentists',
          controller: 'routes.dental.dentists.controller as dentistsCtrl',
          templateUrl: partialBase + '/routes/dental/dentists/dentists.html'
        })
        .state('dental.dentists.search', {
          url: '/search',
          views: {
            '': {
              templateUrl: partialBase + '/routes/ob/doctors/search.html'
            },
            'search@dental.dentists.search': {
              templateUrl: partialBase + '/components/doctor/search/form.html',
              controller: 'dentist.searchCtrl as searchCtrl'
            },
            'results@dental.dentists.search': {
              templateUrl: partialBase + '/components/doctor/search/results/list.html',
              controller: 'routes.dentist.resultsCtrl as resultsCtrl'
            }
          },
          data: {
            termPlaceholder: 'dental.placeholders.addDentists',
            geoPlaceholder: 'visit.plan.doctor.geoPlaceholder'
          }
        })
        .state('dental.plans', {
          url: '/plans',
          controller: 'routes.dental.plan.controller as planCtrl',
          templateUrl: partialBase + '/routes/dental/plan/list/plan.html',
          resolve: {
            DentalPlans: ['plan.utils', 'DentalApp', 'dental.service',
              function (planUtils, DentalApp, dentalService) {
                var memberDemos = planUtils.getApplicantParams(DentalApp.members);
                var address = _.get(DentalApp, 'address.state');
                return dentalService.getSortedPlans(address, memberDemos);
              }]
          }
        })
        .state('dental.plans.detail', {
          url: '/detail/{id:int}',
          controller: 'routes.dental.plan.detail.controller as detailCtrl',
          templateUrl: partialBase + '/routes/dental/plan/detail/detail.html',
          data: {
            backState: 'dental.plans',
            backKey: 'dental.buttons.back.toPlanList'
          }
        });
    }
  ]);

(function () {
  function Ctrl($scope) {
  }
  Ctrl.$inject = ['$scope'];

  angular.module('routes.dental')
    .controller('routes.dental.controller', Ctrl);
}());

(function(){

  /**
   * @name routes.doctor
   * @param {ui.router.state.$stateProvider} $stateProvider
   * @param {config} config
   * @constructor
   */
  function DoctorConfig($stateProvider, config){
    var partials = config.paths.partials;
    var pathBase = partials + '/routes/doctor';
    $stateProvider
      .state('doctor', {
        parent: 'base',
        templateUrl: pathBase + '/index.html',
        data: {
          scrollTop: true
        },
        resolve: {
          ActiveHealth: ['baseUser', function(userModel){
            return userModel.fetchActiveHealth();
          }]
        }
      })
      .state('doctor.search', {
        url: '/find-a-doctor',
        views: {
          '': {
            templateUrl: pathBase + '/landing/landing.html',
            controller: 'routes.doctor.landingCtrl as landingCtrl'
          },
          'search@doctor.search': {
            templateUrl: partials + '/components/doctor/search/mobile-form.html',
            controller: 'routes.doctor.searchCtrl as searchCtrl'
          },
          'results@doctor.search': {
            templateUrl: pathBase + '/landing/results.html',
            controller: 'doctor.resultsCtrl as resultsCtrl'
          }
        },
        data: {
          settings: {
            pageSize: 3,
            trackingCategory: 'provider_search'
          },
          termPlaceholder: 'visit.plan.doctor.termPlaceholder',
          geoPlaceholder: 'visit.plan.doctor.geoPlaceholder'
        }
      })
      .state('doctor.profile', {
        url: '/provider/:id',
        templateUrl: pathBase + '/profile/profile.html',
        controller: 'routes.doctor.profileCtrl as profileCtrl',
        resolve: {
          doctor: ['$stateParams', 'doctor.service', 'ActiveHealth', function($stateParams, doctorService, ActiveHealth){
            return doctorService.getDetails(+$stateParams.id, _.get(ActiveHealth, 'app_json.plan.networkId'));
          }],
          isSaved: ['$stateParams', 'doctor.service', 'baseUser', function($stateParams, doctorService, userModel){
            return doctorService.existsForUser(userModel, $stateParams.id);
          }]
        }
      })
      .state('doctor.account', {
        url: '/provider/account',
        abstract: true,
        templateUrl: config.paths.partials + '/routes/user/account/account.html',
        data: {
          source: 'providers'
        }
      })
      .state('doctor.account.create', {
        url: '/create',
        templateUrl: config.paths.partials + '/routes/user/account/create.html',
        controller: 'user.login.controller',
        data: {
          errorState: 'doctor.account.login',
          successState: 'dashboard.care.doctors'
        }
      })
      .state('doctor.account.login', {
        url: '/login',
        templateUrl: config.paths.partials + '/routes/user/account/login.html',
        controller: 'user.login.controller',
        data: {
          successState: 'dashboard.care.doctors'
        }
      });

  }
  DoctorConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.doctor', ['ui.router', 'doctor', 'config'])
    .config(DoctorConfig);
}());
/**
 * @namespace routes.drive
 */
angular.module('routes.drive', ['ui.router', 'search', 'translate'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function ($stateProvider, $urlRouterProvider, paths) {

      $stateProvider
        .state('drive', {
          url: '/drive',
          controller: 'routes.drive.controller as driveCtrl',
          templateUrl: paths.partials + '/routes/drive/drive.html',
          resolve: {
            user: ['user.service', function(userService){
              return userService.get();
            }]
          },
          data: {
            scrollTop: true
          }
        });
    }
  ]);
(function () {

  /**
   * @name routes.drive.controller
   * @param $timeout
   * @param $filter
   * @param config
   * @param textingService
   * @param subscriptionService
   * @param user
   * @param branchService
   * @param {services.tracking} trackingService
   * @constructor
   */
  // Need user depdency to do a get for csrf token
  function Ctrl($timeout, $filter, config, textingService, subscriptionService, user, branchService, trackingService) {
    var self = this;
    var baseUrl = config.paths.services;
    this.phoneNumber = '';
    this.email = '';
    this.showEmailInput = false;

    /**
     * @name routes.drive.controller.sendText
     * @methodOf routes.drive.controller
     */
    this.sendText = function () {
      //disable text button until post responds or error occurs
      self.disableTextButton = true;

      branchService.getData()
        .then(function (data) {
          return textingService.sendText(self.phoneNumber, data.referring_link)
            .then(function (response) {
              //Successful text send
              if (response.status === 200) {
                self.textMessage = 'Check your texts for a link to download Stride Drive';
              }
            })
        })
        .catch(function (response) {
          if (response.status === 422) {
            self.textMessage = 'Please enter a valid phone number';
          } else {
            if (response.config.data.phone.length === 10) {
              self.textMessage = 'We were unable to send a text to ' + $filter('tel')(response.config.data.phone) + '. Please verify your number is correct or try again later';
            } else {
              self.textMessage = 'Please enter a valid phone number';
            }
          }

        })
        .finally(function () {
          // Add timeout so spinner shows for at least a second
          self.disableTextButton = false;
        });
    };

    /**
     * @name routes.drive.controller.subscribe
     * @methodOf routes.drive.controller
     */
    this.subscribe = function () {
      subscriptionService.subscribe(this.email, ['stride-drive-android'])
        .then(function (response) {
          // Successful add to subscription list
          if (response.status === 201) {
            self.subscribeMessage = 'We will notify you at ' + self.email + ' when the android app is ready';
          }
        })
        .catch(function (response) {
          switch (response.status) {
            case 404:
              var isAddedAlready = response.data && response.data.message && response.data.message.indexOf('Subscription already exists') >= 0;
              self.subscribeMessage = isAddedAlready ? self.email + " has already been signed up" : 'An error has occurred. Please try again later';
              break;
            case 422:
              self.subscribeMessage = 'Please enter a valid email address';
              break;
            default:
              self.subscribeMessage = 'An error has occurred';
              return;
          }
        });
    };

    trackingService.trackLP('Drive');
  }

  Ctrl.$inject = ['$timeout', '$filter', 'config', 'services.texting', 'services.subscription', 'user', 'services.branch', 'services.tracking'];

  angular.module('routes.drive')
    .controller('routes.drive.controller', Ctrl);
}());
angular.module('routes.error', ['ui.router', 'common', 'user'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function($stateProvider, $urlRouterProvider, paths){

      $urlRouterProvider.otherwise('/error/404');

      function createRoute(errorStatus, controller){
        var routeObject = {
          parent: 'error',
          url: '/' + errorStatus,
          templateUrl: paths.partials + '/routes/error/' + errorStatus + '.html'
        };

        if (controller){
          routeObject.controller = controller;
        }

        $stateProvider.state(errorStatus, routeObject);
      }

      $stateProvider
        .state('error', {
          abstract: true,
          parent: 'base',
          url: '/error',
          templateUrl: paths.partials + '/routes/error/error.html'
        });

      //createRoute('403', 'user.login.controller');
      createRoute('404');
      createRoute('500');
      createRoute('unverified', 'user.unverified.controller');
      createRoute('invalid-region');
      createRoute('409');
    }
  ]);
//(function(){
//  /**
//   * @name routes.finance
//   * @param {ui.router.state.$stateProvider} $stateProvider
//   * @param {config} config
//   * @constructor
//   */
//  function Config($stateProvider, config){
//    var pathBase = config.paths.partials + '/routes/finance';
//    var componentBase = config.paths.partials + '/components/finance-tracker';
//    var stepKeyPrefix = 'finance.steps.';
//
//    $stateProvider
//      .state('financeTracker', {
//        parent: 'sidebar',
//        url: '/finance',
//        data: {
//          scrollTop: true,
//          authenticate: true,
//          steps: [
//            {
//              name: 'financeTracker',
//              //text: 'Get Started'
//              key: stepKeyPrefix + 'getStarted'
//            },
//            {
//              name: 'financeTracker.income.source',
//              //text: 'Choose income source'
//              key: stepKeyPrefix + 'incomeSource'
//            },
//            {
//              name: 'financeTracker.income.amount',
//              //text: 'Enter income amount'
//              key: stepKeyPrefix + 'incomeAmount'
//            },
//            {
//              name: 'financeTracker.income.summary',
//              //text: 'Income summary'
//              key: stepKeyPrefix + 'incomeSummary'
//            },
//            {
//              name: 'financeTracker.expense.source',
//              //text: 'Choose expense source'
//              key: stepKeyPrefix + 'expenseSource'
//            },
//            {
//              name: 'financeTracker.expense.amount',
//              //text: 'Enter expense amount'
//              key: stepKeyPrefix + 'expenseAmount'
//            },
//            {
//              name: 'financeTracker.expense.summary',
//              //text: 'Earnings summary'
//              key: stepKeyPrefix + 'earningsSummary'
//            }
//          ]
//        },
//        resolve: {
//          categories: ['financeTracker.service', function(financeService){
//            return financeService.getCategories();
//          }]
//        },
//        views: {
//          'main@sidebar': {
//            templateUrl: pathBase + '/finance.html',
//            controller: 'routes.financeTrackerCtrl as financeCtrl'
//          },
//          'side@sidebar': {
//            templateUrl: config.paths.partials + '/components/sidebar/steps/default.html',
//            controller: 'sidebar.steps.controller as stepsController'
//          },
//          'steps@finance': {
//            templateUrl: config.paths.partials + '/components/sidebar/steps/mobile.html',
//            controller: 'sidebar.steps.controller as stepsController'
//          }
//        }
//      })
//
//      // Income routes
//      .state('financeTracker.income', {
//        url: '/income',
//        template: '<div ui-view></div>',
//        redirectTo: 'financeTracker.income.source',
//        data: {
//          doneState: 'financeTracker.income.summary'
//        }
//      })
//      .state('financeTracker.income.source', {
//        url: '/source',
//        templateUrl: componentBase + '/income/source/source.html',
//        controller: 'financeTracker.income.sourceCtrl as sourceCtrl',
//        data: {
//          headline: 'finance.income.source.headline',
//          nextState: 'financeTracker.income.amount'
//        }
//      })
//      .state('financeTracker.income.source.other', {
//        url: '/other',
//        templateUrl: componentBase + '/income/source/other.html'
//      })
//      .state('financeTracker.income.amount', {
//        url: '/amount',
//        templateUrl: componentBase + '/amount/amount.html',
//        controller: 'financeTracker.amountCtrl as amountCtrl',
//        data: {
//          headline: 'finance.income.amount.headline',
//          doneCtaText: 'finance.income.amount.doneCta',
//          moreCtaText: 'finance.income.amount.moreCta',
//          nextState: '^.summary'
//        }
//      })
//      .state('financeTracker.income.summary', {
//        url: '/summary',
//        templateUrl: pathBase + '/income-summary.html',
//        controller: 'financeTracker.summaryCtrl as summaryCtrl'
//      })
//
//      // Expense routes
//      .state('financeTracker.expense', {
//        url: '/expense',
//        template: '<div ui-view></div>',
//        redirectTo: 'financeTracker.expense.source',
//        data: {
//          doneState: 'financeTracker.expense.summary'
//        }
//      })
//
//      .state('financeTracker.expense.source', {
//        url: '/source',
//        templateUrl: componentBase + '/expense/source/source.html',
//        controller: 'financeTracker.expense.sourceCtrl as sourceCtrl',
//        data: {
//          headline: 'finance.expense.source.headline',
//          nextState: 'financeTracker.expense.amount'
//        }
//      })
//      .state('financeTracker.expense.source.other', {
//        url: '/other',
//        templateUrl: componentBase + '/expense/source/other.html'
//      })
//      .state('financeTracker.expense.amount', {
//        url: '/amount',
//        templateUrl: componentBase + '/amount/amount.html',
//        controller: 'financeTracker.amountCtrl as amountCtrl',
//        data: {
//          headline: 'finance.expense.amount.headline',
//          doneCtaText: 'finance.expense.amount.doneCta',
//          moreCtaText: 'finance.expense.amount.moreCta',
//          nextState: '^.summary'
//        }
//      })
//      .state('financeTracker.expense.summary', {
//        url: '/summary',
//        templateUrl: pathBase + '/expense-summary.html',
//        controller: 'financeTracker.summaryCtrl as summaryCtrl'
//      });
//  }
//  Config.$inject = ['$stateProvider', 'config'];
//
//  angular.module('routes.financeTracker', ['ui.router', 'config', 'common', 'financeTracker'])
//    .config(Config);
//}());

//(function(){
//
//  /**
//   * @name routes.financeTrackerCtrl
//   * @constructor
//   */
//  function Ctrl(){
//
//  }
//
//  angular.module('routes.financeTracker')
//    .controller('routes.financeTrackerCtrl', Ctrl);
//
//}());
(function () {

  function DrugsConfig($stateProvider, config) {
    var partials = config.paths.partials;

    function resolveHealthApp(userModel, currentHealthApp, healthApp) {
      return userModel.fetchActiveHealth()
        .then(function (activeHealthApp) {

          if (activeHealthApp && activeHealthApp.app_json) {
            var model = new healthApp();
            model.setFromDb(activeHealthApp);
            return model;
          }

          return currentHealthApp;
        });
    }

    $stateProvider
      .state('drugLanding', {
        url: '/prescriptions',
        parent: 'base',
        templateUrl: partials + '/routes/drug/landing.html',
        controller: 'routes.drug.landing.controller as drugLanding',
        data: {
          scrollTop: true
        },
        resolve: {
          HealthApp: ['baseUser', 'baseHealthApp', 'health.app', resolveHealthApp]
        }
      })

      .state('drug', {
        url: '/drug',
        parent: 'sidebar',
        abstract: true,
        data: {
          scrollTop: true
        },
        resolve: {
          HealthApp: ['baseUser', 'baseHealthApp', 'health.app', resolveHealthApp]
        }
      })

      .state('drug.picker', {
        url: '/pick',
        abstract: true,

        data: {
          invalidState: 'drug.picker.search',
          steps: [
            {
              name: 'drug.picker.search',
              text: 'Find a drug'
            },
            {
              name: 'drug.picker.dose',
              text: 'Choose dosage'
            },
            {
              name: 'drug.picker.quantity',
              text: 'Choose quantity'
            },
            {
              name: 'drug.picker.refills',
              text: 'Choose refills'
            },
            {
              name: 'drug.picker.pharmacy',
              text: 'Find pharmacy'
            }
          ]
        },
        views: {
          'main@sidebar': {
            templateUrl: partials + '/routes/drug/pick.html',
            controller: 'drug.picker.controller'
          },
          'side@sidebar': {
            templateUrl: partials + '/components/sidebar/steps/default.html',
            controller: 'sidebar.steps.controller as stepsController'
          }
        }
      })

      .state('drug.picker.search', {
        url: '/search',
        controller: 'routes.drug.landing.controller as drugLandingController',
        templateUrl: partials + '/routes/drug/pick-drug.html',
        data: {
          nextState: 'drug.picker.dose'
        }
      })

      .state('drug.picker.dose', {
        url: '/dose',
        controller: 'drug.dose.controller as doseController',
        templateUrl: partials + '/routes/drug/pick-dose.html',
        data: {
          nextState: 'drug.picker.quantity'
        }
      })

      //.state('drug.picker.freq', {
      //  url: '/frequency',
      //  controller: 'drug.frequency.controller as freqController',
      //  templateUrl: partials + '/routes/drug/pick-freq.html',
      //  data: {
      //    nextState: 'drug.picker.fillSize'
      //  }
      //})
      //
      //.state('drug.picker.fillSize', {
      //  url: '/fill-size',
      //  controller: 'drug.fillSize.controller as fillSizeController',
      //  templateUrl: partials + '/routes/drug/pick-size.html',
      //  data: {
      //    nextState: 'drug.picker.refills'
      //  }
      //})

      .state('drug.picker.quantity', {
        url: '/quantity',
        controller: 'drug.fill.controller as fillController',
        templateUrl: partials + '/routes/drug/pick-fill.html',
        data: {
          nextState: 'drug.picker.refills'
        }
      })

      .state('drug.picker.refills', {
        url: '/fill-count',
        controller: 'drug.refill.controller as refillController',
        templateUrl: partials + '/routes/drug/pick-refills.html',
        data: {
          nextState: 'drug.picker.pharmacy'
        }
      })

      .state('drug.picker.pharmacy', {
        url: '/pharmacy',
        templateUrl: partials + '/routes/drug/pick-pharmacy-list.html',
        controller: 'pharmacy.list.controller as pharmacyListController',
        data: {
          nextState: 'drug.picker.pharmacy.detail'
        }
      })

      .state('drug.picker.pharmacy.detail', {
        url: '/detail',
        templateUrl: partials + '/routes/drug/pick-pharmacy.html',
        controller: 'pharmacy.detail.controller as pharmacyDetailController',
        data: {
          nextState: 'drug.picker.create'
        },
        resolve: {
          pharmacy: ['drug.editor', function (drugEditor) {
            return drugEditor.getPharmacy();
          }]
        }
      })
      .state('drug.picker.complete', {
        url: '/complete',
        template: '',
        controller: ['$scope', '$state', 'drug.editor', 'services.tracking', 'drug.service', 'baseUser',
          function ($scope, $state, drugEditor, trackingService, drugService, userModel) {
            var drug = drugEditor.complete();
            var model = drug.drug_json;
            if (model && model.dose && model.fillQty && model.durationDays) {
              drugService.saveDrug(userModel, drug)
                .then(function (response) {
                  if (response) {
                    //Mixpanel prescriptions
                    trackingService.incrementPeopleProp(trackingService.propEnum.drugs);
                  }
                  $state.replace('dashboard.care.drugs');
                })
            }
            else {
              $state.replace('drugLanding');
            }
          }]
      })

      .state('drug.picker.create', {
        url: '/create-account',
        templateUrl: partials + '/routes/refer/create-account.html',
        controller: 'user.login.controller',
        data: {
          successState: 'drug.picker.complete',
          errorState: 'drug.picker.login',
          source: 'prescriptions'
        }
      })
      .state('drug.picker.login', {
        url: '/login',
        templateUrl: partials + '/routes/refer/login.html',
        controller: 'user.login.controller',
        data: {
          successState: 'drug.picker.complete'
        }
      });
  }

  DrugsConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.drug', ['ui.router', 'drug', 'config', 'search', 'user', 'health'])
    .config(DrugsConfig);
}());
(function(){

  /**
   * @name drug.landing.controller
   * @param {ui.router.state.$state} $state
   * @param {ng.$scope} $scope
   * @param {drug.user.model} userDrugModel
   * @param {health.app} HealthApp
   * @param {drug.editor} drugEditor
   * @param {services.tracking} trackingService
   */
  function DrugLandingController($state, $scope, userDrugModel, HealthApp, drugEditor, trackingService){

    userDrugModel.setHealthApp(HealthApp);
    drugEditor.clear();

    $scope.$on('drug-select', function($event, drug){
      drugEditor.setDrug(drug);
      $state.go('drug.picker.dose');
    });

    trackingService.trackLP('Prescriptions');
  }
  DrugLandingController.$inject = ['$state', '$scope', 'userDrugModel', 'HealthApp', 'drug.editor', 'services.tracking'];

  angular.module('routes.drug')
    .controller('routes.drug.landing.controller', DrugLandingController);
}());
(function(){

  function PharmacyDetailController(googleMaps, userDrugModel, pharmacy){

    if (!pharmacy){
      return;
    }

    var self = this;

    this.showPhone = false;
    this.pharmacy = pharmacy;
    this.center = {
      lat: pharmacy.address.lat,
      lng: pharmacy.address.lng
    };

    self.directionsUrl = '';

    userDrugModel.getGeo()
      .then(function(address){
        self.directionsUrl = googleMaps.getDirectionsUrl(pharmacy.address, address);
      });

  }
  PharmacyDetailController.$inject = ['google.maps', 'drug.user.model', 'pharmacy'];

  angular.module('routes.drug')
    .controller('pharmacy.detail.controller', PharmacyDetailController);
}());
(function () {

  /**
   * Pharmacy list controller
   * @name pharmacy.list.controller
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {search.geo} geoService
   * @param {drug.editor} drugEditor
   * @param {drug.service} drugService
   * @param {drug.user.model} userDrugModel
   * @param {google.maps} googleMaps
   */
  function PharmacyListController($q, $state, geoService, drugEditor, drugService, userDrugModel, googleMaps) {
    var self = this;

    /**
     * @returns {boolean}
     */
    this.canGeoLocate = geoService.canGeoLocate;

    /**
     * @type {drug.pharmacyResult[]}
     */
    this.pharmacies = [];

    /**
     * @type {Address}
     */
    this.geo = null;

    this.fetching = true;

    /**
     * @type {number}
     */
    this.positionError = null;

    /**
     * @type {form.FormController}
     */
    this.geoForm = null;

    /**
     * @type {boolean}
     */
    this.showGeoForm = false;

    this.zipcode = '';
    this.street = '';


    // grab the initial list of pharmacies
    userDrugModel.getGeo()
      .then(function (address) {
        self.setGeo(address);
      });

    this.submitGeoForm = function () {
      if (this.geoForm && this.geoForm.$valid) {
        self.fetching = true;
        self.showGeoForm = false;
        $q.all([
            googleMaps.getAddress({address: self.street + ', ' + self.zipcode}),
            geoService.getByZip(self.zipcode)
          ])
          .then(function (addresses) {
            var googleAddress = addresses[0];
            var strideAddress = addresses[1][0] || {};

            self.setGeo(_.extend(strideAddress, googleAddress));
          });
      }
    };

    this.setGeo = function (address) {
      // make sure not to modify address from userModel or applicationModel
      address = angular.copy(address);
      self.geo = address;
      self.zipcode = address.zipcode;
      self.street = address.street;
      userDrugModel.setGeo(address);
      self.setPharmacies(address);
    };

    this.geoLocate = function () {
      self.fetching = true;
      var googleAddress;

      geoService.geoLocate()
        .then(function (address) {
          self.showGeoForm = false;
          googleAddress = address;
          return geoService.getByZip(address.zipcode);
        })
        .then(function (strideAddresses) {
          self.setGeo(_.extend(strideAddresses[0], googleAddress));
        })
        .catch(function (error) {
          self.fetching = false;
          self.positionError = error && error.code || 1;
        });
    };

    this.setPharmacies = function (address) {
      return drugService.getPharmacies(drugEditor.getModel(), address, userDrugModel.getHealthApp())
        .then(function (pharmacies) {
          self.pharmacies = self.sortPharmacies(pharmacies);
          self.fetching = false;
        })
        .catch(function (error) {
          self.pharmacies = [];
          self.fetching = false;
        });
    };

    this.choose = function (pharmacy) {
      drugEditor.setPharmacy(pharmacy);
      $state.go($state.current.data.nextState);
    };

    this.sortPharmacies = function (pharmacies) {

      pharmacies.sort(function (a, b) {
        var result = Math.round(a[a.lowestPrice + 'Price']) - Math.round(b[b.lowestPrice + 'Price']);

        // if price is same, sort based on distance instead
        if (result === 0) {
          return a.distanceMi - b.distanceMi;
        }

        return result;
      });

      return pharmacies;
    };


  }

  PharmacyListController.$inject = ['$q', '$state', 'search.geo', 'drug.editor', 'drug.service', 'userDrugModel', 'google.maps'];

  angular.module('routes.drug')
    .controller('pharmacy.list.controller', PharmacyListController);
}());
/**
 * @namespace routes.getStarted
 */

angular.module('routes.getStarted', ['ui.router', 'user', 'common', 'search', 'visit', 'notification', 'address', 'member'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {
      $stateProvider
        .state('getStarted', {
          parent: 'base',
          url: '/get-started',
          controller: 'routes.getStarted.controller as getStartedCtrl',
          templateUrl: paths.partials + '/routes/get-started/get-started.html',
          redirectTo: 'getStarted.info',
          data: {
            scrollTop: true
          }
        })
        .state('getStarted.info', {
          url: '/info',
          controller: 'routes.getStarted.infoCtrl as infoCtrl',
          templateUrl: paths.partials + '/routes/get-started/info/info.html'
        })
        .state('getStarted.services', {
          url: '/free-services',
          templateUrl: paths.partials + '/routes/get-started/services/template.html',
          controller: 'routes.getStarted.servicesCtrl as servicesCtrl',
          resolve: {
            AllServices: ['visit.service', 'routes.getStarted.model', 'services.date', function (visitService, getStartedModel) {
              var dataModel = getStartedModel.data;
              if (!_.isNumber(dataModel.age) || !_.isString(dataModel.gender)) {
                return [];
              }

              return visitService.getServices(dataModel.age, dataModel.gender, 'physical', false);
            }],
            Recommendations: ['visit.service', 'routes.getStarted.model', function (visitService, getStartedModel) {
              var dataModel = getStartedModel.data;
              if (!_.isNumber(dataModel.age) || !_.isString(dataModel.gender)) {
                return [];
              }

              return visitService.getRecommendations({
                visitType: 'physical',
                age: dataModel.age,
                gender: dataModel.gender,
                illnesses: [],
                attributes: {}
              });
            }]
          }
        })
        .state('getStarted.signup', {
          url: '/sign-up',
          controller: 'routes.getStarted.signupCtrl as signupCtrl',
          templateUrl: paths.partials + '/routes/get-started/signup/signup.html',
          data: {
            successState: 'dashboard',
            errorState: 'account.login',
            source: 'get-started'
          }
        });
    }
  ]);
(function () {

  /**
   *
   * @param {ui.router.state.$state} $state
   * @param {visit.plan.builder} visitPlanBuilder
   * @param {user.model} baseUser
   * @constructor
   */
  function Ctrl($state, visitPlanBuilder, baseUser) {
    this.render = false;

    if (baseUser.isLoggedIn) {
      $state.go('dashboard');
      return;
    }

    if (!$state.is('getStarted.info')){
      $state.go('getStarted.info');
    }

    // start over each time the user comes back to the beginning
    visitPlanBuilder.start();
    // only allowing physical
    visitPlanBuilder.setValue('type', 'physical');

    this.steps = [
      { header: 'Find your free care', activeMobileHeader: 'Find free care', mobileHeader: 'Find', stateName: 'getStarted.info'},
      { header: 'Choose your free care', activeMobileHeader: 'Choose free care', mobileHeader: 'Choose', stateName: 'getStarted.services'},
      { header: 'Get free care', activeMobileHeader: 'Get free care', mobileHeader: 'Get', stateName: 'getStarted.signup'}
    ];

    this.render = true;
  }

  Ctrl.$inject = ['$state', 'visit.plan.builder', 'baseUser'];

  angular.module('routes.getStarted')
    .controller('routes.getStarted.controller', Ctrl);
}());
(function () {

  /**
   * @name routes.getStarted.model
   * @param {ng.$http} $http
   * @param {config} config
   * @param {logger} logger
   */
  function Svc($http, config, logger) {

    // Everything is just in memory, if the user doesn't finish they start over

    /**
     * @name routes.getStarted.model.data
     * @memberOf routes.getStarted.model
     * @type {{ dob: string, age: number, gender: string, geo: Address, services: number[] }}
     */
    this.data = {};

    /**
     * @name routes.getStarted.model.complete
     * @methodOf routes.getStarted.model
     * @param {user.model} userModel
     * @param {number} servicesValue
     * @returns {Promise}
     */
    this.complete = function(userModel, servicesValue){
      var self = this;
      return $http
        .post(config.paths.services + '/ftux/welcome', {
          email: userModel.email,
          servicesValue: servicesValue
        })
        .catch(function(e){
          logger.error({
            message: 'FTUX welcome email send error',
            stack: e
          });
        })
        .finally(function(){
          self.data = {};
        });
    };
  }
  Svc.$inject = ['$http', 'config', 'logger'];

  angular.module('routes.getStarted')
    .service('routes.getStarted.model', Svc);
}());
angular.module('routes.home', ['ui.router', 'config', 'common', 'plan', 'translate', 'user'])
  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths){

      $stateProvider
        .state('home', {
          url: '/',
          parent: 'base',
          controller: 'routes.home.controller as homeCtrl',
          templateUrl: paths.partials + '/routes/home/home.html',
          data: {
            scrollTop: true,
            source: 'home',
            createSuccessRoute: '/home/account-create/success'
          }
        })
        .state('coverage', {
          url: '/coverage',
          parent: 'base',
          controller: 'routes.coverage.controller as coverageCtrl',
          templateUrl: paths.partials + '/routes/home/coverage.html',
          data: {
            scrollTop: true
          }
        });

    }
  ]);
angular.module('routes.home')
  .controller('routes.coverage.controller', [
    '$state',
    '$window',
    'user.service',
    'baseUser',
    'baseHealthApp',
    'services.tracking',
    function ($state, $window, userService, userModel, applicationModel, trackingService) {
      var self = this;
      this.inputsVisible = false;
      this.heroModel = {};
      this.footerModel = {};
      this.showDashboard = true;

      this.showInputs = function () {
        self.inputsVisible = true;
      };

      this.create = function (model) {
        this.showDashboard = false;
        if (model.form.$valid && model.username && model.password) {
          return userService.createFromForm(model.username, model.password, userModel, applicationModel, model.form)
            .then(function () {
              // twitter remarketing conversion
              if ($window.twttr && $window.twttr.conversion) {
                $window.twttr.conversion.trackPid('l6i0x', {tw_sale_amount: 0, tw_order_quantity: 0});
              }

              $state.go('dashboard');
            })
            .catch(function (err) {
              if (err.message === 'user already exists') {
                $state.go('account.login', {user: model.username});
              }
            });
        }
      };

      trackingService.trackLP('Coverage');
    }
  ]);
angular.module('routes.home')
  .controller('routes.home.controller', [
    '$q',
    '$scope',
    '$state',
    'services.date',
    'baseHealthApp',
    'search.geo',
    'translate.service',
    'snackbar.service',
    'services.tracking',
    function ($q, $scope, $state, dateService, applicationModel, geoSearch, translateService, snackbarService, trackingService) {
      //var coverageStartDate = dateService.getStartDate(applicationModel);
      //var coverageStartMonth = coverageStartDate.getMonth();
      //var applyByDate = dateService.getApplyByDate(coverageStartDate);

      //translateService.translate('shared.months')
      //  .then(function(months){
      //    $scope.applyMonth = months[applyByDate.getMonth()];
      //    $scope.startMonth = months[coverageStartMonth];
      //  });

      //snackbarService.push({
      //  key: 'home.coverage.loadingPlans',
      //  duration: -1
      //});

      trackingService.trackLP('Home');

      var state = applicationModel.getState() || null;
      var hasSubsidy = applicationModel.hasSubsidy();

      var requests = [];
      requests.push(dateService.getEnrollmentPeriods({
        onExchange: hasSubsidy,
        state: state,
        officialDate: true
      }));

      if (state) {
        requests.push(geoSearch.getStateConfig(state));
      }


      var today = new Date();
      $scope.showBanner = true;
      $scope.nextMonth = new Date(today.getFullYear(), today.getMonth() + 1);

      $q.all(requests)

        //dateService.getEffectiveDate({ state: state, onExchange: hasSubsidy, officialDate: true })
        //  .then(function(effectiveDate){
        //    var requests = [];
        //    requests.push(dateService.getEnrollmentPeriod({
        //      onExchange: hasSubsidy,
        //      state: state,
        //      effectiveDate: effectiveDate
        //    }));
        //
        //    if (state){
        //      requests.push(geoSearch.getStateConfig(state));
        //    }
        //
        //    return $q.all(requests);
        //  })
        .then(function (responses) {
          var enrollmentPeriods = responses[0];
          var currentPeriod = enrollmentPeriods.current;
          var nextPeriod = enrollmentPeriods.next;
          var now = new Date();

          if (currentPeriod.period_type === 'oep' && nextPeriod.period_type === 'sep') {
            $scope.oepEnding = true;
          }

          // if we have info, use that stride cutoff time
          if (state) {
            $scope.cutoffDate = currentPeriod.stride_end_date;
            $scope.showCutoffMissed = dateService.missedStrideCutoff(currentPeriod);

            if (!$scope.showCutoffMissed) {
              $scope.showCutoffNear = dateService.nearStrideCutoff(currentPeriod);
            }
          }
          else {
            $scope.cutoffDate = currentPeriod.official_end_date;
            $scope.showCutoffNear = dateService.nearDeadline(currentPeriod);
          }

          $scope.daysTilCutoff = Math.ceil(($scope.cutoffDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
          $scope.enrollmentPeriod = currentPeriod;
          $scope.nextEffectiveDate = nextPeriod.effective_date;

          if (responses.length === 2) {
            $scope.stateConfig = responses[1];
          }
        });

      //$scope.$on('$destroy', snackbarService.clear);

      this.goToSignup = function () {
        $state.go('account.create', {source: 'homepage'});
      };


    }
  ]);
'use strict';

/**
 * @namespace routes.marketing
 */

angular.module('routes.marketing', ['ui.router', 'config', 'common', 'translate', 'join'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function($stateProvider, $urlRouterProvider, paths){

      var podcasts = [
        'bestever',
        'cyop',
        'darkenthepage',
        'double',
        'foodheals',
        'getitdone',
        'hack',
        'mba',
        'peers',
        'rideshareguy',
        'roll',
        'solo',
        'twip'
      ];

      _.each(podcasts, rewrite);
      // rich roll gets two re writes!
      $urlRouterProvider.when('/richroll', '/landing/roll');

      $stateProvider
        .state('marketing', {
          url: '/landing/:persona',
          parent: 'base',
          data: {
            htmlClass: 'marketing-page',
            scrollTop: true,
            pageTitle: 'Benefits',
            pageDescription: 'What is a "health insurance recommendation engine"? Come find out.'
          },
          views: {
            '': {
              templateUrl: paths.partials + '/routes/marketing/landing.html',
              controller: 'routes.marketing.controller as marketingCtrl'
            },
            'bottom-join@marketing': {
              templateUrl: paths.partials + '/components/join/join.html',
              controller: 'joinCtrl as joinCtrl'
            },
            'hero-join@marketing': {
              templateUrl: paths.partials + '/components/join/join.html',
              controller: 'joinCtrl as joinCtrl'
            }
          }
        });

      function rewrite(route){
        $urlRouterProvider.when('/' + route, '/landing/' + route);
      }
    }
  ]);
angular.module('routes.marketing')
  .controller('routes.marketing.controller', [
    '$scope',
    '$state',
    '$stateParams',
    'translate.service',
    'config.service',
    'services.tracking',
    function($scope, $state, $stateParams, translateService, configService, trackingService){
      var self = this;

      translateService.translate('personas')
        .then(function(personas){
          // Check if that persona should be redirected to home page if brand doesn't support the persona
          var personaKeys = _.keys(personas);

          /** @type {Persona} **/
          var personaObj = personas[$stateParams.persona];
          var excludedBrands = personaObj && personaObj.excludedBrands;

          $scope.benefitsKey = (personaObj && personaObj.brandedBenefits) ? 'benefitsBrands' : 'benefits';
          self.heroBg = personaObj && personaObj.heroSrc;

          if (!_.includes(personaKeys, $stateParams.persona) || (excludedBrands && _.indexOf(excludedBrands, configService.getBrand()) > -1)) {
            $state.replace('home');
          }

          self.render = true;
        });

      trackingService.trackLP($stateParams.persona);
    }
  ]);

/**
 * @typedef {string} URL
 */

/**
 * @typedef {Object} Persona
 * @property {string} title
 * @property {string} subtitle
 * @property {string[]} excludedBrands
 * @property {boolean} brandedBenefits
 * @property {URL} heroSrc
 * @property {PersonaTestimonial[]} testimonials
 */

/**
 * @typedef {Object} PersonaTestimonial
 * @property {string} quote
 * @property {string} author
 * @property {string} image1
 * @property {string} image2
 */

angular.module('routes.partner', ['ui.router', 'config'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {

      $stateProvider
        .state('partnerUnverified', {
          url: '/partner/unverified',
          templateUrl: paths.partials + '/routes/partner/unverified.html',
          controller: [
            '$state',
            'config.service',
            function ($state, configService) {
              if (!configService.isEnabled('verify')) {
                $state.replace('home');
              }
            }
          ]
        })
        .state('partnerLanding', {
          url: '/launch',
          parent: 'base',
          templateUrl: paths.partials + '/routes/partner/landing.html',
          controller: [
            '$scope',
            '$state',
            'config.service',
            function ($scope, $state, configService) {
              if (!configService.isEnabled('landing')) {
                $state.replace('home');
              }
              $scope.brand = configService.getBrand();
            }
          ],
          data: {
            scrollTop: true
          }
        })
        .state('flushots', {
          url: '/flu-shot',
          parent: 'base',
          templateUrl: paths.partials + '/routes/partner/flushots/flushots.html',
          data: {
            successState: 'flushots.redeem',
            partnerGate: 'flushots',
          }
        })

        .state('flushots.account', {
          url: '/flu-shot/account',
          abstract: true,
          parent: 'base',
          templateUrl: paths.partials + '/routes/user/account/account.html',
          data: {
            source: 'flushots',
            successState: 'flushots.redeem'
          }
        })
        .state('flushots.account.login', {
          url: '/login?user',
          templateUrl: paths.partials + '/routes/user/account/login.html',
          controller: 'user.login.controller'
        })
        .state('flushots.account.create', {
          url: '/create',
          controller: 'user.login.controller',
          templateUrl: paths.partials + '/routes/user/account/create.html',
          data: {
            errorState: 'flushots.account.login'
          }
        })
        .state('flushots.redeem', {
          url: '/redeem',
          templateUrl: paths.partials + '/routes/partner/flushots/redeem.html',
          controller: 'routes.partner.flushotsController as flushotsCtrl'
        })
      ;

    }
  ]);
angular.module('routes.plan', ['ui.router', 'search', 'translate', 'snackbar', 'cart'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function ($stateProvider, $urlRouterProvider, paths) {
      var plansPrefix = '/plans/personal';
      var planPartials = paths.partials + '/routes/plan';
      var detailCtrl = 'routes.plan.detail.controller';
      var detailTemplate = planPartials + '/plan-detail.html';

      $urlRouterProvider.when(plansPrefix + '/list', plansPrefix + '/list/all');


      $stateProvider
        .state('myPlan', {
          url: '/my-plan',
          parent: 'purchase',
          controller: detailCtrl,
          templateUrl: detailTemplate,
          data: {
            personal: true,
            appPlan: true,
            scrollTop: true,
            step: 'plan'
          },
          resolve: {
            AppResources: ['baseUser', 'baseHealthApp', function(userModel, applicationModel){
              return applicationModel.setResources(userModel);
            }]
          }
        })
        .state('recommended', {
          url: plansPrefix + '/recommended',
          parent: 'purchase',
          controller: 'routes.plan.recommended.controller as recoCtrl',
          templateUrl: planPartials + '/recommended/plan-recommended.html',
          data: {
            scrollTop: true,
            step: 'plan'
          },
          resolve: {
            AppResources: ['baseUser', 'baseHealthApp', function(userModel, applicationModel){
              return applicationModel.setResources(userModel);
            }]
          }
        })
        .state('recommended.planDetail', getDetailConfig('recommended', 'toReco'))
        .state('recommended.planDetail.scenario', getScenariosConfig())
        .state('personalPlans', {
          url: plansPrefix + '/list',
          parent: 'sidebar',
          views: {
            'main@sidebar': {
              templateUrl: planPartials + '/list/wrapper.html',
              controller: 'plan.personalCtrl as personalCtrl'
            }
          },
          data: {
            step: 'plan'
          },
          resolve: {
            AppResources: ['baseUser', 'baseHealthApp', function(userModel, applicationModel){
              return applicationModel.setResources(userModel);
            }]
          }
        })
        .state('personalPlans.list', {
          url: '/all',
          views: {
            '': {
              templateUrl: planPartials + '/list/plan-list.html',
              controller: 'plan.list.controller'
            },

            'side@sidebar': {
              templateUrl: planPartials + '/list/sidebar.html',
              controller: 'plan.filterCtrl'
            }
          },
          data: {
            scrollTop: true
          }
        })
        .state('personalPlans.list.planDetail', getDetailConfig('personalPlans.list', 'toPlanList'))
        .state('personalPlans.list.planDetail.scenario', getScenariosConfig())

        .state('personalPlans.list.compare', {
          url: '/compare',
          controller: 'plan.list.compareCtrl'
        })
        .state('personalPlans.list.compare.h2h', {
          url: '/{pid1:[0-9]+}/{pid2:[0-9]+}',
          views: {
            '@personalPlans.list': {
              controller: 'plan.list.compare.h2hCtrl as h2hCtrl',
              templateUrl: planPartials + '/list/compare/' +
              'h2h.html'
            },
            'side@sidebar': {
              templateUrl: paths.partials + '/routes/purchase/nav.html',
              controller: 'routes.purchase.controller'
            }
          }

        })
        .state('personalPlans.list.compare.h2h.scenarios', {
          url: '/scenarios',
          controller: 'plan.scenariosCtrl as scenariosCtrl',
          templateUrl: paths.partials + '/components/plan/scenarios/list.html',
          data: {
            backState: '^',
            backKey: 'planDetail.buttons.back.toCompare'
          }
        })
        .state('personalPlans.list.compare.h2h.planDetail', getDetailConfig('personalPlans.list.compare.h2h', 'toCompare'))
        .state('personalPlans.list.compare.h2h.planDetail.scenario', getScenariosConfig())
        //.state('dentalOffer', {
        //  url: plansPrefix + '/dental-offer',
        //  controller: 'routes.dental.offer.controller',
        //  templateUrl: paths.partials + '/routes/dental/offer/offer.html',
        //  parent: 'purchase',
        //  data: {
        //    authenticate: true,
        //    unAuthState: 'planAccount.create',
        //    scrollTop: true,
        //    step: 'plan'
        //  }
        //})
        .state('planAccount', {
          parent: 'base',
          abstract: true,
          templateUrl: paths.partials + '/routes/user/account/account.html',
          data: {
            authenticate: false,
            successState: 'cart'
          }
        })
        .state('planAccount.login', {
          url: plansPrefix + '/login?user&source',
          templateUrl: paths.partials + '/routes/plan/account/login.html',
          controller: 'user.login.controller',
          params: {
            source: 'health-buy'
          }
        })
        .state('planAccount.create', {
          url: plansPrefix + '/create?source',
          controller: 'user.login.controller',
          templateUrl: paths.partials + '/routes/plan/account/create.html',
          data: {
            errorState: 'planAccount.login'
          },
          params: {
            source: 'health-buy'
          }
        });

      function getDetailConfig(backState, backKey) {
        return {
          url: '/detail/:id',
          views: {
            '': {
              controller: detailCtrl,
              templateUrl: detailTemplate
            },
            'side@sidebar': {
              templateUrl: paths.partials + '/routes/purchase/nav.html',
              controller: 'routes.purchase.controller'
            }
          },
          data: {
            backState: backState,
            backKey: 'planDetail.buttons.back.' + backKey
          }
        };
      }

      function getScenariosConfig() {
        return {
          url: '/scenarios',
          controller: 'routes.plan.scenario.controller',
          templateUrl: planPartials + '/scenario.html'
        };
      }
    }
  ]);
angular.module('routes.plan')
  .controller('routes.plan.detail.controller', [
    '$q',
    '$state',
    '$scope',
    '$stateParams',
    'baseUser',
    'baseHealthApp',
    'application.service',
    'plan.utils',
    'plan.search',
    'plan.detail.setup',
    'plan.compare.service',
    'logger',
    'services.tracking',
    /**
     * @param {ng.$q} $q
     * @param {ui.router.state.$state} $state
     * @param {Object} $scope
     * @param {Object} $stateParams
     * @param {user.model} userModel
     * @param {application.model} applicationModel
     * @param {application.service} applicationService
     * @param {plan.utils} planUtils
     * @param {plan.search} planSearch
     * @param {plan.detail.setup} DetailSetup
     * @param {plan.compare.service} planCompareService
     * @param {logger} logger
     * @param {services.tracking} trackingService
     */

      function ($q, $state, $scope, $stateParams, userModel, applicationModel, applicationService, planUtils, planSearch, DetailSetup, planCompareService, logger, trackingService) {

      var stateData = $state.current.data || {};
      var detailSetup = new DetailSetup();
      var plan /** @type HealthPlan **/ = null;
      var errObj = {
        userOid: userModel.getId(),
        healthApp: applicationModel.get()
      };

      if (!applicationModel.hasValidDemos()) {
        errObj.message = 'Invalid demographic information on health application';
        logger.error(errObj);

        // go home in case ob step is on recommended to avoid looping
        return $state.replace('home');
      }

      $scope.applicantCount = applicationModel.getCoveredMembers().length;

      // Moved this out of resolves, so we can show loading instead of hanging the user
      if (stateData.appPlan && applicationModel.getPlan() && applicationModel.isComplete()) {
        plan = applicationModel.getPlan();
        detailSetup.setup($scope, applicationModel.get(), plan, [applicationModel.getPlan()], false);
      }
      else {
        planSearch.getMerged(applicationModel)
          .then(function (plans) {
            if (stateData.appPlan && applicationModel.getPlan()) {
              plan = _.findWhere(plans, {id: applicationModel.getPlan().id});
            }
            else if (stateData.recommended) {
              plan = planUtils.getTopPlan(plans);
            }
            else {
              //plan = planUtils.getByDetails(plans, $stateParams.carrier, $stateParams.type, $stateParams.name);
              plan = _.findWhere(plans, { id: +$stateParams.id });
            }

            if (plan) {
              detailSetup.setup($scope, applicationModel, plan, plans, plan === planUtils.getTopPlan(plans));
            }
            else {
              return $q.reject('No plan found');
            }
          })
          .catch(function (err) {
            logger.error(_.extend(errObj, {
              message: err && err.message || err
            }));

            $state.replace('500');
          });
      }

      $scope.pickPlan = function () {
        if (plan === null) {
          return $state.replace('404');
        }

        applicationModel.setPlan(userModel, plan)
          .then(function () {
            var params = {};
            if (!plan.adultDental){
              params.offer = 'dental';
            }

            $state.go('cart', params);
            // If there is a dental plan in the cart already, go to plans overview page. Otherwise, go to the dental offer page
            //cartService.hasDentalPlan() ? $state.go('dental.plans.overview') : $state.go('dentalOffer');
          })
          .catch(function (err) {
            logger.error(_.extend(errObj, {
              message: err && err.message || err,
              res: err
            }));

            $state.replace('500');
          });
      };

      $scope.comparePlan = function () {
        planCompareService.removeAllComparePlans();
        planCompareService.addComparePlan(plan);

        trackingService.mixpanelEvent('Plan Compare: Select Plan', {
          'Checked': true,
          'Source': 'Plan Detail'
        });

        $state.go('personalPlans.list.compare');
      };
    }
  ]);
angular.module('routes.plan')
  .directive('planHeaderNav', [
    'config',
    function(config){
      return {
        scope: true,
        templateUrl: config.paths.partials + '/routes/plan/plan-header-nav.html'
      };
    }
  ]);
angular.module('routes.plan')
  .controller('routes.plan.scenario.controller', [
    '$scope',
    '$state',
    '$timeout',
    'scrollTo.service',
    'plan.search',
    'baseHealthApp',

    /**
     * @name routes.plan.scenario.controller
     * @param {Object} $scope
     * @param {ui.router.state.$state} $state
     * @param {ng.$timeout} $timeout
     * @param {*} scrollToService
     * @param {plan.search} planSearch
     * @param {health.app} applicationModel
     */

    function($scope, $state, $timeout, scrollToService, planSearch, applicationModel){

      if (!$scope.plan){
        return $state.go('^');
      }

      planSearch.getScenarios($scope.plan, applicationModel)
        .then(function(scenarios){

          $scope.active = 0;
          $scope.scenarios = scenarios;

          $scope.$watch('active', function(newValue){
            if (newValue < $scope.scenarios.length){
              $scope.planCost = scenarios[newValue].insured;
              $scope.uninsuredCost = scenarios[newValue].uninsured;
            }
          });

          $scope.setActive = function(index){
            if (index < $scope.scenarios.length){

              scrollToService.go(0, 200)
                .then(function(scrolled){
                  $timeout(function(){
                    $scope.active = index;
                  }, scrolled && 50 || 0);

                });
            }
          };

          $scope.render = true;
        });
    }
  ]);
angular.module('routes.ob', ['ui.router', 'config', 'common', 'user', 'application', 'profile', 'search', 'plan', 'drug', 'doctor', 'modal', 'address', 'member'])
  .config([
    '$stateProvider',
    '$urlRouterProvider',
    'config.paths',
    function ($stateProvider, $urlRouterProvider, paths) {
      var sectionsBase = 'ob.';
      var partials = paths.partials;
      var partialBase = partials + '/routes/ob/';
      var location = 'location';
      var family = 'family';
      var doctors = 'doctors';
      var illnesses = 'illnesses';
      var drugs = 'drugs';
      var savings = 'savings';
      var account = 'account';
      var urlBase = '^/onboarding/';

      function getView(step) {
        return {
          controller: 'routes.ob.' + step + '.controller',
          templateUrl: partialBase + step + '/' + step + '.html'
        };
      }

      $urlRouterProvider.when('/onboarding/savings', '/onboarding/savings/subsidy');

      $stateProvider
        .state('ob', {
          url: '/onboarding',
          parent: 'purchase',
          controller: 'routes.ob.controller as ob',
          templateUrl: partialBase + 'ob.html',
          data: {
            scrollTop: true,
            step: 'profile'
          }
        })

        .state(sectionsBase + location, {
          url: '/' + location + '?zipcode',
          controller: 'routes.ob.location.controller as location',
          templateUrl: partialBase + 'location/location.html',
          data: {
            nextState: sectionsBase + family
          }
        })

        .state(sectionsBase + family, {
          url: urlBase + family,
          controller: 'routes.ob.familyCtrl as familyCtrl',
          templateUrl: partialBase + family + '/' + family + '.html'
        })
        .state(sectionsBase + family + '.member', {
          url: '/member/:memberId',
          data: {
            backState: sectionsBase + family,
            backKey: 'shared.buttons.cancel'
          },
          controller: 'member.detail.controller as memberDetailCtrl',
          templateUrl: partials + '/components/member/member-detail.html'
        })
        .state(sectionsBase + 'change', {
          url: '/change',
          templateUrl: partialBase + 'change.html'
        })

        .state(sectionsBase + doctors, {
          url: urlBase + doctors,
          views: {
            '': getView(doctors)
          },
          resolve: {
            AppDoctors: ['baseUser', 'baseHealthApp', 'doctor.application.service', function (userModel, applicationModel, doctorApplicationService) {
              return doctorApplicationService.getDetails(userModel, applicationModel.getId(), applicationModel.getNetworkId(), 'health');
            }]
          }
        })
        .state(sectionsBase + doctors + '.list', {
          url: '/saved',
          templateUrl: partialBase + 'doctors/list.html'
        })
        .state(sectionsBase + doctors + '.search', {
          url: '/search',
          views: {
            '': {
              templateUrl: partialBase + 'doctors/search.html'
            },
            'search@ob.doctors.search': {
              templateUrl: partials + '/components/doctor/search/form.html',
              controller: 'doctor.searchAppCtrl as searchCtrl'
            },
            'results@ob.doctors.search': {
              templateUrl: partials + '/components/doctor/search/results/list.html',
              controller: 'profile.doctor.resultsCtrl as resultsCtrl'
            }
          },
          data: {
            termPlaceholder: 'profile.placeholders.addDoc',
            geoPlaceholder: 'visit.plan.doctor.geoPlaceholder',
            onSavedState: '^.list'
          }
        })
        .state(sectionsBase + 'privacy', {
          url: urlBase + 'privacy',
          templateUrl: partialBase + 'privacy.html'
        })
        .state(sectionsBase + drugs, {
          url: urlBase + 'prescriptions',
          views: {
            '': {
              controller: 'routes.ob.drugs.controller as drugsCtrl',
              templateUrl: partialBase + 'drugs/drugs.html'
            }
          }
        })
        .state(sectionsBase + drugs + '.edit', {
          url: '/edit',
          abstract: true,
          template: '<div ui-view sh-html-class="drug-page"></div>',
          controller: 'drug.picker.controller',
          data: {
            invalidState: sectionsBase + drugs
          }
        })

        .state(sectionsBase + drugs + '.edit.dose', {
          url: '/dose',
          controller: 'drug.dose.controller as doseController',
          templateUrl: partials + '/routes/drug/pick-dose.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.quantity'
          }
        })

        .state(sectionsBase + drugs + '.edit.quantity', {
          url: '/quantity',
          controller: 'drug.fill.controller as fillController',
          templateUrl: partials + '/routes/drug/pick-fill.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.refills'
          }
        })

        .state(sectionsBase + drugs + '.edit.refills', {
          url: '/fill-count',
          controller: 'drug.refill.controller as refillController',
          templateUrl: partials + '/routes/drug/pick-refills.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.member'
          }
        })

        .state(sectionsBase + drugs + '.edit.member', {
          url: '/member',
          controller: 'drug.member.controller as memberController',
          templateUrl: partials + '/routes/drug/pick-member.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.complete'
          },
          resolve: {
            members: ['baseHealthApp', function (applicationModel) {
              return applicationModel.getMembers();
            }]
          }
        })

        .state(sectionsBase + drugs + '.edit.complete', {
          url: '/complete',
          template: '',
          controller: ['$state', '$scope', 'drug.editor', 'baseHealthApp', 'baseUser', 'drug.service',
            function ($state, $scope, drugEditor, currentHealthApp, userModel, drugService) {
              var drug = drugEditor.complete();
              var model = drug.drug_json;

              if (model && model.dose && model.fillQty && model.durationDays) {
                drugService.saveDrug(userModel, drug, currentHealthApp)
                  .then(function (response) {
                    $scope.$emit('drug-saved', response);
                    $state.replace(sectionsBase + drugs);
                  });
              }
              else {
                $state.replace('profile');
              }
            }]
        })

        .state(sectionsBase + illnesses, {
          url: urlBase + 'conditions',
          controller: 'routes.ob.illnesses.controller',
          templateUrl: partialBase + 'illnesses/illnesses.html'
        })
        .state(sectionsBase + illnesses + '.edit', {
          url: '/edit',
          templateUrl: paths.partials + '/components/profile/illnesses/illness-edit.html',
          controller: 'profile.illnessEdit.controller',
          data: {
            skipState: sectionsBase + illnesses + '.smoking'
          }
        })

        .state(sectionsBase + illnesses + '.smoking', {
          url: '/smoking',
          templateUrl: partialBase + 'illnesses/smoking.html',
          controller: 'routes.ob.smoking.controller'
        })

        // re-usable profile controllers w/ onboarding specific templates
        .state(sectionsBase + savings, {
          url: urlBase + savings,
          templateUrl: partialBase + 'savings/savings.html',
          controller: ['$scope', 'services.alert', function ($scope, alertService) {
            $scope.$on('$destroy', alertService.clear);
          }],
          data: {
            // for guided flow income entry
            isOnboarding: true,
            completeState: sectionsBase + account
          },
          resolve: {
            StartYear: ['baseHealthApp', 'plan.deadlineSvc', function (healthApp, planDeadlineSvc) {
              return planDeadlineSvc.getStateEnrollment(healthApp)
                .then(function (response) {
                  return response.periods.next.stride_start_date.getUTCFullYear();
                });
            }]
          }
        })

        // Subsidy flow start
        .state(sectionsBase + savings + '.subsidy', {
          url: '/subsidy',
          controller: 'profile.subsidy.controller',
          templateUrl: partialBase + 'savings/subsidy.html'
        })
        .state(sectionsBase + savings + '.household', {
          url: '/subsidy/household',
          controller: 'profile.household.controller',
          templateUrl: partialBase + 'savings/household.html',
          data: {
            nextState: '^.estimate'
          }
        })
        .state(sectionsBase + savings + '.estimate', {
          url: '/subsidy/income',
          controller: 'routes.ob.estimateSelect.controller as estimateSelectCtrl',
          templateUrl: partialBase + 'savings/estimate-option.html'
        })

        // Guided income estimation
        .state(sectionsBase + savings + '.guided', {
          url: '/subsidy/income/guided',
          template: '<div ui-view></div>',
          controller: ['$scope', 'baseHealthApp', function ($scope, applicationModel) {
            applicationModel.get().taxInfo.guided = true;
          }]
        })
        .state(sectionsBase + savings + '.guided.members', {
          url: '/subsidy/income/guided/members',
          controller: 'profile.guided.controller as guidedCtrl',
          templateUrl: partialBase + 'savings/guided/guided.html'
        })
        .state(sectionsBase + savings + '.guided.source', {
          url: '/source/:sourceIndex',
          controller: 'profile.guided.source.controller as guidedSourceCtrl',
          templateUrl: partialBase + 'savings/guided/guided-source.html'
        })
        .state(sectionsBase + savings + '.guided.summary', {
          url: '/summary',
          controller: 'profile.guided.summary.controller as incomeSummaryCtrl',
          templateUrl: partialBase + 'savings/guided/guided-summary.html',
          data: {
            financeType: 'income',
            next: 'ob.savings.income.qualify'
          }
        })
        .state(sectionsBase + savings + '.guided.summary.edit', {
          url: '/member/:member_id',
          controller: 'profile.guided.summary.edit.controller as guidedSummaryEditCtrl',
          templateUrl: partialBase + 'savings/guided/edit-finance.html',
          params: {
            finances: null,
            isOnboarding: true
          },
          data: {
            backState: sectionsBase + savings + '.guided.summary',
            backKey: 'shared.buttons.cancel',
            stateReplace: 'true'
          }
        })

        // Known income
        .state(sectionsBase + savings + '.income', {
          url: '/subsidy/income/assistance',
          controller: 'profile.income.controller as profileIncomeCtrl',
          templateUrl: partialBase + 'savings/income.html',
          data: {
            nextBtnKey: 'profile.buttons.qualify'
          }
        })
        .state(sectionsBase + savings + '.income.qualify', {
          url: '/qualify',
          controller: 'profile.income.qualify.controller',
          templateUrl: partialBase + 'savings/qualify.html'
        })


        .state(sectionsBase + 'deadline', {
          url: '/deadline',
          templateUrl: partialBase + 'deadline/template.html',
          controller: 'routes.ob.deadlineCtrl as deadlineCtrl',
          data: {
            nextState: 'recommended'
          },
          resolve: {
            Deadline: ['baseHealthApp', 'plan.deadlineSvc', function (healthApp, planDeadlineSvc) {
              return planDeadlineSvc.getStateEnrollment(healthApp);
            }]
          }
        })

        .state(sectionsBase + account, {
          url: '/account',
          controller: 'user.login.controller',
          templateUrl: partialBase + 'account/create.html',
          data: {
            successState: 'recommended',
            //successState: sectionsBase + 'deadline',
            errorState: sectionsBase + 'login',
            source: 'health-onboarding'
          }
        })
        .state(sectionsBase + 'login', {
          url: '/login?user',
          controller: 'user.login.controller',
          templateUrl: partialBase + 'account/login.html',
          data: {
            successState: 'recommended'
            //successState: sectionsBase + 'deadline'
          }
        });
    }
  ]);
angular.module('routes.ob')

  .controller('routes.ob.controller', [
    '$scope',
    '$state',
    '$timeout',
    'utils',
    'services.alert',
    'baseHealthApp',
    'baseUser',
    'plan.stats',
    'logger',
    function($scope, $state, $timeout, utils, alertService, applicationModel, userModel, planStats, logger){
      var self = this;
      var stepOrder = $scope.steps.profile.steps;
      var locationStep = 'ob.location';

      this.render = false;

      $scope.$on('$stateChangeSuccess', function($event, toState){
        var redirectState;
        var step = applicationModel.progress.getObStep(applicationModel);

        if (step === 'location' && !$state.is(locationStep)){
          redirectState = locationStep;
        }
        else if (toState.name === 'ob'){
          if (step === 'recommended'){
            redirectState = 'recommended';
          }
          // if state exists, go to it
          else if ($state.get('ob.' + step)){
            redirectState = 'ob.' + step;
          }
          else {
            redirectState = locationStep;
          }
        }

        if (redirectState && redirectState !== toState.name){
//        there's a bug with location: 'replace', where if you go back and forth it
//        starts replacing history items that it shouldn't, so wait for the digest first
//        to make sure the 'ob' state gets pushed into the history, so it will always be
//        the state that gets removed
          $timeout(function() {
            return $state.replace(redirectState);
          });
        }
        else {
          self.render = true;
        }
      });

      self.warning = null;
      self.message = null;

      self.addDefaultMessage = function(){
        var address = applicationModel.getAddress();
        planStats.getForApp(applicationModel)
          .then(function(stats){
            var plural = stats.carrierCount === 1 ? '' : 's';
            alertService.setMessage({
              key: 'profile.alert.planCount',
              model: {
                planCount: stats.planCount,
                carrierCount: stats.carrierCount,
                plural: plural,
                city: address.city,
                state: address.state
              }
            });
          });
      };

      self.setMaxProgress = function(step){
        var index = _.findIndex(stepOrder, { key: step });
        var storedIndex = _.indexOf(stepOrder, applicationModel.get().obStep);

        applicationModel.get().obStep = stepOrder[Math.max(index, storedIndex)].key;
      };

      self.refreshApp = function(){
        applicationModel.startOver()
          .then(function(){
            $state.go('ob.location');
          });
      };

      self.logSyncError = function(err){
        if (err.status === 409){
          //
          //modalService.push({
          //  render: true,
          //  titleKey: 'errors.modal.sessionOOS',
          //  bodyKey: 'errors.modal.refresh'
          //});

          //$scope.syncError = true;
          logger.error({
            message: 'Session sync modal',
            user: userModel.get(),
            healthApp: applicationModel.get()
          });
          self.syncError = true;
        }
      };

      $scope.navItems = stepOrder;
    }
  ]);
//(function(){
//
//  /**
//   * @name routes.preOep
//   * @param {ui.router.state.$stateProvider} $stateProvider
//   * @param {config} config
//   * @constructor
//   */
//  function Config($stateProvider, config){
//
//    $stateProvider
//      .state('buy.preOep', {
//        url: '/pre-oep',
//        controller: 'routes.preOepCtrl as preOepCtrl',
//        templateUrl: config.paths.partials + '/routes/pre-oep/main.html',
//        data: {
//          step: 'plan',
//          authenticate: true,
//          qualifyState: 'buy.qualify'
//        }
//      })
//      .state('subsidy.preOep', {
//        url: '/pre-oep',
//        controller: 'routes.preOepCtrl as preOepCtrl',
//        templateUrl: config.paths.partials + '/routes/pre-oep/main.html',
//        data: {
//          step: 'plan',
//          authenticate: true,
//          qualifyState: 'subsidy.qualify'
//        }
//      });
//  }
//  Config.$inject = ['$stateProvider', 'config'];
//
//  angular.module('routes.preOep', ['ui.router', 'config', 'common'])
//    .config(Config);
//
//}());
//(function(){
//
//  /**
//   * @name routes.preOepCtrl
//   * @param {ui.router.state.$state} $state
//   * @param {services.date} dateService
//   * @param {plan.utils} planUtils
//   * @param {plan.search} planSearch
//   * @param {application.model} currentHealthApp
//   */
//  function Ctrl($state, dateService, planUtils, planSearch, currentHealthApp){
//    var self = this;
//    this.isOep = dateService.isOpenEnrollment(new Date(), currentHealthApp);
//    this.plan = currentHealthApp.getPlan();
//    this.hasOepPlan = self.plan.planYear === 2016;
//
//    // if they have an old plan and have already started it
//    if (!this.hasOepPlan && currentHealthApp.hasLifeEvent()){
//      self.show2016Plans = true;
//
//      // check to see if there are any 2016 plans
//      planSearch.checkEligibility(currentHealthApp, planUtils.getOepBuyDate(), 2016)
//        .then(function(isEligible){
//          self.has2016Plans = isEligible;
//          self.render = true;
//        });
//    }
//    else {
//      this.render = true;
//    }
//
//    this.get2016Plans = function(){
//      planUtils.setDateParams(planUtils.getOepBuyDate(), 2016);
//      $state.go('profile');
//    };
//    //
//    //this.getSepPlan = function(){
//    //  planUtils.setDateParams(new Date(), 2015);
//    //  $state.go('recommended');
//    //};
//  }
//  Ctrl.$inject = ['$state', 'services.date', 'plan.utils', 'plan.search', 'baseHealthApp'];
//
//  angular.module('routes.preOep')
//    .controller('routes.preOepCtrl', Ctrl);
//}());
angular.module('routes.profile', ['ui.router', 'config', 'user', 'application', 'profile', 'search', 'common', 'drug', 'member'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {

      var partials = paths.partials;
      var sectionsBase = 'profile.';
      var drugs = 'drugs';

      $stateProvider
        .state('profile', {
          url: '/profile',
          parent: 'base',
          templateUrl: paths.partials + '/routes/profile/profile.html',
          controller: 'routes.profile.controller as profileCtrl',
          data: {
            scrollTop: true
          }
        })
        .state('profile.member', {
          url: '/member/:memberId',
          data: {
            backState: 'profile',
            backKey: 'shared.buttons.cancel'
          },
          controller: 'member.detail.controller as memberDetailCtrl',
          templateUrl: partials + '/components/member/member-detail.html'
        })
        .state(sectionsBase + drugs, {
          url: '/drug',
          abstract: true,
          template: '<div ui-view></div>'
        })

        .state(sectionsBase + drugs + '.edit', {
          url: '/edit',
          abstract: true,
          template: '<div ui-view sh-html-class="drug-page"></div>',
          controller: 'drug.picker.controller',
          data: {
            invalidState: 'profile'
          }
        })

        .state(sectionsBase + drugs + '.edit.dose', {
          url: '/dose',
          controller: 'drug.dose.controller as doseController',
          templateUrl: partials + '/routes/drug/pick-dose.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.quantity'
          }
        })

        .state(sectionsBase + drugs + '.edit.quantity', {
          url: '/quantity',
          controller: 'drug.fill.controller as fillController',
          templateUrl: partials + '/routes/drug/pick-fill.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.refills'
          }
        })

        .state(sectionsBase + drugs + '.edit.refills', {
          url: '/fill-count',
          controller: 'drug.refill.controller as refillController',
          templateUrl: partials + '/routes/drug/pick-refills.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.member'
          }
        })

        .state(sectionsBase + drugs + '.edit.member', {
          url: '/member',
          controller: 'drug.member.controller as memberController',
          templateUrl: partials + '/routes/drug/pick-member.html',
          data: {
            nextState: sectionsBase + drugs + '.edit.complete'
          },
          resolve: {
            members: ['baseHealthApp', function (applicationModel) {
              return applicationModel.getMembers();
            }]
          }
        })

        .state(sectionsBase + drugs + '.edit.complete', {
          url: '/complete',
          template: '',
          controller: ['$scope', '$state', 'drug.editor', 'baseHealthApp', 'baseUser', 'drug.service',
            function ($scope, $state, drugEditor, currentHealthApp, userModel, drugService) {
              var self = this;

              var drug = drugEditor.complete();
              var model = drug.drug_json;

              if (model && model.dose && model.fillQty && model.durationDays) {
                self.drugs = $scope.drugs;
                drugService.saveDrug(userModel, drug, currentHealthApp)
                  .then(function (response) {
                    if (response) {
                      var index = _.findIndex(self.drugs, {id: response.id});
                      if (index > -1) {
                        self.drugs[index] = response;
                      } else {
                        self.drugs.push(response);
                      }
                    }
                    $state.replace('profile');
                  });
              }
              else {
                $state.replace('profile');
              }
            }]
        })

        .state('profile.illnesses', {
          url: '/conditions',
          templateUrl: partials + '/components/profile/illnesses/illness-edit.html',
          controller: 'profile.illnessEdit.controller'
        })

        .state('profileUpdate', {
          parent: 'base',
          url: '/profile/calculating',
          templateUrl: partials + '/routes/profile/calculating.html',
          // wait for base user here
          controller: ['baseUser', function (baseUser) {
          }]
        })

        .state('profile.doctorSearch', {
          url: '/doctor/search',
          views: {
            'doctor-search': {
              templateUrl: partials + '/routes/ob/doctors/search.html'
            },
            'search@profile.doctorSearch': {
              templateUrl: partials + '/components/doctor/search/form.html',
              controller: 'doctor.searchAppCtrl as searchCtrl'
            },
            'results@profile.doctorSearch': {
              templateUrl: partials + '/components/doctor/search/results/list.html',
              controller: 'profile.doctor.resultsCtrl as resultsCtrl'
            }
          },
          data: {
            termPlaceholder: 'profile.placeholders.addDoc',
            geoPlaceholder: 'visit.plan.doctor.geoPlaceholder'
          }
        });
    }
  ]);
angular.module('routes.profile')
  .directive('shEditApplicant', [
    'config.paths',
    'member.service',
    'application.model',
    'services.tracking',
    function(paths, memberService, applicationModel, trackingService){

      return {
        scope: true,
        templateUrl: paths.partials + '/routes/profile/applicant-form.html',

        link: {
          pre: function($scope, $element, $attr){
            $scope.applicant = $scope.$eval($attr.shEditApplicant);
            $scope.model = {};
            $scope.required = $scope.$eval($attr.shRequired);
            $scope.isPrimary = memberService.isPrimary($scope.applicant);
          },
          post: function($scope, $element){

            $scope.submit = function(){
              if ($scope.model.form.$valid){

                // Mixpanel profile: age, gender
                var property = {};
                property[trackingService.propEnum.age] = $scope.applicant.age;
                property[trackingService.propEnum.gender] = $scope.applicant.gender;
                trackingService.setPeopleProps(property);

                $scope.$emit('applicant-edit-complete', $scope.applicant);
              }

              else {
                // this trigger sh-submit-errors functionality
                $('form', $element).submit();

              }
            };

            $scope.showType = function(){
              // don't show for primary
              return !memberService.isPrimary($scope.applicant) &&
                // show if there is no spouse or if this is the spouse so they can change to dependent if needed
                (!applicationModel.getSpouse() || memberService.isSpouse($scope.applicant))
            };

            $scope.close = function(){
              $scope.$emit('applicant-edit-close');
            };
          }
        }
      }
    }
  ]);
angular.module('routes.profile')
  .controller('routes.profile.controller', [
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'services.alert',
    'plan.utils',
    'drug.editor',
    'member.service',
    'drug.service',
    function ($scope, $state, userModel, applicationModel, alertService, planUtils, drugEditor, memberService, drugService) {
      var self = this;

      if (applicationModel.isComplete()) {
        $state.replace('dashboard');
        return;
      }

      var primary = applicationModel.getPrimary();
      if (!primary || !primary.age || !primary.gender || !applicationModel.getAddress().zipcode) {
        $state.go('home');
        return;
      }

      var cachedApplication = angular.copy(applicationModel);

      $scope.editing = false;
      $scope.renderProfile = true;
      $scope.application = applicationModel.get();
      $scope.activeApplicant = null;
      $scope.search = {
        doc: false,
        drug: false
      };

      alertService.setMessage(null);

      // Get drugs
      drugService.getAllForUser(userModel)
        .then(function (response) {
          $scope.drugs = response;
        });

      // Get Members
      $scope.members = {
        allMembers: [],
        appMembers: [],
        newMembers: []
      };
      memberService.getMemberSet(userModel, applicationModel.getId())
        .then(function (response) {
          $scope.members.allMembers = response.allMembers;
          //$scope.members.allMembers = response.appMembers;
          $scope.members.appMembers = _.filter(response.allMembers, function (member) {
            return !!_.findWhere(response.appMembers, {id: member.id});
          });
          $scope.renderMembers = true;
        });

      $scope.$on('member-updated', function (event, member) {
        // Find the member in the arrays and update
        var allIndex = _.findIndex($scope.members.allMembers, {id: member.id});
        var appIndex = _.findIndex($scope.members.appMembers, {id: member.id});
        $scope.members.allMembers[allIndex] = member;
        $scope.members.appMembers[appIndex] = member;
      });

      /**
       * Save updated profile
       */
      $scope.save = function () {

        // Save app members
        if (self.membersForm.$valid) {
          var appMembers = _.chain($scope.members.allMembers)
            .filter(function (member) {
              return _.contains($scope.members.appMembers, member);
            })
            .map(function (member) {
              return _.extend({}, member, {status: 'coverage'});
            })
            .value();

          applicationModel.saveMembers($scope.userModel, appMembers)
            .then(function () {
              if (planUtils.isSameMods(cachedApplication, applicationModel)) {
                $state.go('recommended');
              }
              else {
                $state.go('profileUpdate');
              }
            })
            .catch(function (error) {
              alertService.setWarning({key: 'profile.alert.invalidProfile', duration: 5000});
            });
        } else {
          alertService.setWarning({key: 'profile.alert.invalidProfile', duration: 5000});
        }

        //// Save members
        //if (self.membersForm.$valid) {
        //  //$scope.$emit('save-members');
        //} else {
        //  alertService.setWarning({key: 'profile.alert.invalidProfile', duration: 5000});
        //}
      };

      $scope.$on('$stateChangeSuccess', function () {
        $scope.editing = !$state.is('profile');
      });

      $scope.$on('clear-search', function () {
        $scope.search = {
          doc: false,
          drug: false
        };
      });

      $scope.$on('doc-search', function () {
        $scope.search.doc = true;
      });

      // ------- Illnesses ---------

      $scope.addIllness = function () {
        //$scope.editing = true;
        $state.go('.illnesses');
      };
      $scope.$on('illness-add', $scope.addIllness);


      // ------- Drugs ---------
      $scope.$on('drug-search', function () {
        $scope.search.drug = true;
      });

      $scope.$on('drug-select', editDrug);
      $scope.$on('drug-edit', editDrug);

      $scope.$on('drug-remove', function ($event, drug) {
        drugService.removeDrug(userModel, drug)
          .then(function (response) {
            if (response) {
              $scope.drugs = _.reject($scope.drugs, function (d) {
                return d.drug_json.uuid === drug.drug_json.uuid;
              });
            }
          });
      });

      function editDrug($event, drug) {
        drugEditor.setDrug(drug);
        $scope.search.drug = false;
        $state.go('profile.drugs.edit.dose');
      }
    }
  ]);

angular.module('routes.purchase', [
    'ui.router',
    'user',
    'config',
    'common',
    'sidebar'
  ])

  //.constant('routes.purchase.steps', {
  //  profile: {
  //    steps: [
  //      { key: 'location', state: 'ob.location' },
  //      { key: 'family', state: 'ob.family' },
  //      { key: 'doctors', state: 'ob.doctors' },
  //      { key: 'drugs', state: 'ob.drugs' },
  //      { key: 'illnesses', state: 'ob.illnesses' },
  //      { key: 'savings', state: 'ob.savings' }
  //    ]
  //  },
  //
  //  plan: {
  //    steps: [
  //      { key: 'recommended', state: 'recommended' },
  //      { key: 'compare', state: 'compare' }
  //    ]
  //  },
  //
  //  apply: {
  //    steps: [
  //      { key: 'qualify', state: 'buy.qualify' },
  //      { key: 'address', state: 'buy.address' },
  //      { key: 'applicants', state: 'buy.applicants' },
  //      { key: 'extras', state: 'buy.extras' },
  //      { key: 'billing', state: 'buy.billing' },
  //      { key: 'confirm', state: 'buy.confirm' },
  //      { key: 'eSign', state: 'buy.eSign' }
  //    ]
  //  }
  //})

  .service('routes.purchase.steps', ['sidebar.steps.config', function (config) {
    return angular.copy(_.pick(config, ['profile', 'plan', 'apply']));
  }])

  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {

      $stateProvider.state('purchase', {
        abstract: true,
        parent: 'sidebar',
        views: {
          'main@sidebar': {
            templateUrl: paths.partials + '/routes/purchase/main.html',
            controller: ['$scope', 'routes.purchase.steps', function ($scope, steps) {
              _.each(steps, function (step) {
                _.each(step.steps, function (step) {
                  step.done = false;
                });
              });
              $scope.steps = steps;
            }]
          },
          'side@sidebar': {
            templateUrl: paths.partials + '/routes/purchase/nav.html',
            controller: 'routes.purchase.controller'
          }
        }
      })

    }
  ]);

angular.module('routes.purchase')
  .controller('routes.purchase.controller', [
    '$scope',
    '$state',
    'utils',
    'baseHealthApp',
    'baseUser',
    'services.date',
    'routes.purchase.steps',
    'cart.service',
    function ($scope, $state, utils, applicationModel, userModel, dateService, steps, cartService) {
      var progress = {
        profile: {
          active: false,
          open: false,
          done: false,
          disabled: false
        },
        plan: {
          active: false,
          open: false,
          done: false,
          disabled: false
        },
        dental: {
          active: false,
          open: false,
          done: false,
          disabled: false
        },
        apply: {
          active: false,
          open: false,
          done: false,
          disabled: false
        }
      };

      $scope.steps = steps;

      //if (dateService.isOpenEnrollment(new Date(), applicationModel)) {
      //  utils.remove($scope.steps.apply.steps, {key: 'qualify'});
      //}

      $scope.goIfDone = function (step, toState) {
        if (step.done) {
          $state.go(toState);
        }
      };

      if (applicationModel.isComplete()) {
        $state.replace('dashboard');
        return;
      }

      // kick them out of the purchase flow on logout
      //$scope.$watch('userModel.isLoggedIn', function (newValue, oldValue) {
      //  if (newValue !== oldValue && newValue === false) {
      //    $state.go('home');
      //  }
      //});

      $scope.$watch(function () {
        return cartService.hasAppType('dental');
      }, function (hasDental) {
        progress.dental.done = hasDental;
      });

      $scope.$on('$stateChangeSuccess', function ($event, toState) {
        var section = toState.data && toState.data.step || null;

        if (!section){
          return;
        }

        // resets
        progress.profile.active = progress.profile.done = false;
        progress.plan.active = progress.plan.done = false;
        progress.apply.active = progress.apply.done = false;
        progress.dental.active = progress.dental.done = false;

        if (applicationModel.isComplete()) {
          //progress.profile.done = progress.plan.done = progress.apply.done = progress.dental.done = true;
          progress.profile.open = progress.plan.open = progress.apply.open = progress.dental.open = false;
          progress.profile.disabled = progress.plan.disabled = progress.apply.disabled = progress.dental.disabled = true;

          if (!$state.is('buy.submitted')) {
            $state.replace('dashboard');
          }
        }
        else {
          switch (section) {
            case 'plan':
              progress.plan.open =
                progress.profile.done =
                  progress.plan.active = true;
              break;
            case 'dental':
              progress.dental.open =
                progress.profile.done =
                  progress.dental.active = true;
              break;
            case 'apply':
              progress.apply.open =
                progress.profile.done =
                  progress.plan.done =
                    progress.apply.active = true;

              progress.dental.done = cartService.hasAppType('dental');

              break;
            default:
              progress.profile.open =
                progress.profile.active = true;
              break;
          }
        }

        $scope.progress = progress;

        var currentSection = $scope.steps[section];
        var currentIndex = utils.indexOf(currentSection.steps, function (item) {
          return $state.includes(item.state);
        });

        if (currentIndex >= 0) {
          _.each(currentSection.steps, function (item, index) {
            item.active = index === currentIndex;
            item.done = currentIndex > index;
          });
        }

        _.each($scope.steps, function (section) {
          _.each(section.steps, function (item) {
            if (section !== currentSection) {
              item.active = false;
            }

            if (_.isFunction(item.isHidden)) {
              item.hidden = item.isHidden($scope, applicationModel);
            }
            else {
              item.hidden = false;
            }
          });
        });

      });
      
    }
  ]);
angular.module('routes.refer', ['ui.router', 'config', 'user'])
  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths) {

      $stateProvider
        .state('refer', {
          parent: 'base',
          url: '/refer',
          templateUrl: paths.partials + '/routes/refer/refer.html',
          controller: 'routes.refer.controller',
          data: {
            iconHeadline: 'refer.iconHeadline',
            scrollTop: true
          }
        })
        .state('refer.create', {
          url: '/create-account',
          views: {
            'refer-hero': {
              templateUrl: paths.partials + '/routes/refer/create-account.html',
              controller: 'user.login.controller'
            }
          },
          data: {
            successState: 'refer.dashboard',
            source: 'refer'
          }

        })
        .state('refer.login', {
          url: '/login',
          views: {
            'refer-hero': {
              templateUrl: paths.partials + '/routes/refer/login.html',
              controller: 'user.login.controller'
            }
          },
          data: {
            successState: 'refer.dashboard'
          }

        })
        .state('refer.dashboard', {
          url: '/dashboard',
          views: {
            'refer-hero': {
              templateUrl: paths.partials + '/routes/refer/dashboard.html',
              controller: 'routes.refer.dashboard.controller'
            },
            'refer-news': {
              template: '<div></div>'
            }
          },
          data: {
            authenticate: true,
            unAuthState: 'refer.create'
          },
          resolve: {
            code: ['services.promo', function(promoService){
              return promoService.getCode();
            }]
          }
        })
        .state('refer.dashboard.email', {
          url: '/email',
          templateUrl: paths.partials + '/routes/refer/email.html'
        })


        .state('refer.join', {
          url: '/join',
          views: {
            'refer-headline': {
              template: '<h2 class="headline" sh-translate="refer.join.headline"></h2>'
            },
            'refer-legal': {
              template: '<div></div>'
            }
          },
          data: {
            iconHeadline: 'refer.join.iconHeadline',
            successState: 'ob'
          }
        })
        .state('refer.join.create', {
          url: '/create-account',
          views: {
            'refer-hero@refer': {
              templateUrl: paths.partials + '/routes/refer/join-create.html',
              controller: 'user.login.controller'
            }
          }
        })
        .state('refer.join.login', {
          url: '/login',
          views: {
            'refer-hero@refer': {
              templateUrl: paths.partials + '/routes/refer/login.html',
              controller: 'user.login.controller'
            }
          }
        })

    }
  ]);
angular.module('routes.refer')
  .controller('routes.refer.dashboard.controller', [
    '$scope',
    '$state',
    '$location',
    'user.model',
    'application.model',
    'services.share',
    'services.email',
    'services.promo',
    'utils',
    'code',
    function($scope, $state, $location, userModel, applicationModel, shareService, emailService, promoService, utils, code){
      var firstName = '', lastName = '';

      if (applicationModel.getPrimary()){
        firstName = applicationModel.getPrimary().name.first;
        lastName = applicationModel.getPrimary().name.last;
      }

      var viewModel = {
        openPopup   : shareService.openPopup,
        promoUrl    : utils.getAbsBaseUrl() + '/refer/join?ref=' + code,
        emails      : '',
        firstName   : firstName,
        lastName    : lastName
      };

      $scope.invite = function(){
        if (viewModel.emails && viewModel.firstName){
          emailService.sendToMany(
            'sendReferFriendEmail',
            viewModel.emails,
            {
              fullName: viewModel.firstName + ' ' + viewModel.lastName,
              promotionUrl: viewModel.promoUrl
            },
            30
          );
          $state.go('^');
        }
      };

      $scope.viewModel = viewModel;

      promoService.getStats(code)
        .then(function(stats){
          _.each(stats, function(stat){
            viewModel[stat.name] = stat.count;
          });
        });
    }
  ]);
angular.module('routes.refer')
  .controller('routes.refer.controller', [
    '$scope',
    '$state',
    'baseUser',
    function($scope, $state, userModel){

      $scope.$on('$stateChangeSuccess', function(){
        var loggedIn = userModel.isLoggedIn;

        if ($state.is('refer') && loggedIn){
          redirect('refer.dashboard');
        }

        if ($state.is('refer.join') && !loggedIn){
          redirect('refer.join.create');
        }
        else if ($state.includes('refer.join') && loggedIn){
          redirect('ob');
        }


        function redirect(to){
          $state.go(to, null, { location: 'replace' });
        }
      });
    }
  ]);
/**
 * @module routes.subsidy
 * @namespace routes.subsidy
 */

angular.module('routes.subsidy', [
  'ui.router',
  'user',
  'config',
  'common',
  'search',
  'application',
  'plan',
  'profile',
  'billing',
  'sidebar',
  'member'
  ])

  .service('routes.subsidy.steps', ['sidebar.steps.config', function(config){
    return angular.copy(_.pick(config, ['profile', 'plan', 'subsidy']));
  }])

  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths){

      // this state simply checks on the application subsidy status
      // and grabs the state config from content to see whether to direct
      // to one of the state buy flows or ffm
      $stateProvider
        .state('subsidy', {
          url: '/subsidy',
          parent: 'sidebar',
          resolve: {
            stateConfig: ['baseHealthApp', 'search.geo', function(applicationModel, geoSearch){
              var stateCode = applicationModel.getState();
              if (!stateCode) {
                return null;
              }

              return geoSearch.getStateConfig(stateCode);
            }],
            isOep: ['services.date', 'baseHealthApp', function(dateService, applicationModel){
              return dateService.isOepAsync({ onExchange: applicationModel.hasSubsidy(), state: applicationModel.getState() });
            }]
          },
          views: {
            'main': {
              templateUrl: paths.partials + '/routes/subsidy/subsidy.html',
              controller: 'routes.subsidy.controller'
            },
            'side@sidebar': {
              templateUrl: paths.partials + '/routes/subsidy/sidebar.html',
              controller: 'routes.subsidy.sidebar.controller'
            }
          },

          data: {
            authenticate: true,
            tokens: {}
          }
        })
        .state('subsidy.decline', {
          url: '/decline',
          templateUrl: paths.partials + '/routes/subsidy/calculate/calculate.html',
          controller: 'routes.subsidy.calculate.controller',
          data: {
            continueState: 'buy'
          }
        })

        .state('subsidy.support', {
          url: '/support/:state',
          templateUrl: paths.partials + '/routes/subsidy/support/support.html',
          controller: [
            '$scope',
            'stateConfig',
            function($scope, stateConfig){
              $scope.stateName = stateConfig.name;
            }
          ]
        })

        .state('subsidy.qualify', {
          url: '/qualify',
          controller: 'profile.qualify.controller',
          templateUrl: paths.partials + '/components/profile/qualify/event.html',
          data: {
            status: 'qualify',
            nextState: 'subsidy'
          }
        })

        .state('subsidy.qualify.date', {
          url: '/date',
          templateUrl: paths.partials + '/components/profile/qualify/event-date.html'
        });

    }
  ])
  .controller('routes.subsidy.controller', [
    '$scope',
    '$state',
    '$timeout',
    'stateConfig',
    'services.auth',
    'baseHealthApp',
    'baseUser',
    'isOep',
    function($scope, $state, $timeout, stateConfig, authService, applicationModel, userModel, isOep){
      // TODO: set up a route validator that looks for validateRoute method on the state data

      // let auth service take care of this rerouting
      if (!authService.isAuthenticated()) {
        return;
      }

      if (applicationModel.isComplete()){
        return $state.go('dashboard');
      }
      //var hasSeenOepGate = false;

      $scope.$on('$stateChangeSuccess', function($event, toState){
        if (toState.name === 'subsidy'){
          doRedirect();
        }
      });

      if (!$state.is('subsidy')){
        doRedirect();
      }

      $scope.stateConfig = stateConfig;
      $state.current.data.tokens.state = stateConfig.name;

      $scope.decline = function(){
        return applicationModel.killSubsidy()
          .save(userModel)
          .then(function(){
            return $state.go('recommended');
          });
      };

      function doRedirect(){
        var redirectRoute;
        var redirectRouteParams;
        //var isOep = $scope.globals.isOep;
        var plan = applicationModel.getPlan();

        if (applicationModel.isComplete() && $state.current.name.indexOf('.submitted') === -1) {
          redirectRoute = 'dashboard';
        }
        else if (!stateConfig) {
          redirectRoute = 'invalid-region';
        }
        else if (!applicationModel.hasPlan()) {
          redirectRoute = 'ob';
        }
        //else if (!applicationModel.hasSubsidy() || !plan.qhpStatus) {
        // we only care about qhpStatus now, since users can see all exchange plans regardless of subsidy
        else if (!plan.qhpStatus) {
          redirectRoute = 'recommended';
        }

        else if ((!stateConfig.stateExchange || !stateConfig.stateExchange.isActive) && !stateConfig.ffm) {
          redirectRoute = 'subsidy.support';
          redirectRouteParams = { state: stateConfig.key };
        }

        // wipe the plan off if returning customer's plan is 2015 and it's no longer SEP
        else if (!plan.planYear || plan.planYear < 2016){
          applicationModel.setPlan(userModel, null);
          redirectRoute = 'recommended';
        }

        else if (stateConfig.ffm && !stateConfig.stateExchange.isActive){
          redirectRoute = 'ffm';
        }

        //// if they've picked a 2016 plan and it's not open enrollment yet
        //else if (plan.planYear === 2016 && now.getFullYear() !== 2016 && !isOep){
        //  redirectRoute = 'subsidy.preOep';
        //}
        //
        //else if (!hasSeenOepGate && plan.planYear !== 2016 && !$state.includes('ffm')){
        //  hasSeenOepGate = true;
        //  redirectRoute = 'subsidy.preOep';
        //}

        else if (!applicationModel.hasLifeEvent() && !isOep) {
          redirectRoute = 'subsidy.qualify';
        }

        else if ($state.is('subsidy') || !applicationModel.get().addressId){
          redirectRoute = 'exchange';
          redirectRouteParams = { stateCode: stateConfig.key };
        }

        if (redirectRoute && !$state.includes(redirectRoute, redirectRouteParams)){
          $timeout(function(){
            $state.go(redirectRoute, redirectRouteParams, { location: 'replace' });
          });
        }
      }
    }
  ])
  .controller('routes.subsidy.sidebar.controller', [
    '$scope',
    'routes.subsidy.steps',
    function($scope, steps){
      $scope.steps = steps;
    }
  ]);

angular.module('routes.user', ['ui.router', 'user', 'config', 'search'])
  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths){

      $stateProvider
        .state('account', {
          parent: 'base',
          abstract: true,
          templateUrl: paths.partials + '/routes/user/account/account.html',
          data: {
            authPassThrough: true,
            source: 'account'
          }
        })

        .state('account.login', {
          url: '/login?user&redirect',
          templateUrl: paths.partials + '/routes/user/account/login.html',
          controller: 'user.login.controller',
          data: {
            successState: 'dashboard'
          }
        })
        .state('account.create', {
          url: '/create?source&redirect',
          controller: 'user.login.controller',
          templateUrl: paths.partials + '/routes/user/account/create.html',
          params: {
            source: null
          },
          data: {
            errorState: 'account.login',
            successState: 'dashboard'
          }
        })
        .state('account.verify', {
          url: '/verify/:code',
          templateUrl: paths.partials + '/routes/user/account/verify.html',
          controller: 'user.verify.controller',
          data: {
            unAuthState: 'account.login',
            authenticate: true,
            authPassThrough: false
          }
        })
        .state('account.requestReset', {
          url: '/reset',
          templateUrl: paths.partials + '/routes/user/account/reset-request.html',
          controller: 'user.reset.controller'

        })
        .state('account.reset', {
          url: '/reset/:email/:code',
          templateUrl: paths.partials + '/routes/user/account/reset.html',
          controller: 'user.reset.controller'
        });
    }
  ]);

// modified from ui.bootstrap

angular.module('common.directives')

  .constant('accordion.config', {
    closeOthers: true
  })

  .controller('accordion.controller', [
    '$scope',
    '$attrs',
    'accordion.config',
    function ($scope, $attrs, accordionConfig) {

      // This array keeps track of the accordion groups
      var groups = [];

      // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if ( closeOthers ) {
          angular.forEach(groups, function (group) {
            if ( group !== openGroup ) {
              group.isOpen = false;
            }
          });
        }
      };

      // This is called from the accordion-group directive to add itself to the accordion
      this.addGroup = function(groupScope) {
        groups.push(groupScope);
        groupScope.$on('$destroy', function(){
          removeGroup(groupScope);
        });
      };

      // This is called from the accordion-group directive when to remove itself
      function removeGroup(group) {
        var index = groups.indexOf(group);
        if ( index !== -1 ) {
          groups.splice(index, 1);
        }
      }
    }
  ])

// The accordion directive simply sets up the directive controller
  .directive('shAccordion', [
    function () {
      return {
        restrict:'EA',
        controller:'accordion.controller',
        link: function($scope, $element){
          $element.addClass('accordion collapsible');
        }
      };
    }]
  )

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
  .directive('shAccordionGroup', [
    'config.paths',
    'services.tracking',
    function(paths, trackingService) {
      return {
        require:'?^shAccordion',         // We need this directive to be inside an accordion
        restrict:'EA',
        transclude:true,              // It transcludes the contents of the directive into the template
        replace: true,                // The element containing the directive will be replaced with the template
        templateUrl: paths.partials + '/common/directives/accordion/accordion-group.html',
        scope: {
          heading: '@',               // Interpolate the heading attribute onto this scope
          startOpen: '=?',
          isDisabled: '=?',
          scrollTo: '=?',
          isOpen: '=?'
        },
        controller: function() {
          this.setHeading = function($element) {
            this.heading = $element;
          };
        },
        link: function($scope, $element, $attr, accordionCtrl) {
          if (!accordionCtrl) {
            return;
          }

          accordionCtrl.addGroup($scope);

          if ($scope.startOpen){
            $scope.isOpen = true;
          }

          $scope.$watch('isOpen', function(value) {
            if ( value ) {
              accordionCtrl.closeOthers($scope);
            }
            //else {
            //  $scope.startOpen = false;
            //}
          });

          if ($attr.openOn){
            $scope.$on($attr.openOn, function(){
              $scope.isOpen = true;
            });
          }

          $attr.$observe('open', function(value){
            if (value === 'true'){
              $scope.isOpen = true;
            }
          });

          $scope.toggleOpen = function() {
            if ( !$scope.isDisabled ) {
              $scope.isOpen = !$scope.isOpen;

              if ($attr.mixpanelOpenEvent){
                var props = $attr.mixpanelEventProps;
                props = props ? $scope.$eval(props) : {};
                props.Active = $scope.isOpen;

                trackingService.mixpanelEvent($attr.mixpanelOpenEvent, props);
              }
            }
          };
        }
      };
    }
  ])

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
  .directive('shAccordionHeading', function() {
    return {
      restrict: 'EA',
      transclude: true,   // Grab the contents to be used as the heading
      template: '',       // In effect remove this element!
      replace: true,
      require: '^shAccordionGroup',
      link: function(scope, element, attr, accordionGroupCtrl, transclude) {
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, function() {}));
      }
    };
  })

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
  .directive('shAccordionTransclude', function() {
    return {
      require: '^shAccordionGroup',
      link: function(scope, element, attr, controller) {
        scope.$watch(function() { return controller[attr.shAccordionTransclude]; }, function(heading) {
          if ( heading ) {
            element.html('');
            element.append(heading);
          }
        });
      }
    };
  });
angular.module('common.directives')
  .directive('shAddButton', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          translateKey: '@',
          text: '@',
          disableButton: '=?',
          formatValue: '@'
        },
        templateUrl: paths.partials + '/common/directives/add-button/add-button.html',
        link: function($scope){

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shAlertBanner', [
    '$filter',
    '$timeout',
    'config.paths',
    'translate.service',
    'services.alert',
    function($filter, $timeout, paths, translateService, alertService){

      return {
        scope: true,
        templateUrl: function($element, $attr){
          return paths.partials + ($attr.templateUrl || '/common/directives/alert/banner.html');
        },
        link: function($scope, $element, $attr){
          // messages is an array even though only one is ever show
          // so by swapping out the old message for the new message,
          // the old will animate out and the new in

          var setHeight = _.debounce(function(){

            var height = 0;
            var el = null;

            if ($scope.warning){
              el = $element.find('.warning')[0];
            }
            else if ($scope.messages.length){
              el = $element.find('.message')[0];
            }

            if (el){
              height = el.scrollHeight;
            }

            $element.height(height);

          }, 200);


          $scope.messages = [];
          $scope.warning = null;

          $attr.$observe('message', function(newValue){
            if (!_.isUndefined(newValue)){
              alertService.setMessage($scope.$eval(newValue));
            }
          });

          $attr.$observe('warning', function(newValue){
            if (!_.isUndefined(newValue)) {
              alertService.setWarning($scope.$eval(newValue));
            }
          });


          $scope.$watch(alertService.getMessage, function(newMessage){
            var current = $scope.messages[0];

            if (!angular.equals(current, newMessage)) {

              if (current && newMessage && newMessage.text && !newMessage.animate){
                current.text = newMessage.text;
              }
              // only the model data has changed so just update and don't slide in
              else if (current && newMessage && current.key == newMessage.key){
                current.model = newMessage.model;
              }
              else {
                $scope.messages = newMessage ? [newMessage] : [];
              }

              setHeight();
            }
          });

          $scope.$watch(alertService.getWarning, function(newWarning){
            $scope.warning = newWarning;
            setHeight();
          });

          $scope.$watch(function(){ return $element.text() }, setHeight);
          $scope.$on('delayed-resize', setHeight);

          $scope.$on('$destroy', function(){
            alertService.setWarning(null);
            alertService.setMessage(null);
          });
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('mixpanelEvent', [
    'services.tracking',
    function(trackingService){
      return {
        restrict: 'A',
        link: function($scope, $element, $attr){
          $element.on('click', function(){
            var name = $attr.mixpanelEvent;
            var props = $scope.$eval($attr.eventProps);
            var userProps = $scope.$eval($attr.userProps);

            trackingService.mixpanelEvent(name, props);

            if (_.isObject(userProps)){
              trackingService.setPeopleProps(userProps);
            }
          });
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shTrackEvent', [
  'services.tracking',
  function(trackingService){
    return {
      restrict: 'A',
      link: function($scope, $element, $attrs){

        var category = $attrs.eventCategory || $element.prop('tagName').toLowerCase();
        var action = $attrs.eventAction || 'click';
        var label = $attrs.eventLabel;
        var value = $attrs.eventValue;

        $element.on('click', function(){
          trackingService.event(category, action, label, value);
        });
      }
    }
  }
]);
angular.module('common.directives')
  .directive('shListSummary', [
    '$compile',
    'utils',
    'config.paths',
    function($compile, utils, paths){
      return {
        scope: {
          list: '=shListSummary',
          translateBase: '@',
          key: '@'
        },
        templateUrl: paths.partials + '/common/directives/applicant/list-summary.html',
        controller: ['$scope', function($scope){
          $scope.useTranslate = angular.isDefined($scope.translateBase);
          $scope.listNames = _.map($scope.list, function(item){
            var value = utils.traverse(item, $scope.key);
            return value && ($scope.useTranslate ? $scope.translateBase + '.' + value : value);
          });
        }]
      }
    }
  ]);
angular.module('common.directives')
  .directive('shBottomButton', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          translateKey: '@',
          text: '=',
          form: '=',
          onNext: '&',
          onError: '&',
          disableButton: '=?',
          formatValue: '@'
        },
        templateUrl: paths.partials + '/common/directives/bottom-button/bottom-button.html',
        link: function($scope){

          //if (!_.isBoolean($scope.disableButton)){
          //  $scope.disableButton = true;
          //}

          $scope.onClick = function($event){
            if ($scope.pending) return;

            if (!$scope.form || $scope.form.$valid){
              if ($event){
                $event.preventDefault();
                $event.stopPropagation();
              }

              $scope.onNext();
            }
            else {
              if (_.isFunction($scope.onError)){
                $scope.onError();
              }
            }
          };
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shBottomLink', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          translateKey: '@',
          text: '=',
          onNext: '&',
          disable: '=?',
          onError: '&',
          formatValue: '@'
        },
        templateUrl: paths.partials + '/common/directives/bottom-link/bottom-link.html',
        link: function ($scope) {

          if (!_.isBoolean($scope.disable)) {
            $scope.disable = true;
          }

          $scope.onClick = function ($event) {
            if ($scope.pending) return;
            if ($scope.disable) return;

            if (_.isFunction($scope.onError)) {
              $scope.onError();
            }

            if ($event) {
              $event.preventDefault();
              $event.stopPropagation();
            }

            $scope.onNext();
          };
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('buttonSelect', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          labelKey: '@',
          label: '@',
          messageKey: '@',
          message: '@',
          disable: '=?',
          selected: '=',
          selectAction: '&'
        },
        templateUrl: paths.partials + '/common/directives/button-select/button-select.html',

        controller: ['$scope', function ($scope) {
          $scope.onClick = function ($event) {
            $scope.selectAction();
          };
        }]

      }
    }
  ]);
angular.module('common.directives')
  .directive('checkList', ['config', function(config){
    return {
      templateUrl: config.paths.partials + '/common/directives/check-list/template.html',
      restrict: 'E',
      transclude: true,
      scope: {
        onToggle: '&',
        list: '=',
        selected: '=',
        titleKey: '@',
        descKey: '@?'
      },
      link: function($scope){
        $scope.isSelected = function(item){
          return _.contains($scope.selected, item);
        };
      }
    };
  }]);
angular.module('common.directives')
  .directive('customerStories', ['config', function(config){

    return {
      scope: {
        noOuts: '=?'
      },
      templateUrl: config.paths.partials + '/common/directives/customer-stories/template.html',
      controllerAs: 'storiesCtrl',
      controller: ['$scope', function($scope){

        // TODO: make this a content type in contentful
        // the directive should have an attribute that points to the contentful key of
        // all the stories that it wants to include
        this.stories = [
          {
            url: 'https://images.contentful.com/heg7gyzix6dq/6UrdBdYjrGwM8WcokKAssm/a97fd5258a6e31dff968472082d04a4c/hatchback.jpg',
            mobileurl: 'https://images.contentful.com/heg7gyzix6dq/jgmNQXtmLu6KseuyMi4WS/093c6838493e2046b8e415a21ac091bc/megan_mobile.png',
            quote: 'The BIG game changer was being able to communicate with a live, responsive person who answered all my questions.',
            name: 'Megan McDuffie, Wandering Chef',
            linktext: 'Read her story',
            blogurl: 'http://blog.stridehealth.com/post/customer-stories-megan-mcduffie'
          },
          {
            url: 'https://images.contentful.com/heg7gyzix6dq/laGtA1HZAsy4kyIYwYeS8/3531aea616ea18bc57d3db7523af1f63/Lacee.jpg',
            mobileurl: 'https://images.contentful.com/heg7gyzix6dq/siSIyLz5FAmUA4GW4EWSO/60fa0e4cddcfdcbf3ac6c6f986220735/lacee_mobile.png',
            quote: 'Sign up for Stride if you work for yourself and are looking for the best health coverage options with customer care that goes above and beyond.',
            name: 'Lacee Lazoff, Personal Trainer',
            linktext: 'Read her story',
            blogurl: 'http://blog.stridehealth.com/post/customer-story-lacee-lazoff',
            position: 'right'
          },
          {
            url: 'https://images.contentful.com/heg7gyzix6dq/31wF5FTH0QQuSmugo2mwmg/dcf6160a232c187441ba583457df6a68/Jeremy.jpg',
            mobileurl: 'https://images.contentful.com/heg7gyzix6dq/6DAlcuxSKsG0GsceKAsCeu/b12ea589365522de78ff20c68627cc76/jeremy_mobile.png',
            quote: 'Stride’s health care recommendation engine was totally needed. The process was really easy, and I didn’t even have to interact with Kaiser.',
            name: 'Jeremy Bluvol, Entrepreneur',
            linktext: 'Read his story',
            blogurl: 'http://blog.stridehealth.com/post/customer-story-jeremy-bluvol'
          },
          {
            url: 'https://images.contentful.com/heg7gyzix6dq/zdATfSsPn2GcKuIO2ugYG/695f3b7a25f39863bd181a6ff5945d62/Peter.jpg',
            mobileurl: 'https://images.contentful.com/heg7gyzix6dq/5KXjhlAP1SoiwUm4OEqQoG/8c74af97d37efed12e878daa01c65d9e/peter_mobile.png',
            quote: 'I wouldn’t have been able to get the health care I wanted without Stride’s help.',
            name: 'Peter Giacalone, Real Estate Agent',
            linktext: 'Read his story',
            blogurl: 'http://blog.stridehealth.com/post/customer-story-peter-giacalone',
            position: 'left'
          }
        ];

        if (!this.currentStory) {
          this.currentStory = this.stories[0];
        }

        this.showStory = function (index) {
          this.currentStory = this.stories[index];
        };
      }]
    };
  }]);
angular.module('common.directives')
  .directive('shDateDropdowns', [
    'config.paths',
    '$timeout',
    'services.date',
    function(paths, $timeout, dateService){
      var ngCopy = angular.copy;
      var isDate = angular.isDate;
      var today = new Date();
      var thisYear = today.getFullYear();
      var dayValues = _.times(31, function(index){ return index + 1; });
      var monthValues = _.times(12, function(index){ return index; });
      var yearValues = _.times(100, function(index){ return thisYear - index; }); // do years in reverse order
      var thirtyDayMonths = [3, 5, 8, 10];


      return {
        templateUrl: paths.partials + '/common/directives/date/dropdowns.html',
        scope: {
          model: '=',
          omitDay: '@',
          onDateChange: '&',
          range: '=',
          omitTime: '=',
          optional: '=?'
        },
        link: function($scope, $element, $attr){

          var inputs = {
            day: null,
            month: null,
            year: null
          };
          var cachedDays;
          var initialDate = $scope.model ? new Date($scope.model) : null;
          setDateRange($scope.range);

          if (_.isString($scope.model) && $scope.omitTime){
            initialDate = dateService.fromIsoDate($scope.model);
          }

          if (isDate(initialDate)){
            inputs.day = initialDate.getDate();
            inputs.month = initialDate.getMonth();
            inputs.year = initialDate.getFullYear();
          }
          else if ($attr.age && !isNaN(Number($attr.age))){
            inputs.year = thisYear - Number($attr.age);
          }

          // just set to the first day of the month and worry about month/year validation
          if ($scope.omitDay){
            inputs.day = 1;
          }

          $scope.inputs = inputs;

          cachedDays = ngCopy($scope.days);

          $scope.onChange = function(form){
            updateDays();
            var valid = false;
            var date;

            if (_.isNumber(inputs.year) && _.isNumber(inputs.month) && _.isNumber(inputs.day)) {
              date = new Date(inputs.year, inputs.month, inputs.day);
              valid = date.getMonth() === inputs.month && date.getDate() === inputs.day && isWithinBounds(date);
            }

            if (form) {
              form.$setValidity('date', valid);
            }

            if (valid) {
              if ($scope.omitTime){
                $scope.model = dateService.toIsoDate(date);
              }
              else {
                $scope.model = date;
              }

              if (_.isFunction($scope.onDateChange)){
                $timeout($scope.onDateChange);
              }
            }
          };

          function isWithinBounds(date){
            return !_.isArray($scope.range) || (
              (!isDate($scope.range[0]) || date.getTime() >= $scope.range[0].getTime()) &&
              (!isDate($scope.range[1]) || date.getTime() <= $scope.range[1].getTime())
            );
          }

          function updateDays(){
            var copy = ngCopy(cachedDays);

            if (inputs.month) {
              if (inputs.month === 1) {
                copy.length = 29;
              }
              else if (_.contains(thirtyDayMonths, inputs.month)) {
                copy.length = 30;
              }

              // if not a full year, look for chance to cut days off
              if ($scope.months.length < 12){

                // if at the earliest month, cut days off front
                if ($scope.months[0] === inputs.month){
                  copy = copy.slice($scope.range[0].getDate() - 1);
                }
                // if last month, cut off the end
                else if ($scope.months[$scope.months.length - 1] === inputs.month){
                  copy.length = $scope.range[1].getDate();
                }
              }
            }

            // nullify day if no longer in the valid set
            if (copy.indexOf(inputs.day) === -1){
              inputs.day = null;
            }

            $scope.days = copy;
          }

          function setDateRange(range){

            // prune the set of choices based on date range

            if (_.isArray(range)){
              var minDate = range[0];
              var maxDate = range[1];

              var minYear = minDate.getFullYear();
              var maxYear = maxDate.getFullYear();

              var minMonth = minDate.getMonth();
              var maxMonth = maxDate.getMonth();
              var monthDiff = (maxYear - minYear) * 12 + (maxMonth - minMonth) + 1; // from http://stackoverflow.com/a/15158873

              $scope.years = _.times(maxYear - minYear + 1, function(n){ return minYear + n; });

              if (monthDiff < 12){
                $scope.months = _.times(monthDiff, function(n){ return (minMonth + n) % 12; });
              }
              else {
                $scope.months = monthValues;
              }
            }
            else {
              $scope.months = monthValues;
              $scope.years = yearValues;
            }

            // days are modified in the updateDays method
            $scope.days = dayValues;

            if ($scope.years.length === 1){
              inputs.year = $scope.years[0];
            }

            if ($scope.months.length === 1){
              inputs.month = $scope.months[0];
            }
          }
        }
      };

    }
  ]);
angular.module('common.directives')
  .directive('shLocaleDate', [
    'user.model',
    'services.date',
    function(userModel, dateService){
      return {
        scope: {
          date: '=shLocaleDate',
          omitYear: '=?'
        },
        template: '{{ monthKey | translate }} {{ day | shOrdinal:locale }}<span ng-if="!omitYear">, {{ year }}</span>',
        link: function($scope){
          $scope.$watch('date', function(){
            var date = $scope.date;

            if (_.isString($scope.date)){
              date = dateService.fromIsoDate($scope.date);
            }

            //var date = dateService.getDate($scope.date);
            if (!date) return;

            $scope.locale = userModel.getLocale();
            $scope.year = date.getFullYear();
            $scope.monthKey = 'shared.months.' + date.getMonth();
            $scope.day = date.getDate();
          });

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shDateOfBirth', [
    'config.paths',
    '$timeout',
    'services.date',
    '$filter',
    function (paths, $timeout, dateService, $filter) {

      return {
        templateUrl: paths.partials + '/common/directives/dateofbirth/dateofbirth.html',
        scope: {
          model: '=',
          form: '=',
          dobMessage: '@',
          validDOB: '&'
        },
        link: function ($scope, $element, $attr) {
          $scope.checkInput = function () {
            var inputLength = $scope.form.dob.$viewValue.length;

            if (inputLength > 0 && inputLength !== 10) {
              $scope.errorKey = 'errors.dateOfBirth.fullDate';
              $scope.invalidInput = true;
            } else {
              $scope.invalidInput = false;
            }
          };

          $scope.checkDOB = function (validDate, isoDate) {
            $scope.validDOB = validDate;
            $scope.invalidInput = false;
            $scope.errorKey = 'errors.dateOfBirth.invalid';

            if (isoDate) {
              // If iso date isn't length 10, it isn't a valid date
              if (isoDate.length !== 10) {
                $scope.validDOB = false;
                return;
              }

              // Check if the DOB is not in the future
              var dob = dateService.fromIsoDate(isoDate);
              var today = new Date();
              if (dob && dob > today) {
                $scope.validDOB = false;
                $scope.errorKey = 'errors.dateOfBirth.future';
                return;
              }

              // If isoDate and validDate is okay, check min age
              if (validDate) {
                $scope.model.isoDOB = isoDate;
                $scope.model.age = dateService.getYears(dateService.fromIsoDate(isoDate), new Date());

                if ($scope.model.age < 18) {
                  $scope.validDOB = false;
                  $scope.errorKey = 'errors.dateOfBirth.minAge';
                }
              }
            }
          };
        }
      };

    }
  ]);
angular.module('common.directives')
  .directive('shDismissBlock', [
    'config.paths',
    function (paths) {
      return {
        scope: {
          text: '@',
          linkURL: '@',
          iconName: '@',
          dismissFunction: '&'
        },
        templateUrl: paths.partials + '/common/directives/dismissible-block/dismissible-block.html',
        link: function ($scope, element, attrs, ctrl) {
          $scope.dismiss = function () {
            $scope.dismissed = true;
            $scope.dismissFunction();
          }
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shGender', [
    'config',
    function(config){

      return {
        templateUrl: config.paths.partials + '/common/directives/gender/template.html',
        scope: {
          model: '=',
          formCtrl: '=',
          index: '=?'
        },
        link: function($scope){
          $scope.index = $scope.index || 0;
        }
      };

    }
  ]);
angular.module('common.directives')
  .directive('shApplicantAge', [
    'config.ages',
    function(ages){
      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, $attr, ngModelCtrl){
          var applicant = $scope.$eval($attr.shApplicantAge);
          var ageRange = ages[applicant.type];

          if (ageRange && ageRange.length == 2){
            ngModelCtrl.$validators.age = function(value){
              if (_.isString(value)){
                value = parseInt(value);
              }

              return _.isNumber(value) && value >= ageRange[0] && value <= ageRange[1];
            };
          }

          ngModelCtrl.$parsers.push(function(value){
            var intValue = parseInt(value, 10);
            return isNaN(intValue) ? value : intValue;
          })

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shCreditCard', [

    function(){
      var acceptedTypes = [
        // Visa: length 16, prefix 4, dashes optional.
        /^4\d{3}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$/,
        // Mastercard: length 16, prefix 51-55, dashes optional.
        /^5[1-5]\d{2}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}$/
      ];

      var filteredChars = /[- ]/g;

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, attrs, ngModelController){
          ngModelController.$parsers.push(function(value){
            if (angular.isDefined(value)){
              ngModelController.$setValidity('creditCard', isValidNumber(value));
              var justNumbers = value.replace(filteredChars, '');
              $element.val(insertSpaces(justNumbers));
              return justNumbers
            }
          });


        }
      };

      function insertSpaces(value){
        return value ?
               value.match(/\d{1,4}/g).join(' ') :
               ''
      }


      function isValidNumber(number){
        number = number.toString();
        var valid = false;
        var accepted = acceptedTypes.some(function(regex){
          return regex.test(number)
        });

        if (accepted){
          number = number.replace(filteredChars, '');

          var
            checksum = 0
            , i = 2 - number.length % 2
            , digit;

          // Add even digits in even length strings or odd digits in odd length strings.
          for (; i <= number.length; i += 2){
            checksum += parseInt(number.charAt(i-1));
          }
          // Analyze odd digits in even length strings or even digits in odd length strings.
          for (i = number.length % 2 + 1; i < number.length; i += 2) {
            digit = parseInt(number.charAt(i-1)) * 2;
            if (digit < 10) {
              checksum += digit;
            }
            else {
              checksum += digit - 9;
            }
          }

          valid = checksum % 10 == 0
        }

        return valid;
      }
    }

  ]);

angular.module('common.directives')
  .directive('shDate', [
    'services.inputFormat',
    '$parse',
    'services.date',
    function (inputFormatService, $parse, dateService) {

      var stripRegex = /[^\d]/g;
      var charsRegex = /^[\d\-]+$/;
      var validRegex = /^(0[1-9]|10|11|12)(0[1-9]|[12][0-9]|30|31)(\d{4})$/;

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function ($scope, $element, $attr, ngModelController) {

          var onDateChange = angular.noop;
          var dateChangeAttr = $attr.shOnChange;
          if (dateChangeAttr) {
            onDateChange = $parse(dateChangeAttr);
          }

          $scope.$watch(function () {
            return ngModelController.$modelValue;
          }, function (newValue, oldValue) {
            var validDate = false;

            if (newValue && newValue.length === 8) {
              var dateString = [newValue.slice(0, 2), ' ', newValue.slice(2)].join('');
              var inputDate = [dateString.slice(0, 5), ' ', dateString.slice(5)].join('');
              var inputDateArray = inputDate.split(' ');
              var month = parseInt(inputDateArray[0], 10);
              var date = parseInt(inputDateArray[1], 10);
              var year = parseInt(inputDateArray[2], 10);

              var jsDate = new Date(year, month - 1, date);
              validDate = month === jsDate.getUTCMonth() + 1 &&
                date === jsDate.getUTCDate() &&
                year === jsDate.getUTCFullYear();
            }

            ngModelController.$setValidity('dateExists', validDate);
            onDateChange($scope, {validDate: validDate, isoDate: dateService.toIsoDate(jsDate)});
          });

          inputFormatService.setup(ngModelController, $element, stripRegex, charsRegex, validRegex, formatValue);

          function formatValue(value) {
            if (!value) {
              return '';
            }

            value = value.split('');

            if (value.length >= 2) {
              value.splice(2, 0, '/');
            }
            if (value.length >= 5) {
              value.splice(5, 0, '/');
            }

            return value.join('');
          }
        }
      }

    }
  ]);
angular.module('common.directives')
  .service('services.inputFormat', [
    function(){

      this.setup = function(ngModelController, $element, stripRegex, charsRegex, validRegex, formatFn){
        // need to detect if they're deleting characters
        var deleting = false;

        ngModelController.$parsers.push(function(value){
          value = value || '';

          value = value.replace(stripRegex, '');
          // formatting while deleting prevents deletion of dashes
          if (!deleting) {
            $element.val(formatFn(value));
          }

          return value;
        });

        ngModelController.$validators.format = function(value){
          return ngModelController.$pristine || validRegex.test(value);
        };

        $element.on('keydown', function(e){
          deleting = e.which == 8
        }).on('keyup', function(){
          deleting = false
        });
      };

    }
  ]);
angular.module('common.directives')
  .directive('shInteger', function(){
    var regex = /^-?\d+$/;
    var positiveRegex = /^\d+$/;

    return {
      restrict: 'A',
      require: 'ngModel',
      link: function($scope, $element, $attr, ngModelCtrl){
        var isPositive = $scope.$eval($attr.shIntegerPositive) === true;
        ngModelCtrl.$validators.integer = function(value){
          if (_.isNumber(value)){
            value = value.toString();
          }

          return _.isString(value) && (isPositive ? positiveRegex.test(value) : regex.test(value));
        };
      }
    };
  });
angular.module('common.directives')
  .directive('shStripChars', [
    function(){
      return {
        require: 'ngModel',
        restrict: 'A',
        link: function($scope, $element, $attr, ngModelController){

          var stripChars = _.map($attr.shStripChars.split(''), function(char){
            return char == '\\' ? '\\\\' : char;
          });

          var stripRegex = new RegExp('(' + stripChars.join('|') + ')', 'gi');

          ngModelController.$parsers.push(function(value){
            return value && value.replace(stripRegex, '');
          });

        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shInputAppend', [
    function(){
      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, $attr, ngModelController){
          ngModelController.$formatters.push(function(value){
            var text = $attr.shInputAppend;
            return $attr.prependText ? text + value : value + text;
          });
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shNumberAbs', function(){
      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, $attr, ngModelController){
          ngModelController.$formatters.push(function(value){
            return value === null ? value : Math.abs(value);
          });
        }
      }
    }
  );
angular.module('common.directives')
  .directive('shNumberInput', [
    '$filter',
    function($filter){
      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, $attr, ngModelController){
          var stripRegex = $attr.allowNegative === "true" ? /[^0-9\.\-]/g : /[^0-9\.]/g;
          var attrType = $attr.type;
          var precision = $attr.precision || 0;
          var el = $element[0];

          function cleanAndFormat(str){
            var stripped = str.replace(stripRegex, '');
            var value = Number(stripped);
            if (!isNaN(value)){
              return value;
            }
            return null;
          }

          ngModelController.$formatters.push(function(value){
            if(attrType === 'number' || attrType === 'range'){
              return value;
            }
            return $filter('number')(value, precision);
          });

          ngModelController.$parsers.push(function(strValue){
            var cleanedNumber = cleanAndFormat(""+strValue);
            // if the input is not convertable to a number cleanedNumber will be
            // null, not formatting null
            var formatted = cleanedNumber ? $filter('number')(cleanedNumber, precision) : cleanedNumber;
            if(attrType === 'number'){
              renderViewValue(cleanedNumber);
            } else if(formatted){
              var diff = formatted.length - strValue.length;
              var start = el.selectionStart + diff;
              var end = el.selectionEnd + diff;
              renderViewValue(formatted);
              el.setSelectionRange(start, end);
            } else if(strValue === '-' && $attr.allowNegative === "true"){
            } else {
              renderViewValue(null);
            }

            return cleanedNumber;
          });

          ngModelController.$validators.numeric = function(modelValue, viewValue){
            var value = modelValue || viewValue;

            if (_.isString(value)){
              value = value.replace(stripRegex, '');
            }

            return ngModelController.$pristine || !isNaN(Number(value));
          };

          function renderViewValue(val){
            ngModelController.$setViewValue(val);
            ngModelController.$render();
          }
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shPhoneNumber', [
    'services.inputFormat',
    function(inputFormatService){

      var stripRegex = /[^\d]/g;
      var charsRegex = /^[\d\-]+$/;
      var validRegex = /^\(?\d{3}\)?-? ?\d{3}-? ?\d{4}$/;

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, attrs, ngModelController){
          inputFormatService.setup(ngModelController, $element, stripRegex, charsRegex, validRegex, formatValue);

          function formatValue(value){
            if (!value) return;
            // strip out all non digit chars
//            value = value.replace(stripRegex, '');

            // strip out a leading 1
            // if (value.charAt(0) == 1){
            //   value = value.substr(1);
            // }

            // then format how we want it to look
            value = value.split('');

            if (value.length >= 3){
              value.splice(3, 0, '-');
            }
            if (value.length >= 7){
              value.splice(7, 0, '-');
            }

            return value.join('');
          }
        }
      }

    }
  ]);
// use this directive on inputs whose values will be obscured
// after they are submitted, such as ssn and account number
// the validity check will only be performed once the user
// interacts with the value, testing against the passed in regex
angular.module('common.directives')
  .directive('shPii', [
    function(){
      var stripRegex = /[ \-]/g;

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, attrs, ngModelController){
          var regex = new RegExp(attrs.shPii);

          ngModelController.$validators.pii = function(value){
            if (angular.isDefined(value) && value != null){
              value = value.replace(stripRegex, '');

              // if it hasn't been touched and there's already a value,
              // it is x'd out pii from server
              if (!ngModelController.$dirty){
                return true;
              }
              // only do regex test if it has been edited
              else {
                return regex.test(value);
              }

            }
          };
        }
      };

    }
  ]);
angular.module('common.directives')
  .directive('shRoutingNumber', [
    function(){

      // lifted from http://www.brainjar.com/js/validation/
      function checkABA(s) {

        var i, n, t, c;

        // First, remove any non-numeric characters.

        t = "";
        for (i = 0; i < s.length; i++) {
          c = parseInt(s.charAt(i), 10);
          if (c >= 0 && c <= 9)
            t = t + c;
        }

        // Check the length, it should be nine digits.

        if (t.length != 9)
          return false;

        // Now run through each digit and calculate the total.

        n = 0;
        for (i = 0; i < t.length; i += 3) {
          n += parseInt(t.charAt(i),     10) * 3
            +  parseInt(t.charAt(i + 1), 10) * 7
            +  parseInt(t.charAt(i + 2), 10);
        }

        // If the resulting sum is an even multiple of ten (but not zero),
        // the aba routing number is good.
        return n != 0 && n % 10 == 0;
      }


      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, attrs, ngModelController){
          ngModelController.$parsers.push(function(value){
            if (angular.isDefined(value) && ngModelController.$dirty){
              var valid = checkABA(value);
              ngModelController.$setValidity('routingNumber', valid);

              return valid ? value : undefined;
            }
          })
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shSsn', [
    'services.inputFormat',
    function(inputFormatService){

      var stripRegex = /[^\dx]/g;
      var charsRegex = /^[\d\-]+$/;
      var validRegex = /^\(?\d{3}\)?-? ?\d{2}-? ?\d{4}$/g;

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, attrs, ngModelController){
          inputFormatService.setup(ngModelController, $element, stripRegex, charsRegex, validRegex, formatValue);

          function formatValue(value){
            if (!value) return;
            // strip out all non digit chars
//            value = value.replace(stripRegex, '');

            

            // then format how we want it to look
            value = value.split('');

            if (value.length >= 3){
              value.splice(3, 0, '-');
            }
            if (value.length >= 6){
              value.splice(6, 0, '-');
            }

            return value.join('');
          }
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('loader', ['config', function(config){
    return {
      transclude: true,
      scope: true,
      templateUrl: config.paths.partials + '/common/directives/loader/template.html',
      link: function($scope, $element, $attr){
        $attr.$observe('loader', function(newVal){
          $scope.ready = $scope.$eval(newVal) === true;
        });
      }
    };
  }]);
angular.module('common.directives')
  .directive('shMoney', [
    'config',
    function(config){

      return {
        templateUrl: config.paths.partials + '/common/directives/money/money.html',
        scope: {
          amount: '=shMoney',
          color: '='
        },
        link: function($scope){
          $scope.$watch('amount', function(newValue){
            $scope.amount = parseFloat(newValue);
            $scope.negative = $scope.amount < 0;
            $scope.absAmount = Math.abs($scope.amount);
          });
        }
      };

    }
  ]);
angular.module('common.directives')
  .directive('shNotification', [
    '$http',
    'config.paths',
    'notification.service',
    function ($http, paths, notificationService) {
      return {
        require: '^shNotificationList',
        scope: {
          notification: '='
        },
        templateUrl: paths.partials + '/common/directives/notification/notification.html',
        link: function ($scope, element, attrs, ctrl) {

          $scope.source = ctrl.source;

          switch ($scope.notification.messageType) {
            case 'FTUX_visit_plan_ready':
              $scope.glyphName = 'glyph-clipboard';
              break;
            case 'FTUX_free_concierge':
              $scope.glyphName = 'glyph-group';
              break;
            case 'FTUX_find_doctor':
              $scope.glyphName = 'glyph-stethoscope';
              break;
            case 'FTUX_find_drugs':
              $scope.glyphName = 'glyph-pill';
              break;
            default:
              break;
          }

          $scope.dismissNotification = function () {
            // Mark message as read
            notificationService.markAsRead($scope.notification.id)
              .then(function (response) {
                // Message has successfully been marked as read and needs to transition away
                if (response === true) {
                  $scope.dismiss = true; // This adds the class to fade out the notification
                  $scope.notification.dismissed = true;
                  ctrl.lowerCount();
                }
              });
          };
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shNotificationList', [
    '$http',
    'config.paths',
    'notification.service',
    /**
     * @param {ng.$http} $http
     * @param {config.paths} paths
     * @param {notification.service} notificationService
     */
    function ($http, paths, notificationService) {
      return {
        scope: {
          read: '=?',
          source: '@',
          user: '='
        },
        transclude: true,
        templateUrl: paths.partials + '/common/directives/notification-list/notification-list.html',
        controller: ['$scope', function ($scope) {
          $scope.render = false;
          this.source = $scope.source;

          notificationService.get({ userId: $scope.user.getId(), read: $scope.read })
            .then(function(notifications){
              $scope.notifications = notifications;
              $scope.render = true;
              $scope.notificationsLength = notifications && notifications.length || 0;
            });

          this.lowerCount = function () {
            $scope.notificationsLength--;
          };

        }]
      }
    }
  ]);
'use strict';

angular.module('common.directives')
  .directive('shRating', [
    'config.paths',
    function(paths) {
      return {
        restrict: 'A',
        templateUrl: paths.partials + '/common/directives/rating/rating.html',
        scope: {
          value: '=',
          max: '='
        },
        // instance props/methods
        link: function($scope) {
          if (!angular.isDefined($scope.value)) return;


          // make sure the value is either .5 or .0
          var val = Math.round($scope.value * 2) / 2;
          var valInt = parseInt(val);

          $scope.halfStar = val != valInt;
          $scope.fullStars = new Array(valInt);
          $scope.emptyStars = new Array($scope.max - valInt - ($scope.halfStar ? 1 : 0));
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('shRemove', [
    'config.paths',
    function(paths){

      return {
        scope: {
          onConfirm: '&'
        },
        templateUrl: paths.partials + '/common/directives/remove/remove.html',
        link: function($scope, $element){
          $scope.confirm = false;

          $scope.showConfirm = function(){
            $scope.confirm = true;
          };

          $scope.$on('doc-click', function($event, jqEvent){
            if (!$.contains($element[0], jqEvent.target)){
              $scope.$apply(function(){
                $scope.confirm = false;
              });
            }
          });
        }
      }

    }
  ]);
angular.module('common.directives')
  .directive('fbFeed', [
    'services.share',
    function(shareService){

      return {
        restrict: 'A',
        scope: {
          url: '@',
          picture: '@',
          name: '@',
          caption: '@',
          description: '@'
        },
        link: function($scope, $element){
          var keys = ['url', 'picture', 'name', 'caption', 'description'];
          $scope.$watchGroup(keys, writeHref);

          function writeHref(){
            var options = {};

            _.each(keys, function(key){
              options[key] = $scope[key];
            });

            $element.attr('href', shareService.getFeedLink(options));
          }
        }
      }
      
    }
  ]);
angular.module('common.directives')
  .directive('fbLike', [
    '$window',
    '$timeout',
    '$location',
    'config',
    'services.share',
    function($window, $timeout, $location, config, shareService){
      return {
        templateUrl: config.paths.partials + '/common/directives/social/fb-like.html',
        scope: true,
        link: function($scope, $element){
          $scope.url = 'https://www.stridehealth.com' + $location.url();

          shareService.fbReady.then(function(){
            // let attributes get set before parsing
            $timeout(function(){
              $window.FB.XFBML.parse($element.parent()[0]);
            }, 100);
          });
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('shShare', [
    '$window',
    '$document',
    'config.paths',
    'services.share',
    function($window, $document, paths, shareService){
      return {
        scope: {
          shareTitle: '@',
          shareDescription: '@',
          shareTweet: '@'
        },
        templateUrl: paths.partials + '/common/directives/social/share.html',
        link: function($scope){
          $scope.url = encodeURIComponent($window.location.href);
          $scope.title = encodeURIComponent($scope.shareTitle || $document.title);
          $scope.description = encodeURIComponent($scope.shareDescription || "");
          $scope.tweetText = $scope.shareTweet ? encodeURIComponent($scope.shareTweet) : $scope.title;

          $scope.popup = shareService.openPopup;
        }
      }
    }
  ]);
angular.module('common.directives')
  .directive('tweetBtn', [
    'services.share',
    function(shareService){

      return {
        restrict: 'A',
        scope: {
          url: '@',
          text: '@'
        },
        link: function($scope, $element){
          var keys = ['url', 'text'];
          $scope.$watchGroup(keys, writeHref);

          function writeHref(){
            var options = {};

            _.each(keys, function(key){
              options[key] = $scope[key];
            });

            $element.attr('href', shareService.getTweetLink(options));
          }
        }
      }

    }
  ]);
angular.module('common.directives')
  .directive('twitterShare', [
    '$window',
    '$timeout',
    '$location',
    'config',
    'services.share',
    function($window, $timeout, $location, config, shareService){
      return {
        templateUrl: config.paths.partials + '/common/directives/social/twitter-share.html',
        scope: {
          tweetText: '=?'
        },
        link: function($scope, $element){
          $scope.tweetText = $scope.tweetText || document.title;
          $scope.url = 'https://www.stridehealth.com' + $location.url();

          shareService.twitterReady.then(function(){
            // let attributes get set before parsing
            $timeout(function(){
              $window.twttr.widgets.load($element.parent()[0]);
            }, 100);
          });
        }
      };
    }
  ]);
angular.module('common.directives')
  .directive('stepNav', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          translateKey: '@',
          label: '=',
          disable: '=?',
          onError: '&',
          selectAction: '&',
          steps: '='
        },
        templateUrl: paths.partials + '/common/directives/step-nav/step-nav.html',
        controller: ['$rootScope', '$scope', '$state', function ($rootScope, $scope, $state) {

          // Check if any of the steps have a status. If not, this is the init of the navigation
          var isInit = !_.some($scope.steps, function (step) {
            return step.status;
          });

          // Set first step to active if this is init
          if (isInit && $scope.steps && $scope.steps.length > 0 && $scope.steps[0].status !== 'done') {
            $scope.steps[0].status = 'active';
          }

          updateToCurrentState();

          // If the user gets to the state not by clicking, update it
          $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
            updateToCurrentState();
          });

          /**
           * User clicks on a step in the navigation
           */
          $scope.clickStep = function (step) {
            if (!step.status || step.status === 'disabled') {
              return;
            }

            updateStepsStatus(step);
            $state.go(step.stateName);
          };

          function updateToCurrentState() {
            // Get the current state and update UI accordingly to disable subsequent steps and set previous steps to done
            var currentStateName = $state.current.name;
            var currentStep = _.findWhere($scope.steps, {stateName: currentStateName});
            if (currentStep) {
              updateStepsStatus(currentStep);
            }
          }

          /**
           * Updates the steps to be set any previous steps as done, the current step as active, and the subsequent steps as disabled
           * @param step
           */
          function updateStepsStatus(step) {
            var currentStepIndex = _.indexOf($scope.steps, step);
            $scope.currentHeader = step.header;

            for (var i = 0; i < $scope.steps.length; i++) {
              if (i < currentStepIndex) {
                $scope.steps[i].status = 'done';
              }
              if (i === currentStepIndex) {
                $scope.steps[i].status = 'active';
              }
              if (i > currentStepIndex) {
                $scope.steps[i].status = 'disabled';
              }
            }
          }
        }]
      }
    }
  ]);
angular.module('common.directives')
  .directive('tooltip', [
    '$http',
    'config.paths',
    '$compile',
    function ($http, paths, $compile) {
      return {
        link: function ($scope, $element, $attr) {
          // Get width of parent element and subtract the width of the arrow so we can position accurately
          var arrowWidth = 12;
          var elementWidth = ($element.width() - arrowWidth);
          var left = 0;

          switch ($attr.arrowPosition) {
            case 'p25':
              left = elementWidth / 4;
              break;
            case 'p50':
              left = elementWidth / 2;
              break;
            case 'p75':
              left = elementWidth / 4 * 3;
              break;
            case 'p100':
              left = elementWidth;
              break;
            default:
              left = 0;
              return;
          }

          var tooltip;

          // If tooltip parent isn't present, create parent element so tooltip can be positioned based off the parent
          if (!$element.closest(".tooltip-box-parent").length > 0) {
            var parent = angular.element("<div class='tooltip-box-parent'></div>");
            $element.wrap(parent);
          }

          $scope.$watch(function () {
            return [$scope.$eval($attr.tooltipShow), $attr.tooltipMessage];
          }, updateTooltip, true);

          function updateTooltip(attributes) {
            var showTooltip = attributes[0];
            var tooltipMessage = attributes[1];

            if (showTooltip) {
              // Check if there's already a tooltip showing
              if ($element.siblings('.tooltip').length > 0) {
                removeTooltip();
              }

              if (tooltipMessage && tooltipMessage.length > 0) {
                createAndShowTooltip(tooltipMessage);
              }
            } else {
              removeTooltip();
            }
          }

          function removeTooltip() {
            // Remove previous sibling tooltip elements
            $element.nextAll().remove();

            if ($element.closest(".tooltip-arrow-parent").length > 0) {
              $element.children().remove();
            }
          }

          function createAndShowTooltip(message) {
            // Remove previous sibling tooltip elements
            $element.nextAll().remove();

            // Insert new tooltip
            var tooltipArrow = "<div class='tooltip-arrow' ng-show='showTooltip' style='left: " + left + "px'></div>";
            var tooltipCheckmark = "<span class='glyph-ok checkmark'></span>";
            var tooltipBox = "<div class='tooltip' ng-show='showTooltip'>" + tooltipCheckmark + "<span class='message'>" + message + "</span></div>";

            // If tooltip-arrow-parent is present, make the tooltip arrow a child of that parent
            if ($element.closest(".tooltip-arrow-parent").length > 0) {
              var arrowElement = angular.element(tooltipArrow);
              $element.closest(".tooltip-arrow-parent").append(arrowElement);
              tooltip = angular.element(tooltipBox);
            } else {
              tooltip = angular.element(tooltipArrow + tooltipBox);
            }

            tooltip.insertAfter($element);

            $compile(tooltip.contents())($scope);
          }

        }
      }
    }
  ]);
/*
 * angular-mixpanel
 *
 * Copyright (c) 2014 "kuhnza" David Kuhn
 * Licensed under the MIT license.
 * https://github.com/kuhnza/angular-mixpanel/blob/master/LICENSE
 */

/**
 * Wraps the mixpanel JavaScript global to make it injectable and aid in testing.
 * Requires an injectable mixpanelApiKey to be present. This can be easily done
 * by configuring the module like so:
 *
 *    angular.module('analytics.mixpanel')
 *        .config(['$mixpanelProvider', function($mixpanelProvider) {
 *            $mixpanelProvider.setApiKey('<the key>');
 *        }]);
 */
angular.module('analytics.mixpanel', [])
  .provider('$mixpanel', function () {
    var apiKey, superProperties;

    /**
     * Init the mixpanel global
     * @param {Promise} readyDeferred
     */
    function init(readyDeferred) {
      if (!Object.prototype.hasOwnProperty.call(window, 'mixpanel')) {
        throw 'Global `mixpanel` not available. Did you forget to include the library on the page?';
      }

      window.mixpanel.init(apiKey);

      waitTillAsyncApiLoaded(function () {
        if (superProperties) {
          window.mixpanel.register(superProperties);
        }

        readyDeferred.resolve();
      });
    }

    /**
     * Wait till the async portion of the Mixpanel lib has loaded otherwise we'll end up passing back a reference
     * to a bare JS array which won't actually track anything when called.
     *
     * @param callback to be called once the API has finished loading
     */
    function waitTillAsyncApiLoaded(callback) {
      if (!Object.prototype.hasOwnProperty.call(window, 'mixpanel') || (window.mixpanel.__loaded === undefined)) {
        setTimeout(function () {
          waitTillAsyncApiLoaded(callback);
        }, 200);
      }
      else {
        callback();
      }
    }

    /**
     * Perform a dynamic call to the specified mixpanel function against the window.mixpanel object.
     *
     * @param name the mixpanel function name. Can be dot separated to specify sub-property functions
     * @returns {Function} a function that will lookup and dispatch a call to the window.mixpanel object
     */
    function callMixpanelFn(name) {
      return function () {
        var fn = window.mixpanel,
          parts = name.split('.'),
          scope, i;

        for (i = 0; i < parts.length; i++) {
          scope = fn;
          fn = fn[parts[i]];
        }

        return fn.apply(scope, arguments);
      };
    }

    /**
     * Get or set the Mixpanel API key. This can be done via a provider config.
     *
     * @param key your Mixpanel API key
     */
    this.apiKey = function (key) {
      if (!key) {
        return apiKey;
      }

      apiKey = key;
    };

    /**
     * Get or set a special set of properties to include/send with every event.
     *
     * @param properties a map properties
     *
     * @see https://mixpanel.com/help/reference/javascript#super-properties
     */
    this.superProperties = function (properties) {
      if (!properties) {
        return superProperties;
      }

      superProperties = properties;
    };

    this.$get = ['$q', function ($q) {
      var readyDeferred = $q.defer();

      init(readyDeferred);

      // This is a bit of a gross hack but here we dynamically call the mixpanel functions against the
      // window.mixpanel object as we can't be sure when the window reference will be updated.
      return {
        init: callMixpanelFn('init'),
        push: callMixpanelFn('push'),
        disable: callMixpanelFn('disable'),
        track: callMixpanelFn('track'),
        track_links: callMixpanelFn('track_links'),
        track_forms: callMixpanelFn('track_forms'),
        register: callMixpanelFn('register'),
        register_once: callMixpanelFn('register_once'),
        unregister: callMixpanelFn('unregister'),
        identify: callMixpanelFn('identify'),
        get_distinct_id: callMixpanelFn('get_distinct_id'),
        alias: callMixpanelFn('alias'),
        set_config: callMixpanelFn('set_config'),
        get_config: callMixpanelFn('get_config'),
        get_property: callMixpanelFn('get_property'),
        people: {
          set: callMixpanelFn('people.set'),
          set_once: callMixpanelFn('people.set_once'),
          increment: callMixpanelFn('people.increment'),
          append: callMixpanelFn('people.append'),
          track_charge: callMixpanelFn('people.track_charge'),
          clear_charges: callMixpanelFn('people.clear_charges'),
          delete_user: callMixpanelFn('people.delete_user')
        },
        ready: readyDeferred.promise
      };
    }];
  })

  .config([
    '$mixpanelProvider',
    function($mixpanelProvider){
      $mixpanelProvider.apiKey('6b9ccb1b1af18fa94794f6d0a1dcb83e');
    }
  ]);


/**
 * @name mixpanel
 */

/**
 * @name mixpanel.track
 * @methodOf mixpanel
 * @param {string} event_name The name of the event. This can be anything the user does - "Button Click", "Sign Up", "Item Purchased", etc.
 * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.
 * @param {Function} [callback] If provided, the callback function will be called after tracking the event.
 */

/**
 * @name mixpanel.alias
 * @methodOf mixpanel
 * @param {string} alias A unique identifier that you want to use for this user in the future.
 * @param {string} [original] The current identifier being used for this user.
 */

/**
 * @name mixpanel.identify
 * @methodOf mixpanel
 * @param {string} unique_id  A string that uniquely identifies a user
 */

/**
 * @name mixpanel.register
 * @methodOf mixpanel
 * @param {Object} properties A set of properties that will be bound to the user in all subsequent events
 */

/**
 * @name mixpanel.get_distinct_id
 * @methodOf mixpanel
 * @returns {string} The current distinct id of the user. This is either the id automatically generated by the library or the id that has been passed by a call to identify().
 */

/**
 * @name mixpanel.get_property
 * @methodOf mixpanel
 * @param {string} property
 * @returns {string} value of property attached to the user
 */

angular.module('application')
  .directive('appEffectiveDate', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/application/effective-date/template.html',
        scope: {
          app: '='
        },
        link: function($scope){
          $scope.status = _.get($scope.app, 'ifp_enroll_statuses[0]', {});
          $scope.showStartDate = $scope.app.type === 'bor' || $scope.status.displayValue === 'accepted';
        }
      };
    }
  ]);
angular.module('application')
  .directive('appMonthlyPremium', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/application/monthly-premium/template.html',
        scope: {
          app: '='
        }
      };
    }
  ]);
(function(){

  /**
   * @constructor application.newCtrl
   * @param {ng.$scope.Scope} $scope
   * @param {ui.router.state.$state} $state
   * @param {application.model} currentHealthApp
   * @param {ifp_app} ActiveHealth
   * @param {application.service} applicationService
   * @param {user.model} userModel
   */
  function NewController($scope, $state, currentHealthApp, ActiveHealth, applicationService, userModel){
    //var isOep = $scope.globals.isOep;
    //var activeKeys = activeHealthApp.getNewTextKeys(userModel, new Date(), isOep);
    //var currentKeys = currentHealthApp.getNewTextKeys(userModel, new Date(), isOep);

    this.isSameApp = currentHealthApp.getId() === ActiveHealth.app_id;
    //if (currentHealthApp.progress.isInProgress()) {
    //  this.keys = currentKeys;
    //}
    //else {
    //  this.keys = activeKeys;
    //}

    this.showNewApp = this.isSameApp || !currentHealthApp.progress.isInProgress();

    this.createNew = function(){
      var request;

      if (currentHealthApp.isComplete()){
        request = applicationService.getCopy(currentHealthApp.getId())
          .then(function(app){
            currentHealthApp.setFromDb(app);
            // allow user to skip to recommended plan with pre-filled application
            currentHealthApp.data.obStep = 'recommended';

            return userModel.setWorkingApp(currentHealthApp.app_id);
          });
      }
      else {
        request = currentHealthApp.startOver(userModel);
      }

      request.then(function(){
        $state.goNext('ob.location');
      });
    };

  }
  NewController.$inject = ['$scope', '$state', 'baseHealthApp', 'ActiveHealth', 'application.service', 'baseUser'];

  angular.module('application')
    .controller('application.newCtrl', NewController);
}());

(function(){

  /**
   * @name application.startOverButton
   * @param {ui.router.state.$state} $state
   * @param {config.paths} paths
   * @param {application.model} currentApp
   * @param {user.model} userModel
   * @constructor
   */
  function Config($state, paths, currentApp, userModel){
    return {
      templateUrl: paths.partials + '/components/application/new/start-over-button.html',
      scope: true,
      link: function($scope){
        $scope.startOver = function(){
          currentApp.startOver(userModel)
            .then(function() {
              $state.reload($state.current);
            });
        };
      }
    };
  }
  Config.$inject = ['$state', 'config.paths', 'application.model', 'user.model'];

  angular.module('application')
    .directive('startOverButton', Config);
}());
angular.module('application')
  .directive('appPolicyId', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/application/policy-id/template.html',
        scope: {
          app: '='
        }
      };
    }
  ]);
angular.module('application')
  .directive('healthStatus', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/application/status/status.html',
        scope: {
          status: '=healthStatus',
          appType: '=?'
        },
        link: function($scope){
          $scope.$watchGroup(['status','appType'], function(){
            if ($scope.appType === 'bor'){
              $scope.model = {
                isComplete: true,
                displayValue: 'accepted'
              };
            }
            else {
              $scope.model = $scope.status;
            }
          });
        }
      };
    }
  ]);
(function () {

  /**
   */
  function Ctrl(cartService) {
    this.getNumPlans = function() {
      return cartService.apps.length;
    };

    this.toggle = function() {
      cartService.toggle();
    };

    this.shouldShow = function(){
      return _.isArray(cartService.apps) && cartService.apps.length > 0;
    };
  }

  Ctrl.$inject = ['cart.service'];

  angular.module('cart')
    .controller('cart.button.controller', Ctrl);
}());

angular.module('cart')
  .directive('shCartButton', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        templateUrl: paths.partials + '/components/cart/button/button.html',
        controller: 'cart.button.controller as buttonCtrl'
      };
    }
  ]);
angular.module('content')
  .directive('iconGrid', ['config', function(config){

    return {
      templateUrl: config.paths.partials + '/components/content/icon-grid/template.html',
      scope: {
        galleryKey: '@iconGrid',
        gridClasses: '=?'
      },
      controller: ['$scope', 'content.service', function($scope, contentService){
        $scope.hide = false;
        $scope.$watch('galleryKey', function(newValue){

          if (!_.isString(newValue) || !newValue.length){
            return;
          }

          contentService.getByType('gallery', { 'fields.key': newValue })
            .then(function (response) {
              if (!response || !response.length) {
                $scope.hide = true;
                return;
              }

              var gallery = response[0];
              $scope.title = gallery.description;
              $scope.icons = gallery.images;
            });
        });

        $scope.$watch('gridClasses', function(val){
          $scope.classes = val || 'medium-block-grid-2 large-block-grid-4';
        });
      }]
    };

  }]);
(function () {
  /**
   *
   * @param $state
   * @param $scope
   * @param DoctorResultsModel
   * @param {user.model} userModel
   * @param {doctor.application.service} doctorApplicationService
   * @param {ifp_app} DentalApp
   * @constructor
   */
  function Ctrl($state, $scope, DoctorResultsModel, userModel,
                doctorApplicationService, DentalApp) {
    var stateData = $state.current.data || {};
    var settings = _.extend({}, stateData.settings);
    //settings.omitted = _.pluck(applicationModel.getInfo('providers'), 'id');

    settings.onClick = function (result) {
      return doctorApplicationService.add(userModel, DentalApp.app_id, userModel.getPrimaryId(), result.id, 'dental')
        .then(function () {
          $state.go('^', {}, {reload: true});
        });
    };

    this.model = new DoctorResultsModel(settings);
    this.model.watchResults($scope);
  }

  Ctrl.$inject = ['$state', '$scope', 'doctor.results.model', 'baseUser', 'doctor.application.service', 'DentalApp'];

  angular.module('routes.dental')
    .controller('routes.dentist.resultsCtrl', Ctrl);
}());
(function () {

  /**
   * @param $state
   * @param $scope
   * @param {doctor.application.service} doctorApplicationService
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($state, $scope, doctorApplicationService, userModel) {
    this.dentists = $scope.dentists;
    console.log(this.dentists);
    this.remove = function (dentist) {
      doctorApplicationService.remove(userModel, $scope.appId, userModel.getPrimaryId(), dentist.id)
      //memberProviderResource.delete({providerId: dentist.provider_id, memberId: dentist.member_id}).$promise
        .then(function () {
          $state.go('dental.dentists', {}, {reload: true});
        });
    };
  }

  Ctrl.$inject = ['$state', '$scope', 'doctor.application.service', 'user.model'];

  angular.module('dental')
    .controller('dental.savedDentists.controller', Ctrl);
}());

angular.module('dental')
  .directive('shSavedDentists', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          dentists: '=',
          address: '=',
          appId: '='
        },
        templateUrl: paths.partials + '/components/dental/dentist/saved-dentists.html',
        controller: 'dental.savedDentists.controller as savedDentistsCtrl'
      };
    }
  ]);
(function () {

  /**
   * @name dentist.searchCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($scope, DoctorSearchModel, userModel, alertService) {
    var settings = {productType: 'dental'};

    alertService.setMessage({
      key: 'dental.alert.numDentists'
    });
    $scope.$on('$destroy', alertService.clear);

    this.model = new DoctorSearchModel(settings);
    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));
  }

  Ctrl.$inject = ['$scope', 'doctor.search.model', 'baseUser', 'services.alert'];

  angular.module('routes.dental')
    .controller('dentist.searchCtrl', Ctrl);
}());
(function () {

  /**
   * @name dental.card.controller
   * @param {ng.$rootScope.Scope} $scope
   * @constructor
   */
  function Ctrl($scope) {
    this.plan = $scope.plan;
    this.index = $scope.index;
    this.info = $scope.info;

    var currentPlan = $scope.plan.plan;
    if (currentPlan.maxYear1 === currentPlan.maxYear2 && currentPlan.maxYear2 === currentPlan.maxYear3) {
      this.maxAll = currentPlan.maxYear1;
    }
  }

  Ctrl.$inject = ['$scope'];

  angular.module('plan')
    .controller('dental.card.controller', Ctrl);
}());
angular.module('plan')
  .directive('shDentalCard', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          plan: '=',
          index: '=',
          info: '='
        },
        templateUrl: paths.partials + '/components/dental/card/dental-card.html',
        controller: 'dental.card.controller as dentalCardCtrl'
      };
    }
  ]);
(function () {

  /**
   * @name dental.service
   * @param {ng.$http} $http
   * @param {member.service} memberService
   * @param {utils} utils
   * @param {Object} documentUrls
   * @param {config.paths} paths
   * @constructor
   */
  function Svc($http, memberService, utils, documentUrls, paths) {

    /**
     * @name dental.service.getPrimaryMember
     * @methodOf dental.service
     * @param {user.model} userModel
     * @param {string} dentalAppId
     * @returns {Object} primaryMember
     */
    this.getPrimaryMember = function (userModel, dentalAppId) {
      return memberService.getAppMembers(userModel, dentalAppId)
        .then(function (response) {
          // Find primary
          return _.findWhere(response.members, {type: 'primary'});
        });
    };

    /**
     * @name dental.service.getPlanDetails
     * @methodOf dental.service
     * @param {number} planId
     * @returns {Object} dental plan
     */
    this.getPlanDetails = function(planId){
      return $http.get(paths.search + '/dental/plans/' + planId, { cache: true })
        .then(utils.dataOrObject)
        .then(transformPlanDetail);
    };

    /**
     * @name dental.service.getDetailGroups
     * @methodOf dental.service
     * @param {number} planId
     * @returns {Object}
     */
    this.getDetailGroups = function (planId) {
      return this.getPlanDetails(planId)
        .then(function (response) {
          // Check data consistency
          var typeGroups = _.groupBy(response.benefits, 'superType');
          var typeGroupKeys = _.keys(typeGroups);
          var groupValueMap = {};

          _.each(typeGroupKeys, function (key) {
            var typeGroup = typeGroups[key];
            var benefits = _.pluck(typeGroup, 'benefits');

            var year0 = _.pluck(benefits, '0');
            var year1 = _.pluck(benefits, '1');
            var year2 = _.pluck(benefits, '2');

            var allSame0 = allSameValue(_.pluck(year0, 'amount'));
            var allSame1 = allSameValue(_.pluck(year1, 'amount'));
            var allSame2 = allSameValue(_.pluck(year2, 'amount'));

            groupValueMap[key] = {
              0: allSame0 === 0 ? 'No Cost' : allSame0 + '%',
              1: allSame0 === 0 ? 'No Cost' : allSame1 + '%',
              2: allSame2 === 0 ? 'No Cost' : allSame2 + '%'
            };
          });

          // Group benefits into superType and keep the benefit name
          var groups = {};
          var benefitNames = _.keys(response.benefits);
          for (var i = 0; i < benefitNames.length; i++) {
            var benefit = response.benefits[benefitNames[i]];
            var updatedBenefits = angular.copy(benefit.benefits);
            _.each(updatedBenefits, function(benefit){
              benefit.amount = benefit.amount === 0 ? 'No Cost' : benefit.amount + '%';
            });
            var benefitInfo = {
              benefits: updatedBenefits,
              name: benefitNames[i]
            };

            var type = benefit.superType;
            if (!groups[type]) {
              groups[type] = [];
            }
            groups[type].push(benefitInfo);
            groups[type].percentages = groupValueMap[type];
          }

          return groups;
        });
    };

    /**
     * @name dental.service.getPlanDocumentsUrl
     * @methodOf dental.service
     * @param {number|string} planId
     * @returns {string}
     */
    this.getPlanDocumentsUrl = function (planId) {
      return documentUrls[planId] || '';
    };

    function allSameValue(array) {
      return _.reduce(array, function (a, b) {
        return a === b ? a : 'Error';
      });
    }

    /**
     * @name dental.service.getPlans
     * @methodOf dental.service
     * @param {string} state
     * @param {string} demoParams
     * @returns {HttpPromise<DentalPlan[]>}
     */
    this.getPlans = function(state, demoParams){
      return $http
        .get(paths.search + '/dental/plans/eligible', {
          params: {
            state: state,
            demos: demoParams
          },
          cache: true
        })
        .then(utils.dataOrArray)
        .then(function(results){
          return _.each(results, transformPlanDetail);
        });
    };

    /**
     * @name dental.service.getSortedPlans
     * @methodOf dental.service
     * @param {string} state
     * @param {string} demoParams
     * @returns {HttpPromise<DentalPlan[]>}
     */
    this.getSortedPlans = function(state, demoParams){
      return this.getPlans(state, demoParams)
        .then(function (plans) {
          return _.sortBy(plans, function (plan) {
            return -plan.plan.id;
          });
        });
    };

    function transformPlanDetail(planDetail){
      if (_.isObject(planDetail.plan)){
        planDetail.plan.premiumMonth = planDetail.totalMonthlyPremium;
        planDetail.plan.carrier = 'Renaissance Dental';
      }

      return planDetail;
    }
  }

  Svc.$inject = ['$http', 'member.service', 'utils', 'dental.documentUrls', 'config.paths'];

  angular.module('dental')
    .service('dental.service', Svc);
}());

/**
 * @typedef {Object} DentalPlan
 */

(function () {

  /**
   * @name dental.detail.idCtrl
   * @param {ui.router.state.$state} $state
   * @param {dental.service} dentalService
   * @param {ifp_app} IfpApp
   * @constructor
   */
  function Ctrl($state, dentalService, IfpApp) {
    var self = this;
    this.render = false;
    this.index = IfpApp.plan_id;
    this.plan = {
      plan: IfpApp.app_json.plan,
      totalMonthlyPremium: IfpApp.premium,
      docUrl: dentalService.getPlanDocumentsUrl(IfpApp.plan_id)
    };

    this.selectedPlanId = +IfpApp.plan_id;

    dentalService.getDetailGroups(IfpApp.plan_id)
      .then(function (response) {
        console.log(response);
        self.benefitGroups = response;
        self.render = true;
      })
      .catch(function(){
        $state.go('404');
      });
  }

  Ctrl.$inject = ['$state', 'dental.service', 'IfpApp'];

  angular.module('plan')
    .controller('dental.detail.idCtrl', Ctrl);
}());
angular.module('doctor')
  .directive('doctorAddress', [
    'config',
    function(config){
      return {
        templateUrl: config.paths.partials + '/components/doctor/address/address.html',
        scope: {
          doctor: '='
        }
      };
    }
  ]);
angular.module('doctor')
  .directive('providerDisclaimer', [
    'config',
    function(config){
      return {
        scope: {
          reveal: '='
        },
        templateUrl: config.paths.partials + '/components/doctor/disclaimer/template.html',
        link: function($scope){
          // if reveal option isn't true, just show the text on init
          $scope.model = {
            showText: $scope.reveal !== true
          };
        }
      };
    }
  ]);
angular.module('doctor')
  .directive('doctorNetwork', [
    'config',
    function(config){
      return {
        templateUrl: function($element, $attr){
          return config.paths.partials + ($attr.templateUrl || '/components/doctor/network/network.html');
        },
        scope: {
          doctor: '='
        }
      };
    }
  ]);
//(function(){
//
//  /**
//   * @name doctor.profileCtrl
//   * @param {ui.router.state.$state} $state
//   * @param {ui.router.state.$stateParams} $stateParams
//   * @param {google.maps} googleMaps
//   * @param {doctor.service} doctorService
//   * @param {user.model} userModel
//   * @param {application.model} applicationModel
//   * @constructor
//   */
//  function Ctrl($state, $stateParams, googleMaps, doctorService, userModel, applicationModel){
//    var self = this;
//    var providerId = $stateParams.providerId;
//    this.center = null;
//    this.isSaved = null;
//
//    var networkId;
//
//    if (applicationModel.isComplete()){
//      networkId = applicationModel.getPlan().networkId;
//    }
//
//    doctorService.getDetails(providerId, networkId)
//      .then(function(doctor){
//        self.doctor = doctor;
//        self.setMap();
//      });
//
//    doctorService.existsForUser(userModel, providerId)
//      .then(function(exists){
//        self.isSaved = exists;
//      });
//
//    this.setMap = function(){
//      googleMaps.promise
//        .then(function(){
//          var position = self.doctor.position;
//
//          if (position){
//            return {
//              lat: position.latitude,
//              lng: position.longitude
//            };
//          }
//
//          return googleMaps.getAddress({
//            address: googleMaps.getAddressString(doctorService.doctorToAddress(self.doctor))
//          });
//        })
//        .then(function(position){
//          self.center = position;
//          self.directionsUrl = googleMaps.getDirectionsUrl(position);
//        });
//    };
//
//    this.saveDoctor = function(){
//      if (userModel.isLoggedIn){
//        return doctorService.addForMember(userModel, applicationModel.getPrimaryId(), self.doctor)
//          .then(function(){
//            doctorService.searchTerm = '';
//            $state.go('dashboard.care.doctors');
//          });
//      }
//
//      $state.go('doctor.account.create');
//    };
//  }
//  Ctrl.$inject = ['$state', '$stateParams', 'google.maps', 'doctor.service', 'baseUser', 'baseHealthApp'];
//
//  angular.module('doctor')
//    .controller('doctor.profileCtrl', Ctrl);
//
//}());
(function(){

  /**
   * @name doctor.searchCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($scope, DoctorSearchModel, userModel, applicationModel, doctorService){
    this.model = new DoctorSearchModel();
    if (applicationModel) {
      doctorService.setGeo(applicationModel.getAddress());
    }

    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));
  }
  Ctrl.$inject = ['$scope', 'doctor.search.model', 'baseUser', 'application.model', 'doctor.service'];

  angular.module('doctor')
    .controller('doctor.searchAppCtrl', Ctrl);
}());
(function(){

  /**
   * @name doctor.searchCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($scope, DoctorSearchModel, userModel){
    this.model = new DoctorSearchModel();
    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));
  }
  Ctrl.$inject = ['$scope', 'doctor.search.model', 'baseUser'];

  angular.module('doctor')
    .controller('doctor.searchCtrl', Ctrl);
}());
(function(){


  function Factory(googleMaps, doctorService, trackingService){

    /**
     * @constructor doctor.search.model
     *
     * @param {Object} [settings]
     * @param {string} settings.trackingCategory
     * @param {number} settings.radius
     * @param {boolean} settings.inNetworkOnly
     * @param {Object} settings.searchParams
     * @param {boolean} settings.forceSearch
     */
    function Model(settings){
      this.geo = {};
      this.term = doctorService.searchTerm;
      this.geoString = '';

      /**
       * @name doctor.search.model.settings
       * @memberOf doctor.search.model
       */
      this.settings = _.extend({
        radius: 10,
        trackingCategory: '',
        inNetworkOnly: false,
        patientNetwork: null,
        didSearch: false,
        searchParams: {},
        forceSearch: false,
        showClear: true,
        persist: false
      }, settings || {});
      if (!this.settings.persist){
        doctorService.clear();
      }
    }

    /**
     * @name doctor.search.model.init
     * @methodOf doctor.search.model
     * @param {ng.$rootScope.Scope} $scope
     * @param {user.model} userModel
     * @returns {Promise}
     */
    Model.prototype.init = function($scope, userModel){
      return doctorService.getGeo(userModel)
        .then(_.bind(this.setGeo, this))
        .then(_.bind(function(){
          if (this.term !== ''){
            return this.search();
          }
        }, this))
        .then(_.bind(this.bindWatch, this, $scope));
    };

    /**
     * @name doctor.search.model.bindWatch
     * @methodOf doctor.search.model
     * @param {ng.$rootScope.Scope} $scope
     */
    Model.prototype.bindWatch = function($scope){
      var self = this;
      $scope.$watch(function(){ return self.term; }, function(newTerm, oldTerm){
        if (newTerm !== oldTerm){
          self.search();
        }
      });

      $scope.$watch(function(){ return self.settings.inNetworkOnly; }, function(newSetting, oldSetting){
        if (newSetting !== oldSetting){
          doctorService.saveSetting('inNetworkOnly', newSetting);

          if (self.settings.trackingCategory){
            trackingService.event(self.settings.trackingCategory, 'click', 'in_network_' + (newSetting ? 'on' : 'off'));
          }

          if (self.term.length){
            self.search();
          }
        }
      });

      //if (!this.settings.persist){
      //  $scope.$on('$destroy', doctorService.clear);
      //}
    };

    /**
     * @name doctor.search.model.setGeo
     * @methodOf doctor.search.model
     * @param {Address} address
     */
    Model.prototype.setGeo = function(address){
      this.geo = address;
      this.geoString = googleMaps.getAddressString(address);

      doctorService.saveSetting('geo', address);
    };

    /**
     * @name doctor.search.model.onPlaceChange
     * @methodOf doctor.search.model
     * @param {object} place
     * @returns {Promise<doctor.model[]>}
     */
    Model.prototype.onPlaceChange = function(place){
      if (this.settings.trackingCategory){
        trackingService.event(this.settings.trackingCategory, 'input', 'change_location');
      }

      this.setGeo(place);
      return this.search();
    };

    /**
     * @name doctor.search.model.search
     * @methodOf doctor.search.model
     * @returns {Promise<doctor.model[]>}
     */
    Model.prototype.search = function(){
      var geo = this.geo;
      var location = geo.zipcode;
      var settings = this.settings;

      if (geo.lat && geo.lng){
        location = {
          lat: geo.lat,
          lng: geo.lng
        };
      }

      if (!settings.didSearch && settings.trackingCategory){
        settings.didSearch = true;
        trackingService.event(settings.trackingCategory, 'input', 'start');
      }

      return doctorService.search(this.term, location, settings.radius, settings.inNetworkOnly, settings.patientNetwork,
        settings.searchParams, !!settings.forceSearch, settings.productType);
    };


    return Model;
  }
  Factory.$inject = ['google.maps', 'doctor.service', 'services.tracking'];


  angular.module('doctor')
    .factory('doctor.search.model', Factory);
}());
(function () {

  /**
   * @name doctor.application.service
   * @param {ng.$q} $q
   * @param {ng.$http} $http
   * @param {config} config
   * @param {utils} utils
   * @param {doctor.service} doctorService
   * @param {logger} logger
   * @constructor
   */
  function DoctorApplicationService($q, $http, config, utils, doctorService, logger) {
    var self = this;
    var baseUrl = config.paths.services + '/application';
    var providerCache = null;
    var providerCacheTime = +new Date();
    var providerCacheDurationSeconds = 3;


    /**
     * Get all the doctors for an app
     * @name doctor.application.service.getAllForApp
     * @methodOf doctor.application.service
     * @param {user.model} userModel
     * @param {string} appId
     * @param {string} [productType]
     * @returns {Promise<MemberProvider[]>}
     */
    this.getAllForApp = function (userModel, appId, productType) {
      if (!userModel.isLoggedIn){
        return doctorService.getAllForUser(userModel, productType);
      }

      var now = +new Date();
      if (now - 1000 * providerCacheDurationSeconds > providerCacheTime){
        providerCacheTime = now;
        providerCache = null;
      }

      // cache for x seconds on the client so we can access from multiple scopes without performance hit
      if (providerCache !== null){
        return $q.when(providerCache);
      }

      return $http.get(baseUrl + '/' + appId + '/member/provider')
        .then(utils.dataOrArray)
        .then(function(providers){
          providerCache = providers;
          return providers;
        })
        .catch(function(err){
          logger.error({
            message: 'Error fetching providers for app ' + appId,
            stack: err
          });

          return [];
        });
    };

    /**
     * Get all the detailed doctor information for an app
     * @name doctor.application.service.getMergedForApp
     * @methodOf doctor.application.service
     * @param {user.model} userModel
     * @param {string} appId
     * @param {number} [networkId]
     * @param {string} [productType]
     * @returns {Promise<doctor.model[]>}
     */
    this.getDetails = function (userModel, appId, networkId, productType) {
      return self.getAllForApp(userModel, appId, productType)
        .then(function (results) {
          return doctorService.getDetails(_.pluck(results, 'provider_id'), networkId);
        });
    };


    /**
     * @name doctor.application.service.add
     * @methodOf doctor.application.service
     * @param {user.model} userModel
     * @param {string} appId
     * @param {string} memberId
     * @param {string} provider_id
     * @param {string} [productType=health]
     * @returns {Promise<MemberProvider|boolean>}
     */
    this.add = function (userModel, appId, memberId, provider_id, productType) {
      if (!_.isString(productType)){
        productType = 'health';
      }

      if (!userModel.isLoggedIn) {
        return doctorService.addForMember(userModel, memberId, provider_id, productType);
      }

      return $http.post([baseUrl, appId, 'member', memberId, 'provider'].join('/'), {
          provider_id: provider_id,
          product_type: productType
        })
        .then(utils.dataOrObject)
        .catch(function (e) {
          logger.error({
            message: 'Error adding doctor ' + provider_id + ' to application ' + appId,
            stack: e
          });
          return false;
        });
    };

    /**
     * @name doctor.application.service.remove
     * @methodOf doctor.application.service
     * @param {user.model} userModel
     * @param {string} app_id
     * @param {string} member_id
     * @param {number} provider_id This is the id from the Scala service
     * @returns {Promise<number>} returns promise with the number of rows deleted
     */
    this.remove = function (userModel, app_id, member_id, provider_id) {
      if (!userModel.isLoggedIn) {
        return doctorService.deleteForMember(userModel, member_id, provider_id);
      }

      return $http
        .delete([baseUrl, app_id, 'member', member_id, 'provider', provider_id].join('/'))
        .then(utils.dataOrZero)
        .catch(function (e) {
          logger.error({
            message: 'Error deleting provider ' + provider_id + ' from application ' + app_id,
            stack: e
          });

          return 0;
        });
    };

  }

  DoctorApplicationService.$inject = ['$q', '$http', 'config', 'utils', 'doctor.service', 'logger'];

  angular.module('doctor')
    .service('doctor.application.service', DoctorApplicationService);
}());
(function () {

    /**
     * @name doctor.service
     * @param {ng.$q} $q
     * @param {ng.$http} $http
     * @param {$rootScope} $rootScope
     * @param {config} config
     * @param {search.request} searchRequest
     * @param {session} session
     * @param {utils} utils
     * @param {google.maps} googleMaps
     * @param {plan.utils} planUtils
     * @param {logger} logger
     * @constructor
     */
    function DoctorService($q, $http, $rootScope, config, searchRequest, session, utils, googleMaps, planUtils, logger) {
      var self = this;
      var sessionKey = 'doctor';
      var searchBaseUrl = '/provider';
      var providerSessionKey = 'member_provider';
      var baseUrl = config.paths.services;

      if (!getFromSession()){
        session.set(providerSessionKey, []);
      }

      /**
       * Used for storing logged out user's providers
       * @typedef {Object} session_provider
       * @property {number} provider_id
       * @property {string} member_id
       * @property {string} product_type
       */

      /**
       * @namespace doctor.response
       */

      /**
       * @typedef {Object} doctor.response.providerStats
       * @property {string} zip5 The zip provided
       * @property {number} providers Number of providers in given zip
       */

      /**
       * @typedef {Object} doctor.response.providerNetworkStats
       * @property {number} id Provider id
       * @property {number} carrierCount Number of carriers that include this provider
       * @property {number} networkCount Number of networks that include this provider
       */

      /**
       * @typedef {Object} doctor.response.networkStats
       * @property {doctor.response.providerNetworkStats[]} providers
       * @property {number} sharedCarriers Number of carriers that all providers belong to
       * @property {number} sharedNetworks Number of networks that all providers belong to
       */

      /**
       * @typedef {Object} doctor.settings
       * @property {Address} geo
       * @property {string} searchTerm
       */

      /**
       * @typedef {Object} doctor.response.merged
       * @property {MemberProvider} provider
       * @property {doctor.model} details
       */

      this.didSearch = false;
      this.searchResults = null;
      this.searching = false;
      this.searchTerm = '';

      /**
       * @type {doctor.settings}
       */
      this.settings = session.get(sessionKey) || {};

      /**
       * @param {string} key
       */
      this.getSetting = function (key) {
        return self.settings[key];
      };

      /**
       * @param {string} key
       * @param {*} value
       */
      this.saveSetting = function (key, value) {
        self.settings[key] = value;
        session.set(sessionKey, self.settings);
      };

      /**
       * @name doctor.service.getDetails
       * @methodOf doctor.service
       * @param {number|number[]} ids
       * @param {number} [networkId]
       * @returns {Promise<doctor.model|doctor.model[]>} returns an array if an array of ids was passed in, otherwise just the doctor object
       */
      this.getDetails = function (ids, networkId) {
        var params = {};
        var url = searchBaseUrl;
        var many = _.isArray(ids);

        if (many && !ids.length){
          return $q.when([]);
        }

        if (many){
          params.ids = ids.join(',');
        }
        else {
          url = searchBaseUrl + '/' + ids;
        }

        if (_.isNumber(networkId)) {
          params.patientNetwork = networkId;
        }

        return searchRequest
          .get(url, {cache: true, params: params})
          .then(function (result) {
            if (_.isArray(result.data)){
              return _.map(result.data, function(doc){
                return setName(mapResult(doc));
              });
            }

            return setName(mapResult(result.data));
          })
          .catch(function(err){
            logger.error({
              message: 'Failed to find doctor with ids: ' + many ? ids.join(', ') : ids,
              stack: err
            });
            return many ? [] : null;
          });
      };

      /**
       * @name doctor.service.statsByZip
       * @methodOf doctor.service
       * @param {string} zipcode
       * @param {string} [productType]
       * @returns {Promise<doctor.response.providerStats>}
       */
      this.getStatsByZip = function (zipcode, productType) {
        return searchRequest
          .get(searchBaseUrl + '/stats/geo?zipcode=' + zipcode)
          .then(function (response) {
            return response && _.isObject(response.data) ? response.data : {};
          });
      };

      /**
       * @name doctor.service.getNetworkStats
       * @methodOf doctor.service
       * @param {number[]} providerIds
       * @param {Object} [params]
       * @returns {Promise<doctor.response.networkStats>}
       */
      this.getNetworkStats = function (providerIds, params) {
        if (!providerIds.length) {
          return $q.when({});
        }

        if (!_.isObject(params)) {
          params = {};
        }

        params.providers = providerIds.join(',');

        return searchRequest
          .get(searchBaseUrl + '/stats/networks', {cache: true, params: params})
          .then(utils.dataOrObject);
      };

      /**
       * @name doctor.service.search
       * @methodOf doctor.service
       * @param {string} query
       * @param {string|google.maps.latLng} location
       * @param {number} radius
       * @param {boolean} [inNetworkOnly]
       * @param {number} [networkId]
       * @param {Object} [params]
       * @param {boolean} [forceSearch=false]
       * @param {string} productType
       * @returns {Promise<doctor.model[]>}
       */
      this.search = function (query, location, radius, inNetworkOnly, networkId, params, forceSearch, productType) {
        self.searchTerm = query;
        self.searching = true;

        // return promise with empty array when no doc name so we don't try to hit the server
        if ((!query || query.length < 3) && !forceSearch) {
          self.searching = false;
          return $q.when([]);
        }

        self.didSearch = true;

        params = _.extend({
          query: query || null,
          radius: radius,
          patientNetwork: networkId,
          inNetwork: inNetworkOnly,
          productType: productType || 'health' // Defaulting to health for now
        }, params || {});

        if (_.isString(location)) {
          params.zipcode = location;
        }
        else {
          params.latitude = location.lat;
          params.longitude = location.lng;
        }

        return searchRequest
          .get(searchBaseUrl, {params: params})
          .then(function (response) {
            var data = response && _.isArray(response.data) ? response.data : [];
            data = _.map(data, mapResult);

            _.each(data, setName);
            self.searching = false;
            self.searchResults = data;

            return data;
          });
      };

      /**
       * @name doctor.service.isSearching
       * @methodOf doctor.service
       * @returns {boolean}
       */
      this.isSearching = function () {
        return self.searching;
      };

      this.reset = function () {
        this.clear();
        this.didSearch = false;
      };

      /**
       * @name doctor.service.clear
       * @methodOf doctor.service
       */
      this.clear = function () {
        self.searchTerm = '';
        self.searchResults = [];
        self.searching = false;
      };

      ///**
      // * Get a single provider for a given member
      // * @param {user.model} userModel
      // * @param {string} memberId
      // * @param {number} providerId
      // * @returns {Promise<MemberProvider>}
      // */
      //this.getForMember = function (userModel, memberId, providerId) {
      //  return $http
      //    .get(baseUrl + '/member/provider', {
      //      params: {
      //        userId: userModel.getId(),
      //        memberId: memberId,
      //        providerId: providerId
      //      }
      //    })
      //    .then(utils.dataOrNull);
      //};

      /**
       * Get a single provider for a given user
       * @param {user.model} userModel
       * @param {number} providerId
       * @returns {Promise<MemberProvider>}
       */
      this.getForUser = function (userModel, providerId) {
        if (!userModel.isLoggedIn) {
          return $q.when(_.findWhere(getFromSession(), { provider_id: providerId }) || null);
        }

        return $http.get(baseUrl + '/user/provider', {
            params: {
              providerId: providerId
            }
          })
          .then(utils.dataOrNull);
      };

      /**
       * Get all the doctors for a user
       * @param {user.model} userModel
       * @param {string} [productType]
       * @returns {Promise<MemberProvider[]>}
       */
      this.getAllForUser = function (userModel, productType) {
        if (!userModel.isLoggedIn){
          var providers = getFromSession();

          if (productType){
            providers = _.where(providers, { product_type: productType });
          }

          return $q.when(providers);
        }

        return $http.get(baseUrl + '/user/providers', {params: {productType: productType}})
          .then(utils.dataOrArray);
      };

      /**
       * Get all the doctors for a member
       * @param {user.model} userModel
       * @param {UUID} memberId
       * @param {string} [productType]
       * @returns {Promise<MemberProvider[]>}
       */
      this.getAllForMember = function (userModel, memberId, productType) {
        if (!userModel.isLoggedIn){
          var query = { member_id: memberId };
          if (_.isString(productType)){
            query.product_type = productType;
          }
          return $q.when(_.where(getFromSession(), query));
        }

        return $http.get(baseUrl + '/member/providers', {
            params: {
              memberId: memberId,
              productType: productType
            }
          })
          .then(utils.dataOrArray);
      };

      /**
       * Get all the detailed doctor information for a user
       * @param {user.model} userModel
       * @param {number} [networkId]
       * @param {string} [productType]
       * @returns {Promise<doctor.response.merged[]>}
       */
      this.getMergedForUser = function (userModel, networkId, productType) {
        return self.getAllForUser(userModel, productType)
          .then(function (results) {
            return getMerged(results, networkId);
          });
      };

      /**
       * Get all the detailed doctor information for a member
       * @param {user.model} userModel
       * @param {UUID} memberId
       * @param {number} [networkId]
       * @param {string} [productType]
       * @returns {Promise<doctor.response.merged[]>}
       */
      this.getMergedForMember = function (userModel, memberId, networkId, productType) {
        return self.getAllForMember(userModel, memberId, productType)
          .then(function (results) {
            return getMerged(results, networkId);
          });
      };


      /**
       * @param {user.model} userModel
       * @param {string} memberId
       * @param {number} provider_id
       * @param {string} [productType=health]
       * @returns {Promise<MemberProvider|boolean>}
       */
      this.addForMember = function (userModel, memberId, provider_id, productType) {
        if (!_.isString(productType)){
          productType = 'health';
        }

        if (!userModel.isLoggedIn) {
          var provider = { member_id: memberId, provider_id: provider_id, product_type: productType };

          var sessionProviders = getFromSession();
          if (!_.findWhere(sessionProviders, { provider_id: provider_id })){
            sessionProviders.push(provider);
            session.set(providerSessionKey, sessionProviders);
          }

          return $q.when(provider);
        }

        return $http.post(baseUrl + '/member/provider', {
            providerId: provider_id,
            memberId: memberId,
            productType: productType
          })
          .then(utils.dataOrObject)
          .catch(function () {
            return false;
          });
      };

      /**
       * @param {user.model} userModel
       * @param {string} memberId
       * @param {number} provider_id
       * @returns {Promise<boolean>} returns promise with delete success boolean
       */
      this.deleteForMember = function (userModel, memberId, provider_id) {
        if (!userModel.isLoggedIn) {
          var oldProviders = session.get(providerSessionKey);
          var newProviders = _.reject(oldProviders, { provider_id: provider_id });

          session.set(providerSessionKey, newProviders);
          return $q.when(newProviders.length !== oldProviders.length);
        }

        return $http
          .delete(baseUrl + '/member/provider', {
            params: {
              providerId: provider_id,
              memberId: memberId
            }
          })
          .then(utils.dataOrZero);
      };

      /**
       * @param {user.model} userModel
       * @param {number} providerId
       * @returns {Promise<boolean>}
       */
      this.existsForUser = function (userModel, providerId) {
        return self.getForUser(userModel, providerId)
          .then(function (result) {
            return result !== null;
          });
      };

      /**
       * @param {doctor.model} doctor
       * @returns {Address}
       */
      this.doctorToAddress = function (doctor) {
        return {
          street: doctor.addr1,
          unit: doctor.addr2,
          city: doctor.city,
          state: doctor.state,
          zipcode: doctor.zip5
        };
      };

      this.getGeo = function (userModel) {
        return $q.when(self.getSetting('geo'))
          .then(function (geo) {
            if (!geo) {
              return userModel.fetchGeo();
            }

            return geo;
          })
          .then(function (geo) {
            if (!geo.lat || !geo.lng) {
              return googleMaps.getAddress({address: googleMaps.getAddressString(geo)});
            }

            return geo;
          })
          .then(function (geo) {
            self.saveSetting('geo', geo);
            return geo;
          });
      };


      this.setGeo = function (address) {
        this.saveSetting('geo', address);
      };

      /**
       * @name doctor.service.getFromSession
       * @methodOf doctor.service
       * @returns {MemberProvider[]}
       */
      this.getFromSession = getFromSession;

      /**
       * @name doctor.service.getMerged
       * @methodOf doctor.service
       * @param {MemberProvider[]} results
       * @param {number} networkId
       * @returns {doctor.response.merged}
       */
      this.getMerged = getMerged;

      /**
       * @name doctor.service.clearSession
       * @methodOf doctor.service
       */
      this.clearSession = clearSession;

      /**
       * Alters the passed in doctors array, appending planCount and carrierCount to each doctor model
       * @name doctor.service.attachNetworkStats
       * @methodOf doctor.service
       * @param {doctor.model[]} doctors
       * @param {Address} address
       * @param {string} [productType]
       * @returns {Promise<doctor.model[]>}
       */
      this.attachNetworkStats = function(doctors, address, productType){

        // Gets providers and their network data for the member
        var params = planUtils.getDateParams();
        params.state = address.state;
        params.region = address.region;
        params.countyFips = address.county_fips;
        params.productType = productType;

        return self.getNetworkStats(_.pluck(doctors, 'id'), params)
          .then(function(stats){
            return _.each(doctors, function (doctor) {
              var providerStats = _.findWhere(stats.providers, { id: doctor.id }) || {};
              doctor.networkCount = providerStats.planCount || 0;
              doctor.carrierCount = providerStats.carrierCount || 0;
            });
          });
      };

      function setName(doc) {
        doc.name = utils.capitalize(doc.firstName + ' ' + doc.lastName);
        return doc;
      }

      function mapResult(result) {
        var provider = result.provider;
        provider.networkStatus = result.networkStatus;
        provider.distanceMi = result.distanceMi;
        return provider;
      }

      function getMerged(results, networkId) {

        if (!results.length) {
          return [];
        }

        return self.getDetails(_.pluck(results, 'provider_id'), networkId)

          .then(function (details) {
            return _.map(results, function (provider) {

              return {
                provider: provider,
                // not currently possible, but what happens if a user adds
                // the same doctor for 2 different members? this would just
                // user the first match of the details, which should be ok
                // since they would be the same resource
                details: _.findWhere(details, {id: provider.provider_id})
              };

            });

          });
      }

      function addProvidersOnLogin($event, userModel){
        return $q.all(_.map(getFromSession(), function(provider){
            // this works for now since providers can only be added to the primary member
            // should also function for create if using the provider.member_id since one hasn't been established yet
            // however on login, the provider.member_id won't match up with the primary_member_id on the newly logged in user
            return self.addForMember(userModel, userModel.getPrimaryId(), provider.provider_id);
          }))
          .then(clearSession);
      }

      function getFromSession(){
        return session.get(providerSessionKey);
      }

      function clearSession(){
        session.remove(providerSessionKey);
      }

      $rootScope.$on('user-login', addProvidersOnLogin);
      //$rootScope.$on('user-create', addProvidersOnLogin);
    }

    DoctorService.$inject = ['$q', '$http', '$rootScope', 'config', 'search.request', 'session', 'utils', 'google.maps',
      'plan.utils', 'logger'];

    angular.module('doctor')
      .service('doctor.service', DoctorService);
  }());
angular.module('doctor')
  .directive('doctorSpecialties', [
    'config',
    function(config){

      return {
        templateUrl: config.paths.partials + '/components/doctor/specialty/specialties.html',
        scope: {
          specialties: '=doctorSpecialties',
          displayCount: '=?'
        },
        link: function($scope){
          if (!_.isNumber($scope.displayCount)){
            $scope.displayCount = $scope.specialties.length;
          }
        }
      };

    }
  ]);
(function(){

  /**
   * @name financeTracker.amountCtrl
   * @param {ui.router.state.$state} $state
   * @param {$filter} $filter
   * @param {financeTracker.config} financeConfig
   * @param {services.tracking} trackingService
   * @param {financeTracker.txnBuilder} txnBuilder
   * @constructor
   */
  function Ctrl($state, $filter, financeConfig, trackingService, txnBuilder){
    var type = txnBuilder.getValue('type');
    var source = txnBuilder.getValue('source');
    var sourceRoute = '^.source';


    if (!source){
      $state.replace(sourceRoute);
      return;
    }

    var self = this;
    var trackingType = financeConfig.tracking.types[type];
    var trackingProps = {
      'Transaction Source': source,
      'Transaction Type': trackingType
    };

    this.source = source;
    this.pattern = /^[0-9,.]+$/;
    this.week = txnBuilder.getValue('week');
    this.weekVisible = false;
    this.amount = '';
    this.tokens = {
      source: this.source,
      weekStart: $filter('date')(this.week[0], 'EEEE M/d')
    };

    /**
     * @name financeTracker.amountCtrl.setDay
     * @methodOf financeTracker.amountCtrl
     * @param {Date} day
     * @param {boolean} [suppressTracking=false] will not fire tracking call if set to true
     */
    this.setDay = function(day, suppressTracking){
      self.day = day;
      txnBuilder.setValue('day', day);

      if (!suppressTracking){
        trackingService.mixpanelEvent(financeConfig.tracking.names.selectDate, _.extend({}, trackingProps, {
          'Day Selected': day.toISOString()
        }));
      }
    };

    // default it to thursday, don't fire tracking
    this.setDay(this.week[3], true);

    this.finish = function(){
      finish().then(function(){
        self.done();
      });
    };

    this.addMore = function(){
      finish().then(function(){
        txnBuilder
          .start(type)
          .setValue('week', self.week);

        self.done(sourceRoute);
      });
    };

    this.done = function(nextState){
      $state.go(nextState || $state.current.data.nextState);
    };

    function finish(){
      trackingService.mixpanelEvent(financeConfig.tracking.names.enterAmount, _.extend({}, trackingProps, {
        'Transaction Amount': self.amount
      }));

      return txnBuilder
        .setValue('amount', self.amount)
        .finish()
        .catch(function(err){
          console.log(err);
        });
    }
  }
  Ctrl.$inject = ['$state', '$filter', 'financeTracker.config', 'services.tracking', 'financeTracker.txnBuilder'];

  angular.module('financeTracker')
    .controller('financeTracker.amountCtrl', Ctrl);
}());
(function(){

  /**
   *
   * @constructor
   */
  function Svc(){

    var frequencyMultipliers = {
      once: 1,
      hourly: 2080, //40 * 52 assuming 40 hours per week?
      weekly: 52,
      monthly: 12,
      twiceMonthly: 24,
      yearly: 1
    };

    this.calculateIncome = function(amount, frequency) {
      return amount * frequencyMultipliers[frequency];
    };

    this.calculateAmount = function(income, frequency) {
      return income / frequencyMultipliers[frequency];
    };
  }

  Svc.$inject = [];

  angular.module('income')
    .service('income.service', Svc);
}());
(function () {

  /**
   * @param {ng.$q} $q
   * @param {utils} utils
   * @param {health.progress} AppProgress
   * @param {services.date} dateService
   * @param {address.service} addressService
   * @param {doctor.application.service} doctorApplicationService
   * @param {member.service} memberService
   * @param {application.service} applicationService
   * @returns {health.app}
   */
  function Factory($q, utils, AppProgress, dateService, addressService, doctorApplicationService, memberService, applicationService) {

    /**
     * @constructor health.app
     */
    function Model() {

      /**
       * Application data object
       * @typedef {Object} health.app.data
       * @property {string} userId
       * @property {string} status
       * @property {Object} plan
       * @property {Object} subsidy
       * @property {Object} taxInfo
       * @private
       */
      this.data = {
        status: 'onboarding',
        subsidy: null,
        taxInfo: null,
        plan: null
      };

      /**
       * @name health.app.app_id
       * @memberOf health.app
       * @type {string|number} number if not logged in, otherwise a string generated by the API
       */
      this.app_id = null;

      /**
       * @name health.app.user_id
       * @memberOf health.app
       * @type {UUID}
       */
      this.user_id = null;

      /**
       * @name health.app.qualifying_event
       * @memberOf health.app
       * @type {string}
       */
      this.qualifying_event = null;

      /**
       * @name health.app.qualifying_event_date
       * @memberOf health.app
       * @type {Date}
       */
      this.qualifying_event_date = null;

      /**
       * @name health.app.progress
       * @memberOf health.app
       * @type {health.progress}
       */
      this.progress = new AppProgress(this);


      /**
       * @name health.app.doctors
       * @memberOf health.app
       * @type {doctor.model[]}
       */
      this.doctors = [];

      /**
       * @name health.app.member_providers
       * @memberOf health.app
       * @type {MemberProvider[]}
       */
      this.member_providers = [];

      /**
       * @name health.app.drugs
       * @memberOf health.app
       * @type {MemberDrug[]}
       */
      this.member_drugs = [];

      /**
       * @name health.app.members
       * @memberOf health.app
       * @type {Member}
       */
      this.members = [];

      /**
       * @name health.app.address
       * @memberOf health.app
       * @type {Address}
       */
      this.address = {};

      /**
       * @name health.app.billing
       * @memberOf health.app
       * @type {Billing}
       */
      this.billing = {};

      /**
       * @name health.app.start_date
       * @memberOf health.app
       * @type {DateOnly}
       */
      this.start_date = null;

      /**
       * @name health.app.submitted_on
       * @memberOf health.app
       * @type {Date}
       */
      this.start_date = null;


      /**
       * @name health.app.statuses
       * @memberOf health.app
       * @type {ifp_enroll_status[]}
       */
      this.statuses = [];
    }

    ///**
    // * Set application based on data object
    // * @name health.app.set
    // * @methodOf health.app
    // * @param {health.app.data} application Application json object from the server
    // */
    //Model.prototype.set = function(application){
    //  this.data = application;
    //
    //  _.each(this.data.applicants, function(applicant){
    //    if (!applicant.uuid){
    //      applicant.uuid = utils.uuid();
    //    }
    //
    //    //if (_.isArray(applicant.providers)){
    //    //  applicant.providers = _.filter(applicant.providers, function(provider){
    //    //    return provider && (provider.provider_id || provider.id);
    //    //  });
    //    //}
    //  });
    //};

    /**
     * @name health.app.setFromDb
     * @methodOf health.app
     * @param {ifp_app} ifp_app
     * @returns {health.app}
     */
    Model.prototype.setFromDb = function (ifp_app) {
      if (!ifp_app) {
        console.error('this should not happen');
      }

      this.data = ifp_app.app_json || {};
      this.app_id = ifp_app.app_id;
      this.user_id = ifp_app.user_id;
      this.qualifying_event = ifp_app.qualifying_event;
      this.qualifying_event_date = ifp_app.qualifying_event_date && dateService.fromIsoDate(ifp_app.qualifying_event_date) || null;
      this.address = ifp_app.address || {};
      this.billing = ifp_app.billing || {};
      this.members = ifp_app.members || [];
      this.member_drugs = ifp_app.member_drugs || [];
      this.member_providers = ifp_app.member_providers || [];
      this.statuses = ifp_app.ifp_enroll_statuses || [];
      this.start_date = ifp_app.start_date || null;
      this.submitted_on = ifp_app.submitted_on || null;

      return this;
    };

    ///**
    // * Shortcut method for starting over
    // * @name health.app.toIfpApp
    // * @methodOf health.app
    // * @returns {ifp_app}
    // */
    //Model.prototype.toIfpApp = function(){
    //  var ifp_app = _.pluck(this, ['app_id', 'user_id', 'qualifying_event', 'member_providers', 'member_drugs', 'address', 'start_date', 'billing']);
    //  ifp_app.app_json = this.data;
    //  ifp_app.qualifying_event_date = dateService.toIsoDate(this.qualifying_event_date);
    //  ifp_app.ifp_enroll_statuses = this.statuses;
    //
    //  return ifp_app;
    //};

    /**
     * Grab the current application for this session from node and
     * set the healthApp data to it
     * @name health.app.setFromWorking
     * @methodOf health.app
     * @returns {Promise.<health.app|Error>}
     */
    Model.prototype.setFromWorking = function (userModel) {
      var self = this;
      return applicationService.getWorking(userModel, 'health')
        .then(function (ifp_app) {
          return self.setFromDb(ifp_app);
        });
    };

    /**
     * @name health.app.getId
     * @methodOf health.app
     * @returns {string}
     */
    Model.prototype.getId = function () {
      return this.app_id;
    };

    /**
     * @name health.app.saveAddress
     * @methodOf health.app
     * @param {user.model} userModel
     * @param {Address} address
     * @returns {HttpPromise<Address>}
     */
    Model.prototype.saveAddress = function (userModel, address) {
      return addressService.saveForApp(userModel, this.getId(), address)
        .then(_.bind(function (address) {
          this.address = address;
          return address;
        }, this));
    };

    /**
     * @name health.app.saveMembers
     * @methodOf health.app
     * @param {user.model} userModel
     * @param {Member[]} members
     * @returns {HttpPromise<Member[]>}
     */
    Model.prototype.saveMembers = function (userModel, members) {
      return memberService.saveForApp(userModel, this.getId(), members)
        .then(_.bind(function (members) {
          this.members = memberService.sortAllMembers(members);
          return this.members;
        }, this));
    };

    /**
     * Get the raw application object
     * @name health.app.get
     * @methodOf health.app
     * @returns {health.app.data}
     */
    Model.prototype.get = function () {
      return this.data;
    };

    /**
     * @name health.app.getIllnesses
     * @methodOf health.app
     * @returns {Illness[]}
     */
    Model.prototype.getIllnesses = function () {
      return _.chain(this.getMembers())
        .pluck('illnesses')
        .flatten()
        .compact()
        .uniq()
        .value();
    };

    /**
     * Gets the type of application
     * @name health.app.getType
     * @methodOf health.app
     * @returns {string} Either 'self' for a single applicant or 'all' for multiple applicants
     */
    Model.prototype.getType = function () {
      // this isn't returning family ever right now, since we need primary on the app
      return (this.getMembers() && this.getMembers().length > 1) ? 'all' : 'self';
    };

    /**
     * Get the primary applicant
     * @name health.app.getPrimary
     * @methodOf health.app
     * @returns {Member}
     */
    Model.prototype.getPrimary = function () {
      return _.findWhere(this.getMembers(), {type: 'primary'});
    };

    /**
     * @name health.app.getPlan
     * @methodOf health.app
     * @returns {Object}
     */
    Model.prototype.getPlan = function () {
      return this.data.plan || {};
    };

    /**
     * @name health.app.getAddress
     * @methodOf health.app
     * @returns {Address}
     */
    Model.prototype.getAddress = function () {
      return this.address;
    };

    /**
     * @name health.app.getState
     * @methodOf health.app
     * @returns {string}
     */
    Model.prototype.getState = function () {
      return this.getAddress().state || '';
    };

    /**
     * @name health.app.hasAddress
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.hasAddress = function () {
      var address = this.getAddress();
      return _.isObject(address) && _.every(['zipcode', 'region', 'state'], function (key) {
          return _.isString(address[key]) || _.isNumber(address[key]);
        });
    };

    /**
     * Get all members attached to application
     * @name health.app.getMembers
     * @methodOf health.app
     * @returns {Member[]}
     */
    Model.prototype.getMembers = function () {
      return this.members;
    };

    /**
     * Get all members that are being covered by the application
     * @name health.app.getCoveredMembers
     * @methodOf health.app
     * @returns {Member[]}
     */
    Model.prototype.getCoveredMembers = function () {
      return _.filter(this.members, function (member) {
        return _.get(member, 'member_application.type', 'coverage') === 'coverage';
      });
    };

    /**
     * Get all members in app that are covered or have medicaid status
     * @name health.app.getCoveredAndMedicaidMembers
     * @methodOf health.app
     * @param {Member[]} [members]
     * @returns {Member[]}
     */
    Model.prototype.getCoveredAndMedicaidMembers = function (members) {
      return _.filter(members || this.members, function (member) {
        return _.contains(['coverage', 'medicaid'], _.get(member, 'member_application.type'));
      });
    };

    /**
     * @name health.app.setEffectiveAges
     * @methodOf health.app
     * @param {DateOnly} [effectiveDate]
     * @returns {HttpPromise<Member[]>}
     */
    Model.prototype.setEffectiveAges = function (effectiveDate) {
      return applicationService.setEffectiveAges({
        members: this.getMembers(),
        effectiveDate: effectiveDate,
        onExchange: this.hasSubsidy(),
        state: this.getState()
      });
    };

    /**
     * @name health.app.getStartDate
     * @methodOf health.app
     * @returns {Date}
     */
    Model.prototype.getStartDate = function () {
      var date = dateService.getDate(this.data.startDate);

      if (!date) {
        date = dateService.getStartDate(this);
      }

      return date;
    };

    /**
     * @param {Date} date
     */
    Model.prototype.setStartDate = function (date) {
      this.data.startDate = date;
    };

    /**
     * @name health.app.getSpouse
     * @methodOf health.app
     * @returns {Member}
     */
    Model.prototype.getSpouse = function () {
      return _.findWhere(this.getMembers(), {type: 'spouse'});
    };

    /**
     * Gets the userId associated with the application
     * @name health.app.getUserId
     * @methodOf health.app
     * @returns {UUID}
     * @method
     */
    Model.prototype.getUserId = function () {
      return this.user_id;
    };

    /**
     * Gets the uuid of the primary member on the application
     * @name health.app.getPrimaryId
     * @methodOf health.app
     * @returns {UUID}
     */
    Model.prototype.getPrimaryId = function () {
      var primary = this.getPrimary();
      return primary && primary.id || '';
    };

    /**
     * Try pull data from the user.partnerData if it hasn't been set already by the user
     * @name health.app.setPrimaryFromPartner
     * @methodOf health.app
     * @param {user.model} userModel
     */
    Model.prototype.setPrimaryFromPartner = function (userModel) {
      var primary = this.getPrimary();

      if (!primary) {
        return;
      }

      var partnerDataAge = parseInt(userModel.getPartnerData('age'));
      var partnerDataGender = userModel.getPartnerData('gender');
      var partnerDataDob = userModel.getPartnerData('dob');

      if (!primary.age && !_.isNaN(partnerDataAge)) {
        primary.age = partnerDataAge;
      }

      if (!primary.gender && _.isString(partnerDataGender)) {
        partnerDataGender = partnerDataGender.toLowerCase();

        if (partnerDataGender === 'f' || partnerDataGender === 'female') {
          primary.gender = 'F';
        }
        else if (partnerDataGender === 'm' || partnerDataGender === 'male') {
          primary.gender = 'M';
        }
      }

      if (!primary.dob && !_.isNaN(Date.parse(partnerDataDob))) {
        primary.dob = dateService.toIsoDate(new Date(partnerDataDob));
      }
    };

    /**
     * @name health.app.getKids
     * @methodOf health.app
     * @returns {Member[]}
     */
    Model.prototype.getKids = function () {
      return _.where(this.getMembers(), {type: 'dependent'});
    };

    Model.prototype.getVisitCount = function () {
      return _.reduce(this.getMembers(), function (total, member) {
        return total + _.reduce(member.visits, function (count, visit) {
            return count + visit.count;
          }, 0);
      }, 0);
    };

    /**
     * @name health.app.isValid
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.isValid = function () {
      return _.every(this.getCoveredAndMedicaidMembers(), memberService.isValid);
    };

    /**
     * @name health.app.hasValidDemos
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.hasValidDemos = function () {
      return this.hasAddress() && this.getMembers().length && this.isValid() || false;
    };

    /**
     * @name health.app.isComplete
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.isComplete = function () {
      return this.statuses.length && this.statuses[0].isComplete === true;
    };

    /**
     * Gets the status of the application
     * @name health.app.getStatus
     * @methodOf health.app
     * @returns {string} status
     */
    Model.prototype.getStatus = function () {
      return this.data.status || 'onboarding';
    };

    /**
     * Sets the status of the application
     * @param {string} status
     */
    Model.prototype.setStatus = function (status) {
      if (_.isString(status)) {
        this.data.status = status.toLowerCase();
      }
    };

    //
    //Model.prototype.setExtras = function(extras){
    //  this.data.extras = extras;
    //};
    //
    //Model.prototype.getExtras = function(){
    //  this.data.extras = this.data.extras || {};
    //  return this.data.extras;
    //};


    /**
     * @name health.app.getStateExchange
     * @methodOf health.app
     * @returns Object
     */
    Model.prototype.getStateExchange = function () {
      return this.data.stateExchange;
    };

    /**
     * Only return applicants that are not being covered
     * @name health.app.getHouseholdMembers
     * @methodOf health.app
     * @returns applicant.model[]
     */
    Model.prototype.getHouseholdMembers = function () {
      return _.reject(this.getMembers(), function (member) {
        return member.member_application && member.member_application.type === 'coverage';
      });
    };

    /**
     * @name health.app.hasSubsidy
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.hasSubsidy = function () {
      return this.data.subsidy && this.data.subsidy.amount > 0 || false;
    };

    /**
     * @name health.app.setSubsidy
     * @methodOf health.app
     * @param {number} subsidy
     * @param {number} [csr=-1]
     * @returns health.app
     */
    Model.prototype.setSubsidy = function (subsidy, csr) {
      if (!_.isNumber(subsidy) || subsidy <= 0) {
        this.data.subsidy = null;
        return this;
      }

      if (!_.isNumber(csr)) {
        csr = -1;
      }

      this.data.subsidy = {amount: subsidy, csr: csr};
      return this;
    };

    /**
     * @name health.app.killSubsidy
     * @methodOf health.app
     * @returns health.app
     */
    Model.prototype.killSubsidy = function () {
      this.data.subsidy = null;
      this.data.stateExchange = null;
      this.data.ffmApplication = null;
      this.data.aptc = null;
      this.data.plan = null;
      return this;
    };

    /**
     * @name health.app.hasLifeEvent
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.hasLifeEvent = function () {
      return this.qualifying_event && _.isDate(this.qualifying_event_date);
    };

    /**
     * @name health.app.getLifeEventDate
     * @methodOf health.app
     * @returns {Date}
     */
    Model.prototype.getLifeEventDate = function () {
      return this.hasLifeEvent() ? this.qualifying_event_date : null;
    };

    /**
     * @name health.app.hasValidLifeEventDate
     * @methodOf health.app
     * @returns {Boolean}
     */
    Model.prototype.hasValidLifeEventDate = function () {
      if (!this.hasLifeEvent()) {
        return false;
      }

      var eventTime = this.qualifying_event_date.getTime();
      var today = new Date();
      // remove time of day information from date so it's comparing start of day to start of day
      var todayTime = +new Date(today.getFullYear(), today.getMonth(), today.getDate());
      var oneDay = 1000 * 60 * 60 * 24;

      // valid if:
      // event is no more than 55 days before today
      // event is no more than 60 days after today
      return eventTime - todayTime >= -(oneDay * 55) && eventTime - todayTime <= (oneDay * 60);
    };

    /**
     * @name health.app.hasPlan
     * @methodOf health.app
     * @returns {boolean}
     */
    Model.prototype.hasPlan = function () {
      return !!(this.data.plan && this.data.plan.id);
    };

    /**
     * @name health.app.getNetworkId
     * @methodOf health.app
     * @returns {number}
     */
    Model.prototype.getNetworkId = function () {
      return this.hasPlan() ? this.data.plan.networkId : null;
    };

    /**
     * @name health.app.getFilingStatus
     * @methodOf health.app
     * @returns {string}
     */
    Model.prototype.getFilingStatus = function () {
      var status = '';
      var taxInfo = this.data.taxInfo;
      var stateExchange = this.data.stateExchange;

      if (taxInfo && taxInfo.filingStatus) {
        status = taxInfo.filingStatus;
      }
      else if (stateExchange && stateExchange.primaryTaxFiler) {
        var primaryFiler = stateExchange.primaryTaxFiler;
        var primaryApplicant = this.getPrimary();
        var applicant = _.isArray(primaryFiler.applicants) && primaryFiler.applicants[0];

        if (applicant && primaryApplicant && primaryApplicant.id === applicant.id && applicant) {
          status = applicant.filingStatus || '';
        }
      }

      return status;
    };

    /**
     * @name health.app.getPremium
     * @methodOf health.app
     * @param {HealthPlan} [plan]
     * @returns {number}
     */
    Model.prototype.getPremium = function (plan) {
      var val = 0;
      var key = 'premiumMonth';

      if (_.isUndefined(plan)) {
        plan = this.getPlan();
      }

      if (plan && plan[key]) {
        if (plan.mods) {
          val = plan.mods[key];
        }
        else {
          val = plan[key];
        }
      }

      return val;
    };

    ///**
    // * @name health.app.getNewTextKeys
    // * @methodOf health.app
    // * @param {user.model} userModel
    // * @param {Date} date
    // * @param {boolean} isOep
    // * @returns {{headline: string, body: string, cta1: string, cta2: string, obHeadline: string, obBody: string, toaster: string}}
    // */
    //Model.prototype.getNewTextKeys = function(userModel, date, isOep){
    //  date = dateService.getDate(date) || new Date();
    //
    //  var externalPlan = !_.isEmpty(userModel.getBor());
    //  var isComplete = this.isComplete();
    //  var isCovered = isComplete || externalPlan;
    //  var inProgress = this.progress.isInProgress();
    //  var has2016Plan = isCovered && this.getStartDate().getFullYear() === 2016;
    //  var is2016 = date.getFullYear() === 2016;
    //  var headline;
    //  var body;
    //  var cta1;
    //  var cta2;
    //  var obHeadline;
    //  var obBody;
    //  var toaster;
    //
    //  if (isCovered){
    //    cta1 = externalPlan && !isComplete ? 'shopPlan' : 'newPlan';
    //    cta2 = 'newPlan';
    //
    //    if (isOep){
    //      headline = 'rightPlan';
    //      obBody = 'locationDate';
    //
    //      if (has2016Plan){
    //        headline = body = obHeadline = 'differentPlan';
    //
    //        if (!is2016){
    //          toaster = 'archivedPlan';
    //        }
    //      }
    //      else {
    //        headline = 'rightPlan';
    //
    //        if (is2016){
    //          body = 'switchPlan';
    //          obHeadline = 'newPlan2016';
    //        }
    //        else {
    //          cta1 = 'shopPlan2016';
    //          body = 'findPlan';
    //          obHeadline = 'getReady';
    //        }
    //      }
    //    }
    //    else {
    //      headline = 'newPlan';
    //      body = 'qualify';
    //      obHeadline = 'newPlan';
    //      obBody = 'location';
    //    }
    //  }
    //  else {
    //
    //    headline = obHeadline = '';
    //    obBody = 'location';
    //
    //    if (inProgress){
    //      cta1 = body = 'continue';
    //      cta2 = 'startOver';
    //
    //      if (this.getPlan()){
    //        body = 'continuePlan';
    //      }
    //    }
    //    else {
    //      cta1 = 'shopPlan';
    //      cta2 = 'externalPlan';
    //
    //      if (isOep){
    //        body = 'uninsuredOep';
    //      }
    //      else {
    //        body = 'uninsured';
    //      }
    //    }
    //
    //  }
    //
    //  return {
    //    headline: headline,
    //    body: body,
    //    cta1: cta1,
    //    cta2: cta2,
    //    obHeadline: obHeadline,
    //    obBody: obBody,
    //    toaster: toaster
    //  };
    //};

    /**
     * @name health.app.setAppDoctors
     * @methodOf health.app
     * @param {user.model} userModel
     * @returns {HttpPromise.<doctor.model[]>}
     */
    Model.prototype.setAppDoctors = function (userModel) {
      var self = this;
      return doctorApplicationService.getDetails(userModel, self.getId(), self.getNetworkId(), 'health')
        .then(function (docs) {
          self.doctors = docs;
          return docs;
        });
    };

    /**
     * @name health.app.setResources
     * @methodOf health.app
     * @param {user.model} userModel
     * @returns {HttpPromise}
     */
    Model.prototype.setResources = function (userModel) {
      return $q.all([
        this.setAppDoctors(userModel)
        //this.setAppDrugs(userModel)
      ]);
    };

    /**
     * Shortcut method for starting over
     * @name health.app.startOver
     * @methodOf health.app
     * @param {user.model} userModel
     * @returns {HttpPromise<health.app|Error>}
     */
    Model.prototype.startOver = function (userModel) {
      return applicationService.reset(userModel, this.getId())
        .then(_.bind(this.setFromDb, this));
    };

    return Model;
  }

  Factory.$inject = ['$q', 'utils', 'health.progress', 'services.date', 'address.service', 'doctor.application.service', 'member.service', 'application.service'];

  angular.module('health')
    .factory('health.app', Factory);
}());
angular.module('health')
  .directive('ifpPlanCard', ['config', function(config){
    return {
      templateUrl: config.paths.partials + '/components/health/card/slim.html',
      scope: {
        ifpApp: '='
      }
    };
  }]);
(function(){

  function Factory(memberService){

    /**
     * @name health.progress
     * @param {health.app} healthApp
     * @constructor
     */
    function Model(healthApp){
      this.section = '';
      this.step = '';
      this.app = healthApp;
    }

    /**
     * Stores the furthest advanced state of the application
     * @name health.progress.setFromApp
     * @methodOf health.progress
     */
    Model.prototype.setFromApp = function(){
      var progress = this.get();
      this.section = progress.section;
      this.step = progress.step;
    };

    /**
     * Gets the furthest advanced state of the application
     * @name health.progress.get
     * @methodOf health.progress
     * @returns {{ section: string, step: string }}
     */
    Model.prototype.get = function(){
      var app = this.app;
      var section = '';
      var step = '';
      var status = app.getStatus();

      if (this.isComplete()){
        section = 'complete';
      }

      else if (status !== 'onboarding' && app.hasPlan()){
        section = 'cart';

        //if (!dateService.isOpenEnrollment(new Date(), app)){
        //  step = 'qualify';
        //}
        //else if (status === 'application'){
        //  if (!app.getAddress().street){
        //    step = 'address';
        //  }
        //  else {
        //    step = 'applicants';
        //  }
        //}
        //else {
        //  step = status;
        //}
      }

      else {
        section = 'ob';
        step = this.getObStep();
      }

      return {
        section: section,
        step: step
      };
    };

    /**
     * Gets the onboarding step the application should be on
     * @name health.progress.getObStep
     * @methodOf health.progress
     * @returns {string}
     */
    Model.prototype.getObStep = function(){
      var app = this.app;

      // address is required
      if (!app.hasAddress()){
        return 'location';
      }

      var members = app.getMembers();
      // valid applicants is required
      if (!members.length || !_.every(members, memberService.isValid)){
        return 'family';
      }

      // check saved state first
      var savedObStep = app.get().obStep;
      if (!_.isEmpty(savedObStep)){
        return savedObStep;
      }

      // plan means they've been all the way through
      if (app.getPlan() || !_.isEmpty(app.get().taxInfo)){
        return 'recommended';
      }

      // none of these are required, so step backwards through them
      if (app.getIllnesses().length){
        return 'savings';
      }

      if (app.member_drugs.length){
        return 'illnesses';
      }

      if (app.member_providers.length){
        return 'drugs';
      }

      return 'doctors';
    };

    /**
     * @name health.progress.isComplete
     * @methodOf health.progress
     * @returns {boolean}
     */
    Model.prototype.isComplete = function(){
      return this.app.isComplete();
    };

    /**
     * @name health.progress.isInProgress
     * @methodOf health.progress
     * @returns {boolean}
     */
    Model.prototype.isInProgress = function(){
      return !this.isComplete() && !this.isEmpty();
    };

    /**
     * @name health.progress.isInProgress
     * @methodOf health.progress
     * @returns {boolean}
     */
    Model.prototype.isEmpty = function(){
      return !this.app.getMembers().length;
    };

    /**
     * @name health.progress.getState
     * @methodOf health.progress
     * @returns {string}
     */
    Model.prototype.getState = function(){
      var progress = this.get();
      if (progress.section === 'complete'){
        return 'dashboard';
      }

      if (progress.step === 'recommended'){
        return 'recommended';
      }

      if (progress.section === 'cart'){
        return 'cart';
      }

      return progress.section + '.' + progress.step;
    };

    return Model;
  }
  Factory.$inject = ['member.service'];

  angular.module('health')
    .factory('health.progress', Factory);
}());
(function(){

  /**
   * @name health.service
   * @param {ng.$http} $http
   * @param {utils} utils
   * @param {config} config
   * @constructor
   */
  function Svc($http, utils, config){

    var serviceBase = config.paths.services;

    /**
     * Request url helper for health application
     * @name health.service.getHealthUrl
     * @param {health.app} healthApp
     * @param {string} [subPath]
     * @returns {string}
     * @private
     */
    function getHealthUrl(healthApp, subPath){
      var appId = '';
      if (healthApp && _.isFunction(healthApp.getId)){
        appId = healthApp.getId();
      }

      return serviceBase + '/health/application' + (subPath ? '/' + subPath : '') + '?ts=' + (new Date()).getTime() + (appId ?  '&appId=' + appId : '');
    }

    /**
     * Gets all health applications tied to the session
     * @name health.service.getApps
     * @methodOf health.service
     * @returns {Promise.<health.app[]|Error>}
     */
    this.getApps = function(){
      return $http.get(serviceBase + '/health/applications?ts=' + (new Date()).getTime())
        .then(utils.dataOrArray);
    };

    /**
     * Gets a new application based on data from the session's current application
     * @name health.service.getCurrentCopy
     * @methodOf health.service
     * @returns {Promise.<health.app|Error>}
     */
    this.getCurrentCopy = function(){
      return $http.get(getHealthUrl(null, 'current/copy'))
        .then(utils.dataOrObject);
    };
  }
  Svc.$inject = ['$http', 'utils', 'config'];

  angular.module('health')
    .service('health.service', Svc);
}());
(function () {

  /**
   * @namespace plan.list.compare
   */

  /**
   * @name plan.list.compareCtrl
   * @param {Object} $scope
   * @param {ng.$timeout} $timeout
   * @param {plan.compare.service} planCompareService
   * @param {snackbar.service} snackbarService
   * @param {services.mediaQuery} mediaQueryService
   * @param {services.tracking} trackingService
   */
  function Ctrl($scope, $timeout, planCompareService, snackbarService, mediaQueryService, trackingService) {

    var closeTimeout;
    var hasBeenOpened;
    $scope.modes.compare = true;
    setPlanCount();

    // make sure any plan in the compare service is initially flagged as selected
    _.each(planCompareService.getPlans(), function (plan) {
      plan.selected = true;
    });

    autoOpenDropDown();

    $scope.pickPlan = function (plan) {
      if (plan.selected === true) {
        // Uncheck the plan and remove from the compare
        plan.selected = false;
        planCompareService.removeComparePlan(plan);
      }
      else {
        var addSuccess = planCompareService.addComparePlan(plan);
        if (addSuccess) {
          // Toggle checkbox
          plan.selected = true;


          autoOpenDropDown();
        }
        else {
          // Show toaster that max 2 plans allowed to be compared
          snackbarService.push({
            key: 'plan.alert.comparelimit',
            removable: true,
            duration: 3
          });
        }
      }

      trackingService.mixpanelEvent('Plan Compare: Select Plan', {
        'Checked': plan.selected,
        'Source': 'Plan List'
      });

      setPlanCount();
    };

    $scope.closeCompareDropdown = function () {
      var comparePlanIds = planCompareService.getCompareParams();

      // Find selected plans
      this.allPlans.forEach(function (plan) {
        if (comparePlanIds.pid1 && plan.id === comparePlanIds.pid1 && !plan.selected) {
          planCompareService.removeComparePlan(plan);
        }

        if (comparePlanIds.pid2 && plan.id === comparePlanIds.pid2 && !plan.selected) {
          planCompareService.removeComparePlan(plan);
        }

      });

      // Update number of plans
      setPlanCount();
      // Hide dropdown
      setDropDownDisplay(false);
    };

    // hide drop down whenever navigating away form page
    $scope.$on('$stateChangeStart', function(){
      setDropDownDisplay(false);
    });

    $scope.getNumSelectedPlans = function () {
      return planCompareService.getNumSelectedPlans();
    };

    function setPlanCount() {
      $scope.numComparePlans = planCompareService.getNumComparePlans();
    }

    /**
     * @param {boolean} bool
     */
    function setDropDownDisplay(bool) {
      $scope.viewModel.showCompareDropdown = bool;

      if (!bool) {
        $timeout.cancel(closeTimeout);
      }
      else {
        hasBeenOpened = true;
      }
    }

    /**
     * @returns {boolean}
     */
    function autoOpenDropDown() {
      var planCount = planCompareService.getNumComparePlans();

      if (!mediaQueryService.mediumUp() || planCount === 0) {
        return false;
      }

      if (planCount === 2) {
        setDropDownDisplay(true);
      }
      // If only 1 plan is select, auto open the first time and close after delay
      else if (planCount === 1 && !hasBeenOpened) {
        setDropDownDisplay(true);
        closeTimeout = $timeout(function () {
          setDropDownDisplay(false);
        }, 2000);
      }

    }
  }

  Ctrl.$inject = ['$scope', '$timeout', 'plan.compare.service', 'snackbar.service', 'services.mediaQuery', 'services.tracking'];

  angular.module('plan')
    .controller('plan.list.compareCtrl', Ctrl);
}());
angular.module('plan')
  .directive('planDeadline', [
    'plan.deadlineSvc',
    'config',
    function(planDeadlineSvc, config){

      return {
        scope: {
          enrollment: '=',
          nextEnrollment: '=',
          stateConfig: '='
        },
        templateUrl: function($element, $attr){
          return config.paths.partials + ($attr.templateUrl || '/components/plan/deadline/template.html');
        },
        link: function($scope){
          _.extend($scope, planDeadlineSvc.getModel($scope.enrollment, $scope.nextEnrollment));
        }
      };

    }
  ]);
(function(){

  /**
   * @name plan.deadlineSvc
   * @param {$q} $q
   * @param {services.date} dateService
   * @param {search.geo} geoSearch
   */
  function Svc($q, dateService, geoSearch){

    /**
     * @name plan.deadlineSvc.getModel
     * @methodOf plan.deadlineSvc
     * @param {EnrollmentPeriod} enrollmentPeriod
     * @param {EnrollmentPeriod} nextEnrollmentPeriod
     * @returns {{effectiveDate: string, nextEffectiveDate: string, enrollmentPeriod: EnrollmentPeriod, showCutoffNear: boolean, showCutoffMissed: boolean}}
     */
    this.getModel = function(enrollmentPeriod, nextEnrollmentPeriod){
      return {
        effectiveDate: enrollmentPeriod.effective_date,
        nextEffectiveDate: nextEnrollmentPeriod && nextEnrollmentPeriod.effective_date || dateService.getNextEffectiveDate(enrollmentPeriod.effective_date),
        enrollmentPeriod: enrollmentPeriod,
        showCutoffNear: dateService.nearStrideCutoff(enrollmentPeriod),
        showCutoffMissed: dateService.missedStrideCutoff(enrollmentPeriod),
        isOep: enrollmentPeriod.period_type === 'oep',
        isPeriodEnd: !nextEnrollmentPeriod || enrollmentPeriod.period_type !== nextEnrollmentPeriod.period_type
      };
    };

    /**
     * @name plan.deadlineSvc.getStateEnrollment
     * @methodOf plan.deadlineSvc
     * @param {health.app} healthApp
     * @returns {Promise<{ stateConfig: object, enrollment: EnrollmentPeriod, periods: EnrollmentPeriod[] }>}
     */
    this.getStateEnrollment = function(healthApp){
      var state = healthApp.getState();

      return $q.all([
          geoSearch.getStateConfig(state),
          dateService.getEnrollmentPeriods({
            onExchange: healthApp.hasSubsidy(),
            state: state,
            officialDate: true
          })
        ])
        .then(function(responses){
          return {
            stateConfig: responses[0],
            periods: responses[1] || {}
          };
        });
    };
  }
  Svc.$inject = ['$q', 'services.date', 'search.geo'];

  angular.module('plan')
    .service('plan.deadlineSvc', Svc);
}());
(function(){


  function Ctrl($scope){

    $scope.showFilters = function (bool) {
      $scope.filtersShowing = bool;
    };

    function hideFilters(){
      $scope.filtersShowing = false;
    }

    $scope.$on('filters-changed', hideFilters);
  }
  Ctrl.$inject = ['$scope'];

  angular.module('plan')
    .controller('plan.filterCtrl', Ctrl);
}());
angular.module('plan')
  .directive('shPlanFilters', [
    '$rootScope',
    'config.paths',
    'plan.filter.service',
    'services.tracking',
    function ($rootScope, paths, filterService, trackingService) {
      return {
        scope: true,
        templateUrl: paths.partials + '/routes/plan/list/sidebar-filters.html',
        link: function ($scope, $element, $attr) {
          //filterService.updateList();
          $scope.filterList = filterService.getFilterList();
          $scope.activeFilter = $scope.filterList[0];
          $scope.setActive = function (filter) {
            $scope.activeFilter = filter;
          };

          $scope.reset = function () {
            filterService.reset();
            notify();
          };

          $scope.limitCarrier = 4;
          $scope.limitDoctor = 4;

          $scope.hasChanges = function () {
            return filterService.hasChanges();
          };

          /**
           * Toggles the selected filter
           * ng-change is used so the model gets updated before this function gets called
           */
          $scope.toggleCheckboxFilter = function (defaultState) {
            var currentFilter = this.filter;
            var filters = this.filterSet.filters;

            trackingService.mixpanelEvent('Plan Compare: Filter', {
              'Category': this.filterSet.key,
              'Value': currentFilter.text || currentFilter.key,
              'Is Active': currentFilter.selected
            });

            var allUnchecked = isAllUnchecked(filters);
            if (allUnchecked) {
              filters.forEach(function (filter) {
                filter.active = defaultState;
                filter.selected = false;
              });
            } else {
              filters.forEach(function (filter) {
                filter.active = filter.selected;
              });
            }

            filterService.save();
            notify();
          };

          /**
           * Toggles non checkbox filters
           */
          $scope.toggleFilter = function () {
            var currentFilter = this.filter;
            var filters = this.filterSet.filters;

            var allUnchecked = isAllUnchecked(filters);
            if (allUnchecked) {
              // Make this filter active and deactivate the others
              currentFilter.active = true;

              filters.forEach(function (filter) {
                if (filter !== currentFilter) {
                  filter.active = false;
                }
              });
            } else if (isOnlyOneChecked(currentFilter, filters)) {
              activateAllFilters(filters);
            } else {
              currentFilter.active = !currentFilter.active;
            }

            if (currentFilter.selected === undefined) {
              currentFilter.selected = true;
            } else {
              currentFilter.selected = !currentFilter.selected;
            }

            filterService.save();
            notify();
          };

          /**
           * Activates all filters (all values show up) when no options are selected
           * @param filters
           */
          function activateAllFilters(filters) {
            filters.forEach(function (filter) {
              filter.active = true;
            });
          }

          /**
           * Checks if only 1 item in the filter list is selected
           * @param currentFilter
           * @param filters
           * @returns {boolean}
           */
          function isOnlyOneChecked(currentFilter, filters) {
            var onlyOneChecked = true;
            var filterListCopy = filters.slice();
            var index = filters.indexOf(currentFilter);

            // Get all filters except the current one
            filterListCopy.splice(index, 1);

            // Check if any of the remaining filters are checked
            filterListCopy.forEach(function (filter) {
              if (filter.selected) {
                onlyOneChecked = false;
              }
            });
            return onlyOneChecked;
          }

          /**
           * Checks if there are no selected items in the filter list
           * @param filters
           * @returns {boolean}
           */
          function isAllUnchecked(filters) {
            var allUnchecked = true;

            filters.forEach(function (filter) {
              if (filter.selected) {
                allUnchecked = false;
              }
            });

            return allUnchecked;
          }


          function notify() {
            if ($attr.notify !== 'false') {
              $rootScope.$broadcast('filters-changed');
            }
          }
        }
      };
    }
  ]);
angular.module('plan')
  .service('plan.filter.service', [
    '$q',
    'plan.search',
    'user.model',
    'application.model',
    'session',
    'plan.utils',
    'doctor.application.service',
    function ($q, planSearch, userModel, applicationModel, sessionService, planUtils, doctorApplicationService) {
      var _self = this;
      var _sessionKey = 'plan-filters';
      var _fullFilterList = [];
      var _filterList = [];
      var _filters = {
        /**
         * @param {HealthPlan} plans
         * @param {number[][]} carrierIds
         */
        carriers: function (plans, carrierIds) {
          return _.filter(plans, function (plan) {
            return _.contains(_.flatten(carrierIds), plan.carrierId);
          });
        },
        networks: function (plans, allowedValues) {
          return genericFilter(plans, allowedValues, 'planType');
        },
        tiers: function (plans, allowedValues) {
          return genericFilter(plans, allowedValues, 'metalType');
        },

        subsidy: function (plans, allowedValues) {
          return genericFilter(plans, allowedValues, 'qhpStatus');
        },
        hsa: function (plans, allowedValues) {
          return genericFilter(plans, allowedValues, 'hsaStatus');
        },

        doctors: function (plans, requiredValues) {
          console.log('filtering docotrs')
          return _.filter(plans, function (plan) {

            if (plan.mods) {
              var docs = plan.mods.providers;

              return _.every(requiredValues, function (requiredDocId) {
                // can't use findWhere here, since one id is sometimes a string and the other sometimes an int
                return _.find(docs.providersAccepted, function (d) {
                  return d.id === requiredDocId && d.accepted;
                });
              });
            }

            return false;
          });
        }
      };
      var _filterSets = {
        savings: function (plans, filters) {
          var subsidyFilters = _.filter(filters, function (filter) {
            return filter.type === 'subsidyStatus';
          });
          var hsaFilters = _.filter(filters, function (filter) {
            return filter.type === 'hsaStatus';
          });
          var activeSubsidyFilters = _.where(subsidyFilters, {active: true});
          var activeHsaFilters = _.where(hsaFilters, {active: true});

          if (activeSubsidyFilters.length < subsidyFilters.length) {
            plans = _self.filter(plans, 'subsidy', _.pluck(activeSubsidyFilters, 'value'));
          }

          if (activeHsaFilters.length < hsaFilters.length) {
            plans = _self.filter(plans, 'hsa', _.pluck(activeHsaFilters, 'value'));
          }

          return plans;
        }
      };

      /**
       * @name plan.filter.service.filterActive
       * @methodOf plan.filter.service
       * @param {HealthPlan[]} plans
       * @returns {Array.<HealthPlan>}
       */
      this.filterActive = function (plans) {
        var filteredPlans = plans.slice(0);

        _.each(_filterList, function (filterSet) {

          var activeFilters = _.where(filterSet.filters, {active: true});

          if (_filterSets[filterSet.key]) {
            filteredPlans = _filterSets[filterSet.key](filteredPlans, filterSet.filters);
          }
          else if (
            // if it's doctors, only filter if at least 1 value is present
          (filterSet.key === 'doctors' && activeFilters.length) ||
            // everything else should not bother filtering if all values are present
          (filterSet.key !== 'doctors' && activeFilters.length < filterSet.filters.length)) {

            filteredPlans = _self.filter(filteredPlans, filterSet.key, _.pluck(activeFilters, 'value'));
          }

        });

        return filteredPlans;
      };

      this.filter = function (plans, filterKey, allowedValues) {
        if (_.isFunction(_filters[filterKey])) {
          return _filters[filterKey](plans, (_.isArray(allowedValues) ? allowedValues : [allowedValues]));
        }
      };

      /**
       * @name plan.filter.service.reset
       * @methodOf plan.filter.service
       * @param {HealthPlan[]} [plans] If plans aren't passed in, it will use previous _fullFilterSet
       */
      this.reset = function (plans) {
        sessionService.remove(_sessionKey);
        this.updateList(plans);
      };

      this.save = function () {
        sessionService.set(_sessionKey, _filterList);
      };

      this.hasChanges = function () {
        var hasChanges = false;

        _.each(_filterList, function (filterSet) {
          _.each(filterSet.filters, function (filter) {
            if (filter.selected) {
              hasChanges = true;
            }
          });
        });
        return hasChanges;
      };

      this.getFilterList = function () {
        return _filterList;
      };

      /**
       * @name plan.filter.service.updateList
       * @methodOf plan.filter.service
       * @returns {any[]}
       */
      this.updateList = function (plans) {
        _filterList.length = 0;

        return getFullFilterSet(plans)
          .then(function (fullFilterSet) {

            _.each(fullFilterSet, function (filterSet) {
              _filterList.push(filterSet);
            });

            mergeSaved();

            return _filterList;
          });
      };

      // this method is intended to be used outside of the plan list to preset a certain filter group
      // will wipe out other filters that have been set
      this.activateFilters = function (filterGroupKey, activeFilterKeys) {
        getFullFilterSet()
          .then(function (list) {
            var filterGroup = _.findWhere(list, {key: filterGroupKey}) || {};

            _.each(filterGroup.filters || [], function (filter) {
              // not all filters have a key, so match on value if the key isn't present
              filter.active = _.indexOf(activeFilterKeys, filter.key || filter.value) > -1;
            });

            _filterList = list;
            _self.save();
          });
      };

      this.isFilterGroupActive = function (key) {
        var filterGroup = _.findWhere(_filterList, {key: key});

        if (filterGroup && filterGroup.filters) {
          return _.findWhere(filterGroup.filters, {selected: true});
        }
      };

      /**
       * @name plan.filter.service.getActiveFilterGroupKeys
       * @methodOf plan.filter.service
       * @returns {string[]}
       */
      this.getActiveFilterGroupKeys = function () {
        var activeFilterKeys = [];
        _.each(_.keys(_filters), function (key) {
          if (_self.isFilterGroupActive(key)) {
            activeFilterKeys.push(key);
          }
        });
        return activeFilterKeys;
      };

      function genericFilter(plans, allowedValues, key) {
        return _.filter(plans, function (plan) {
          return _.contains(allowedValues, plan[key]);
        });
      }

      function mergeSaved() {
        var savedList = sessionService.get(_sessionKey);
        // if they don't have a saved list yet, just return the default
        if (savedList) {

          // iterate through each current filter item, which will exclude any
          // saved filters that are no longer valid to the current plan set / application
          _.each(_filterList, function (filterSet) {

            var savedFilterSet = _.findWhere(savedList, {key: filterSet.key});

            if (savedFilterSet) {
              // loop through saved filterSets and find corresponding current filter set
              _.each(savedFilterSet.filters, function (savedFilter) {

                var filterSetItem = _.find(filterSet.filters, function (filter) {
                  // looking by key first, then text field which might get screwy if text changes
                  return (filter.key && filter.key === savedFilter.key) || (filter.text && filter.text === savedFilter.text);
                });

                if (filterSetItem) {
                  filterSetItem.active = savedFilter.active;
                  filterSetItem.selected = savedFilter.selected;
                }
              });

              // Activate any that are already selected
              _.each(filterSet.filters, function (filter) {
                filter.active = filter.selected;
              });

              // If all the valid filters are not active, activate them all (essentially no filter selected)
              if (filterSet.key !== 'doctors' && !_.findWhere(filterSet.filters, {active: true})) {
                _.each(filterSet.filters, function (filter) {
                  filter.active = true;
                  filter.selected = false;
                });
              }

            }

          });
        }
      }

      function getFullFilterSet(plans) {
        if (!_.isArray(plans)){
          return $q.when(angular.copy(_fullFilterList));
        }

        return doctorApplicationService.getDetails(userModel, applicationModel.getId())
          .then(function (response) {
            _fullFilterList = [
              {
                key: 'carriers',
                filters: _.map(planUtils.getCarriers(plans), function (carrierBrand) {
                  return {
                    text: carrierBrand.name,
                    value: carrierBrand.ids,
                    active: true
                  };
                })
              },
              {
                key: 'networks',
                filters: _.map(planUtils.getNetworks(plans), function (network) {
                  return {
                    text: network,
                    value: network,
                    active: true
                  };
                })
              },
              {
                key: 'tiers',
                filters: _.map(planUtils.getTiers(plans), function (tier) {
                  return {
                    text: tier,
                    value: tier,
                    active: true
                  };
                })
              },
              {
                key: 'doctors',
                filters: _.map(response, function (doctor) {

                  console.log(doctor.name, doctor.id);

                  return {
                    text: doctor.name,
                    value: doctor.id,
                    active: false
                  };
                })
              }
            ];

            return angular.copy(_fullFilterList);
          });
      }
    }
  ]);
(function(){

  function Ctrl($q, $state, $scope, planSearch, logger, currentHealthApp, userModel){
    var self = this;
    var errObj = {
      userOid: userModel.getId(),
      healthApp: currentHealthApp.get()
    };

    if (!currentHealthApp.hasValidDemos()){
      errObj.message = 'Invalid demographic information on health application';
      logger.error(errObj);

      // go home in case ob step is on recommended to avoid looping
      return $state.replace('home');
    }

    planSearch.getMerged(currentHealthApp)
      .then(function(plans){
        if (!plans || !plans.length) {
          return $q.reject('No plans returned');
        }

        $scope.allPlans = plans;
        self.render = true;
      })
      .catch(function(err){
        errObj.message = err && err.message || err;
        logger.error(errObj);

        return $state.replace('500');
      });
  }
  Ctrl.$inject = ['$q', '$state', '$scope', 'plan.search', 'logger', 'baseHealthApp', 'baseUser'];

  angular.module('plan')
    .controller('plan.personalCtrl', Ctrl);
}());
(function () {

  /**
   * @name plan.plancardCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {plan.card} PlanCard
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl($scope, PlanCard, trackingService, userModel) {
    this.planCard = new PlanCard($scope.plan, $scope.applicationModel, $scope.info, userModel);
    var premium = $scope.plan.mods.premiumYear;
    var oop = $scope.plan.mods.oop.totalOop;
    var totalCost = premium + oop;
    this.premiumPercent = minRatio(premium / totalCost) * 100;
    this.oopPercent = minRatio(oop / totalCost) * 100;
    this.coveredMembers = $scope.applicationModel.getCoveredMembers();

    if ($scope.plan.mods.savings.subsidy && $scope.plan.qhpStatus) {
      var fullPremium = $scope.plan.premiumMonth;
      this.subsidyPercent = minRatio(($scope.plan.mods.savings.subsidy / 12) / fullPremium) * 100;
      this.personalPercent = minRatio($scope.plan.mods.premiumMonth / fullPremium) * 100;
    }

    this.hideFlag = $scope.hideFlag;
    this.showBorder = $scope.showBorder;

    this.toggleInfo = function ($event, index, name) {
      if ($scope.info) {
        $event.stopPropagation();
        var newIndex = -1;

        if ($scope.infoOpen !== index) {
          newIndex = index;
          trackingService.mixpanelEvent('Plan Compare: Info Drawer', {
            Name: name,
            'Stride Plan ID': $scope.plan.id,
            'HIOS ID': $scope.plan.planId
          });
        }

        $scope.infoOpen = newIndex;
      }
    };


    function minRatio(num) {
      return Math.max(0.3, Math.min(0.7, num));
    }
  }

  Ctrl.$inject = ['$scope', 'plan.card', 'services.tracking', 'user.model'];

  angular.module('plan')
    .controller('plancardCtrl', Ctrl);
}());
angular.module('plan')
  .directive('shPlanCard', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          plan: '=',
          applicationModel: '=',
          info: '=',
          hideFlag: '=',
          showBorder: '=',
          checkbox: '=',
          infoOpen: '@',
          infoDisplay: '='
        },
        templateUrl: function($element, $attr){
          if ($attr.template && $attr.template === 'option') {
            return paths.partials + '/components/plan/plan-card/option-card.html';
          }
          return paths.partials + '/components/plan/plan-card/plan-card.html';
        },
        controller: 'plancardCtrl as plancardCtrl'
      };
    }
  ]);
(function () {


  function Factory(planUtils, costService) {

    /**
     * @name plan.card
     * @param {HealthPlan} plan
     * @param {health.app} applicationModel
     * @param {boolean} info
     */
    function PlanInfo(plan, applicationModel, info) {
      var self = this;

      this.plan = plan;
      this.applicationModel = applicationModel;

      var appMembers = applicationModel.getCoveredMembers();

      var isPersonal = !!plan.mods;
      var isFamilyPlan = isPersonal && appMembers.length > 1;
      var indSuffix = 'Ind';
      var famSuffix = 'Fam';
      var deductibleKey = 'deductible' + (isFamilyPlan && plan.deductibleFam && famSuffix || indSuffix);
      var deductibleRxKey = 'deductiblerx' + (isFamilyPlan && famSuffix || indSuffix);
      var oopMaxKey = 'oopmax' + (isFamilyPlan && famSuffix || indSuffix);

      // If the info boxes are supposed to be expandable
      this.info = info;

      // Set applicants list
      this.applicants = appMembers;

      // Deductible
      this.isFamily = isFamilyPlan;

      this.deductible = plan[deductibleKey];
      this.deductibleKey = 'plan.card.' + deductibleKey;
      this.deductibleExplainKey = 'plan.card.explain.' + deductibleKey;

      if (!isFamilyPlan) {
        this.deductibleKey = 'plan.card.deductible';
        this.deductibleExplainKey = 'plan.card.explain.deductible';
      }

      this.deductibleRx = plan[deductibleRxKey];

      this.oopMax = plan[oopMaxKey];
      this.detailParams = planUtils.getDetailParams(plan);
      this.setPreviewBenefits();

      if (plan.mods) {

        // Doctors
        if (plan.mods.providers) {
          var userDocs = angular.copy(plan.mods.providers.providersAccepted);
          self.userDocs = _.each(userDocs, function (doc) {
            var match = _.find(applicationModel.doctors, function(doctor){
              return doctor.provider_id === doc.id || doctor.id === doc.id;
            });
            doc.name = match && match.name || '';
          });
        }
        this.allAccepted = planUtils.allDocsAccepted(plan);
        this.inNetCount = planUtils.getInNetCount(plan);

        // Drugs
        if (plan.mods.userDrugs) {
          this.userDrugs = _.filter(plan.mods.userDrugs, function (drug) {
            var match = _.find(applicationModel.member_drugs, function(memberDrug){
              return memberDrug.drug_json.id === drug.id && memberDrug.member_id === drug.applicantId;
            });

            if (match){
              drug.product = match.drug_json.product;
            }

            return !!match;
          });

          // --- Calculate total drug cost per month ----
          var allData = true;
          var noData = true;
          var firstDrug;
          var totalDrugCost = 0;
          var userDrugs = this.userDrugs;

          for (var i = 0; i < userDrugs.length; i++) {
            if (!userDrugs[i].annualForecast || userDrugs[i].annualForecast === -1) {
              allData = false;
            } else if (userDrugs[i].annualForecast && userDrugs[i].annualForecast > -1) {
              noData = false;
              if (!firstDrug) {
                firstDrug = userDrugs[i];
              }

              totalDrugCost += userDrugs[i].annualForecast;
            }
          }

          this.totalMonthlyDrugCost = totalDrugCost / 12;

          if (allData) {
            this.allDrugData = true;
          }
          if (noData) {
            // If we have no data on all the drugs added
            this.totalMonthlyDrugCost = null;
          } else {
            // If we have some data on the drugs added
            this.firstDrug = firstDrug;
          }
        }
      }
    }

    PlanInfo.prototype.setPreviewBenefits = function () {
      var getFormattedText = costService.getText;
      var visitsCosts = this.plan.benefits.visits || {};
      var drugsCosts = this.plan.benefits.drugs || {};

      this.visits = {
        pre: {
          primary: getFormattedText(visitsCosts.ben_primary),
          specialist: getFormattedText(visitsCosts.ben_specialist)
        }
      };

      this.drugs = {
        pre: {
          generic: getFormattedText(drugsCosts.rx_generic),
          brand: getFormattedText(drugsCosts.rx_brand)
        }
      };
    };

    PlanInfo.prototype.setFullBenefits = function () {
      var getFormattedText = costService.getText;
      var getPrePostCombined = costService.getCombined;
      var visitsCosts = this.plan.benefits.visits || {};
      var drugsCosts = this.plan.benefits.drugs || {};

      this.visits = {
        pre: {
          primary: getFormattedText(visitsCosts.ben_primary),
          specialist: getFormattedText(visitsCosts.ben_specialist),
          preventive: getFormattedText(visitsCosts.ben_preventive)
        },
        post: {
          primary: getFormattedText(visitsCosts.ben_primary, true),
          specialist: getFormattedText(visitsCosts.ben_specialist, true),
          preventive: getFormattedText(visitsCosts.ben_preventive, true)
        }
      };

      this.drugs = {
        pre: {
          generic: getFormattedText(drugsCosts.rx_generic),
          brand: getFormattedText(drugsCosts.rx_brand),
          excBrand: getFormattedText(drugsCosts.rx_brandpreferred),
          specialty: getFormattedText(drugsCosts.rx_specialty)
        },
        post: {
          generic: getFormattedText(drugsCosts.rx_generic, true),
          brand: getFormattedText(drugsCosts.rx_brand, true),
          excBrand: getFormattedText(drugsCosts.rx_brandpreferred, true),
          specialty: getFormattedText(drugsCosts.rx_specialty, true)
        }
      };

      this.surgeries = {
        pre: {
          er: getFormattedText(visitsCosts.ben_er, false, true),
          minor: getFormattedText(visitsCosts.ben_outpatient, false, true),
          major: getFormattedText(visitsCosts.ben_inpatient, false, true)
        },

        post: {
          er: getFormattedText(visitsCosts.ben_er, true, true),
          minor: getFormattedText(visitsCosts.ben_outpatient, true, true),
          major: getFormattedText(visitsCosts.ben_inpatient, true, true),
          urgent: getFormattedText(visitsCosts.ben_urgent, true, true),
          imaging: getFormattedText(visitsCosts.ben_imaging, true, true)
        }
      };

      this.pregnancies = {
        combined: {
          preNatal: getPrePostCombined(visitsCosts.ben_prenatal),
          delivery: getPrePostCombined(visitsCosts.ben_delivery),
          wellBaby: getPrePostCombined(visitsCosts.ben_postnatal)
        }
      };

      this.oon = {
        pre: {
          all: getFormattedText(visitsCosts.ben_oon, false, true)
        },

        post: {
          all: getFormattedText(visitsCosts.ben_oon, true, true)
        }
      };
    };


    return PlanInfo;
  }

  Factory.$inject = ['plan.utils', 'services.cost'];

  angular.module('plan')
    .factory('plan.card', Factory);
}());
angular.module('plan')
  .directive('shPlanNameCheckbox', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          plan: '='
        },
        templateUrl: paths.partials + '/components/plan/plan-name-checkbox/template.html'
      };
    }
  ]);
// TODO: rework this stuff

angular.module('plan')
  .directive('shRecFetch', [
    'config.paths',
    function(paths){

      return {
        transclude: true,
        replace: true,
        templateUrl: paths.partials + '/components/plan/rec-fetch/rec-fetch.html',
        scope: true,
        controller: [
          '$q',
          '$timeout',
          '$scope',
          '$state',
          '$element',
          'plan.search',
          'plan.utils',
          'application.model',
          'user.model',
          'logger',
          'services.tracking',
          function($q, $timeout, $scope, $state, $element, planSearch, planUtils, applicationModel, userModel, logger, trackingService){
            var self = this;
            self.recChangeEl = null;
            self.recSameEl = null;
            self.recInvalidEl = null;
            self.locals = {};

            var cachedTopPlan = angular.copy(planUtils.getTopPlan(planSearch.getMergedCached()));
            var savedPlan = angular.copy(applicationModel.getPlan());

            $element.addClass('rec-fetch');
            $scope.calculating = true;

            this.trackEvent = function(elToShow){
              var type = elToShow === self.recSameEl ? 'price'
                       : elToShow === self.recChangeEl ? 'plan'
                       : undefined;
              if(type){
                trackingService.mixpanelEvent(trackingService.propEnum.eligibilityChange, {
                  type:type
                });
              }
            }

            // this sets cached values for format tokens
            if (!_.isEmpty(savedPlan)){
              self.locals.planName = savedPlan.name;
              self.locals.premium = savedPlan.mods.premiumMonth.toFixed(2);
            }

            $q
              .all([
                planSearch.getMerged(applicationModel, true),
                $timeout(function(){}, 2000)
              ])
              .then(function(results){
                var plans = results[0];

                // no plans, we don't support the region
                if (!plans || !plans.length){
                  // wipe the old plan off the app first and save it
                  return applicationModel.setPlan(userModel, null)
                    .then(function(){
                      $state.go('invalid-region');
                    });
                }

                var rec = planUtils.getTopPlan(plans);
                var hasSavedPlan = !_.isEmpty(savedPlan);
                var newVersionOfSavedPlan = hasSavedPlan && _.find(plans, { id: savedPlan.id });
                // if they don't have an old plan, it can't be invalid
                // if they do have it, make sure it is in the returned set
                var savedIsValid = !hasSavedPlan || !!newVersionOfSavedPlan;

                if (!savedIsValid){
                  applicationModel.setPlan(userModel, null)
                    .then(function(){
                      finish(self.recInvalidEl);
                    });
                }
                else if (hasSavedPlan){
                  // update the old plan
                  applicationModel.setPlan(userModel, newVersionOfSavedPlan)
                    .then(function(){
                      // if it's the same plan
                      if (applicationModel.getPlan().id === rec.id){
                        finish(self.recSameEl);
                      }
                      else {
                        finish(self.recChangeEl);
                      }
                    });
                }
                else if (cachedTopPlan && cachedTopPlan.id === rec.id){
                  finish(self.recSameEl);
                }

                else {
                  finish(self.recChangeEl);
                }

              }, function(){
                logger.error({
                  message: 'Recommendation fetch failed to get merged plans',
                  userOid: applicationModel.getUserId()
                });
                $state.go('500');
              });

            function finish(elToShow){
              $scope.calculating = false;
              $element.find('.complete').append(elToShow);
              self.trackEvent(elToShow);
            }
          }
        ]
      };

    }
  ])
  .directive('shRecChange', [

    function(){
      return {
        require: '^shRecFetch',
        replace: true,
        transclude: true,
        template: '',
        link: function($scope, $element, $attr, fetchCtrl, transclude){
          _.extend($scope, fetchCtrl.locals);
          fetchCtrl.recChangeEl = transclude($scope, function(clone, scope){ });
        }
      };
    }
  ])
  .directive('shRecSame', [

    function(){
      return {
        require: '^shRecFetch',
        replace: true,
        transclude: true,
        template: '',
        link: function($scope, $element, $attr, fetchCtrl, transclude){
          _.extend($scope, fetchCtrl.locals);
          fetchCtrl.recSameEl = transclude($scope, function(){ });
        }
      };
    }
  ])
  .directive('shRecInvalid', [

    function(){
      return {
        require: '^shRecFetch',
        replace: true,
        transclude: true,
        template: '',
        link: function($scope, $element, $attr, fetchCtrl, transclude){
          _.extend($scope, fetchCtrl.locals);
          fetchCtrl.recInvalidEl = transclude($scope, function(clone, scope){ });
        }
      };
    }
  ]);

(function(){

  /**
   * @param {ui.router.state.$state} $state
   * @param {Object} $stateParams
   * @param {plan.scenarios.model} ScenariosModel
   * @param {health.app} healthApp
   * @param {services.tracking} trackingService
   */
  function Ctrl($state, $stateParams, ScenariosModel, healthApp, trackingService){
    var self = this;
    var pid1 = parseInt($stateParams.pid1);
    var pid2 = parseInt($stateParams.pid2);

    this.model = new ScenariosModel([pid1, pid2]);
    this.model.getScenarios(healthApp)
      .then(function(){
        self.render = true;

        trackingService.setPeopleProp('Head-to-head scenarios viewed', true);
      })
      .catch(function(err){
        $state.replace('500');
      });
  }
  Ctrl.$inject = ['$state', '$stateParams', 'plan.scenarios.model', 'baseHealthApp', 'services.tracking'];

  angular.module('plan')
    .controller('plan.scenariosCtrl', Ctrl);
}());
(function(){

  /**
   * @param {ng.$q} $q
   * @param {ng.$timeout} $timeout
   * @param {*} scrollToService
   * @param {plan.search} planSearch
   */
  function Factory($q, $timeout, scrollToService, planSearch){

    /**
     * @name plan.scenarios.model
     * @property {Array} scenarios
     * @property {number[]} pids
     * @property {number[]} costs
     * @property {HealthPlan[]} plans
     * @property {number} active
     */

    /**
     * @constructor
     * @param {number[]} pids
     */
    function Model(pids){
      this.scenarios = [];
      this.pids = pids;
      this.costs = _.map(pids, function(){ return 0; });
    }

    /**
     * @name plan.scenarios.model.getScenarios
     * @methodOf plan.scenarios.model
     * @param {health.app} healthApp
     * @returns {Promise.<T>}
     */
    Model.prototype.getScenarios = function(healthApp){
      var self = this;
      var plans = planSearch.getMergedCached();
      this.plans = _.map(this.pids, function(pid){
        return _.findWhere(plans, { id: pid });
      });

      return $q
        .all(_.map(this.plans, function(plan){
          return planSearch.getScenarios(plan, healthApp);
        }))
        .then(function(respones){
          self.scenarios = respones;
          self.active = 0;
          self.setCosts(self.active);
        });
    };

    /**
     * @name plan.scenarios.model.setCosts
     * @methodOf plan.scenarios.model
     * @param {number} index
     */
    Model.prototype.setCosts = function(index){
      this.costs = _.map(this.scenarios, function(scenario){
        return scenario[index].insured;
      });
    };

    /**
     * @name plan.scenarios.model.setActive
     * @methodOf plan.scenarios.model
     * @param {number} index
     */
    Model.prototype.setActive = function(index){
      var self = this;
      scrollToService.go(0, 200)
        .then(function(scrolled){
          $timeout(function(){
            self.active = index;
            self.setCosts(index);
          }, scrolled && 50 || 0);
        });
    };

    return Model;
  }
  Factory.$inject = ['$q', '$timeout', 'scrollTo.service', 'plan.search'];

  angular.module('plan')
    .factory('plan.scenarios.model', Factory);
}());
angular.module('profile')
  .directive('shApplicantsForm', [
    'config.paths',
    'profile.details.form',
    function(paths, detailsForm){
      return {
        templateUrl: paths.partials + '/components/profile/applicants/full-applicant-form.html',
        link: detailsForm.setup,
        scope: {
          // make sure you can pass in applicants, since this might not always act upon people on the application
          applicants: '=',
          onChange: '&',
          onNoChange: '&',
          isExtended: '='
        }
      };
    }
  ])

  .controller('profile.applicant.form', [
    '$scope',
    'services.date',
    'application.model',
    'member.service',
    function($scope, dateService, applicationModel, memberService){
      var initialAge = $scope.applicant.age;

      $scope.formModel = {
        form: {},
        isPrimary: memberService.isPrimary($scope.applicant)
      };

      $scope.dobUpdated = function(){
        $scope.formModel.age = null;

        dateService.getStartDateAge($scope.applicant.dob, applicationModel)
          .then(function(startDateAge){
            $scope.ageChanged = !$scope.applicant.excluded && startDateAge !== initialAge;
            $scope.applicant.age = startDateAge;

            if (!$scope.applicant.excluded && !memberService.isValid($scope.applicant)){
              $scope.formModel.age = null;
            }
            else {
              $scope.formModel.age = startDateAge;
            }

          });
      };

      // if they already have a dob from previous entry, check the start date age
      if (_.isString($scope.applicant.dob) || _.isDate($scope.applicant.dob)){
        $scope.dobUpdated();
      }

      $scope.$on('submit-error', function(){
        if ($scope.formModel.form && !$scope.formModel.form.$valid){
          $scope.$broadcast('invalid-form');
        }
      });
    }
  ]);
// This directive is only ever used in the context of an application
angular.module('profile')
  .directive('shSavedDoctors', [
    '$rootScope',
    'config.paths',
    'user.model',
    'application.model',
    'doctor.service',
    'doctor.application.service',
    function ($rootScope, paths, userModel, applicationModel, doctorService, doctorApplicationService) {

      return {
        scope: true,
        templateUrl: function (tElement, tAttrs) {
          return paths.partials + (tAttrs.templateUrl || '/components/profile/doctors/doctor-saved.html');
        },
        link: function ($scope, $element, $attr) {
          $scope.render = false;

          doctorApplicationService.getDetails(userModel, applicationModel.getId(), null, 'health')
            .then(getStats)
            .then(function(doctors){
              $scope.userDocs = doctors;
              $scope.render = true;
            });

          $scope.$on('provider-added', function($event, result){
            $scope.userDocs.push(result.details);
            return getStats($scope.userDocs);
          });

          $scope.remove = function (doc) {
            doctorApplicationService.remove(userModel, applicationModel.getId(), applicationModel.getPrimaryId(), doc.id)
              .then(function () {
                $rootScope.$broadcast('provider-removed', { details: doc });
                $scope.userDocs.splice(_.indexOf($scope.userDocs, doc), 1);
              });
          };

          $scope.searchState = $attr.searchState || '.search';
          function getStats(doctors){
            return doctorService.attachNetworkStats(doctors, applicationModel.getAddress(), 'health');
          }
        }
      };
    }
  ]);
(function () {
  /**
   *
   * @param $state
   * @param $scope
   * @param $rootScope
   * @param userModel
   * @param DoctorResultsModel
   * @param applicationModel
   * @param {doctor.application.service} doctorApplicationService
   * @constructor
   */
  function Ctrl($state, $scope, $rootScope, userModel, DoctorResultsModel, applicationModel, doctorApplicationService) {
    var self = this;
    var stateData = $state.getData();
    var settings = _.extend({}, stateData.settings);

    settings.onClick = function (doctor) {
      return doctorApplicationService.add(userModel, applicationModel.getId(), applicationModel.getPrimaryId(), doctor.id, 'health')
        .then(function(provider){
          $rootScope.$broadcast('provider-added', { provider: provider, details: doctor });
          $state.go(stateData.onSavedState || '^');
        });
    };

    doctorApplicationService.getAllForApp(userModel, applicationModel.getId(), 'health')
      .then(function(providers){
        settings.omitted = _.pluck(providers, 'provider_id');
        self.model = new DoctorResultsModel(settings);
        self.model.watchResults($scope);
      });
  }

  Ctrl.$inject = ['$state', '$scope', '$rootScope', 'baseUser', 'doctor.results.model', 'baseHealthApp', 'doctor.application.service'];

  angular.module('visit')
    .controller('profile.doctor.resultsCtrl', Ctrl);
}());
angular.module('profile')
  .controller('profile.eSign.controller', [
    '$q',
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'application.service',
    'plan.search',
    'utils',
    'services.date',
    'services.tracking',
    'partner.service',
    'plan.deadlineSvc',
    'cart.service',
    'logger',
    /**
     * @name profile.eSign.controller
     * @param {object} $q
     * @param {object} $scope
     * @param {ui.router.state.$state} $state
     * @param {user.model} userModel
     * @param {application.model} applicationModel
     * @param {application.service} applicationService
     * @param {plan.search} planSearch
     * @param {utils} utils
     * @param {services.date} dateService
     * @param {services.tracking} trackingService
     * @param {partner.service} partnerService
     * @param {plan.deadlineSvc} planDeadlineSvc
     * @param {cart.service} cartService
     * @param {logger} logger
     */
    function($q, $scope, $state, userModel, applicationModel, applicationService, planSearch, utils, dateService, trackingService, partnerService, planDeadlineSvc, cartService, logger){
      var carrier = applicationModel.getPlan().carrier;
      //var today = new Date();
      var enrollmentParams = {
        state: applicationModel.getState(),
        onExchange: applicationModel.hasSubsidy()
      };
      var app_id = applicationModel.getId();

      $scope.model = {};
      $scope.cartService = cartService;

      $q.all([
        dateService.getEffectiveDate(enrollmentParams)
          .then(function(effectiveDate){
            $scope.effectiveDate = effectiveDate;
          }),

        dateService.isOepAsync(enrollmentParams)
          .then(function(isOep){
            $scope.isOpenEnrollment = isOep;
          }),

        planDeadlineSvc.getStateEnrollment(applicationModel)
          .then(function(stateEnrollment){
            $scope.stateConfig = stateEnrollment.stateConfig;
            $scope.enrollment = stateEnrollment.periods.current;
            $scope.enrollmentPeriods = stateEnrollment.periods;
          }),

        partnerService.requiresNotifyOptIn()
          .then(function(result){
            $scope.model.showPartnerOptIn = result;
            $scope.model.partnerOptIn = result;
          })
        ])
        .then(function(){
          $scope.render = true;
        });

      $scope.applicants = _.filter(applicationModel.getCoveredMembers(), function(member){
        return member.age > 17;
      });

      //$scope.startDate = dateService.getStartDate(applicationModel);
      //$scope.sepStartDate = new Date(today.getFullYear(), today.getMonth() + 1, 1);
      $scope.validError = '';

      $scope.tokens = {
        carrierName: carrier,
        carrierKey: utils.toDash(carrier)
      };

      $scope.signatures = _.map($scope.applicants, function(applicant){
        return {
          first: applicant.first_name,
          last: applicant.last_name,
          firstValue: '',
          lastValue: ''
        };
      });

      $scope.submit = function(){
        if ($scope.model.signForm.$valid){

          var loggingObject = null;

          dateService.getEffectiveDate({
              state: applicationModel.getState(),
              onExchange: applicationModel.hasSubsidy()
            })
            .then(function(effectiveDate){
              if (!dateService.isSameIsoDate(effectiveDate, $scope.effectiveDate)) {
                $scope.effectiveDate = effectiveDate;
                return $q.reject({ reason: 'startDateMismatch' });
              }

              return dateService.getEnrollmentPeriods(enrollmentParams);
            })
            .then(function(enrollmentPeriods){
              var hasLifeEvent = applicationModel.hasLifeEvent();
              // if it's SEP, make sure they have a life event and a valid date
              if (enrollmentPeriods.current.period_type === 'sep') {

                if (!hasLifeEvent) {
                  return $q.reject({ reason: 'qualifyingEvent' });
                }

                if (!applicationModel.hasValidLifeEventDate()){
                  return $q.reject({ reason: 'qualifyingEventDate' });
                }
              }
              // otherwise strip it off and save it
              else if (hasLifeEvent) {
                return applicationService.saveQE(userModel, app_id, null, null);
              }
            })
            .then(function(){
              if ($scope.model.showPartnerOptIn){
                return partnerService.notifyOptIn($scope.model.partnerOptIn);
              }
            })
            .then(function(){
              return applicationService.isValidToSubmit(app_id, $scope.effectiveDate);
            })
            .then(function(data){
              if (!data.isValid){
                return $q.reject(data);
              }

              return cartService.getApps();
            })
            .then(function(cartApps){

              // create an esign request for all applications in cart
              var requests = _.map(cartApps, function(cartApp){

                var memberIds = _.chain(cartApp.members)
                  // all member ids for the app
                  .pluck(['id'])
                  // find all members that esigned
                  .filter(function(memberId){
                    return !!_.findWhere($scope.applicants, { id: memberId });
                  })
                  .value();

                return applicationService.eSign(cartApp.app_id, memberIds);
              });

              requests.unshift(cartApps);

              return $q.all(requests);
            })
            .then(function (responses) {
              var cartApps = responses[0];
              var billingId = applicationModel.billing.id;
              loggingObject = cartService.getTrackingPayload();

              return cartService.purchase(_.pluck(cartApps, 'app_id'), billingId, $scope.effectiveDate);
            })
            .then(function(purchaseDetails){
              _.each(purchaseDetails, function(pd){
                var app = _.findWhere(cartService.apps, { app_id: pd.app_id });
                if (app && app.type === 'health'){
                  applicationModel.statuses = pd.ifp_enroll_statuses;
                  applicationModel.start_date = pd.start_date;
                }
              });

              return applicationService.setActive(userModel, app_id, 'health');
            })
            //.then(function () {
            //  return applicationModel.setFromCurrentApp();
            //})
            .then(function () {
              var strideRank = applicationModel.getPlan().mods.ranks.strideRank;
              trackingService.setPeopleProp(trackingService.propEnum.purchasedRank, strideRank);

              if (loggingObject) {
                trackingService.mixpanelEvent(trackingService.propEnum.purchaseComplete, loggingObject);

                if (loggingObject.Dental) {
                  trackingService.setPeopleProp(trackingService.propEnum.dentalPurchased, true);
                }
              }

              $state.go('^.submitted');
            })
            .catch(function (err) {
              logger.error({
                message: 'Error submitting application',
                stack: err,
                userOid: applicationModel.getUserId(),
                path: $state.href($state.current)
              });

              throwError(err);
            });
        }
      };

      function throwError(error){
        var reason = error && error.reason || error || '500';
        $scope.validError = reason;
        $scope.$emit('invalid-submit-check', { reason: reason });
      }
    }
  ]);
angular.module('profile')
  .controller('profile.illnessEdit.controller', [
    '$scope',
    '$state',
    'application.model',
    'search.illnesses',
    'services.alert',
    function($scope, $state, applicationModel, illnessService, alertService){
      var ngCopy = angular.copy;
      var stateData = $state.getData();
      $scope.applicationType = applicationModel.getType();
      $scope.skipState = stateData.skipState || '^';

      illnessService.get()
        .then(filterList);

      $scope.selectIllness = function(illness){
        if ($scope.applicationType == 'self'){

          // cap illnesses at 4 per person

          illness.selected = !illness.selected;
          $scope.selectedCount = _.where($scope.list, { selected: true }).length;
        }
        else {
          $scope.illness = ngCopy(illness);
          var applicants = _.map(applicationModel.getMembers(), function(applicant){
            var app = ngCopy(applicant);
            app.selected = _.contains(applicant.illnesses, illness.name);
            return app;
          });


          // strip out applicants that have 4 illnesses already
          // leave them in if they are selected already, so they can
          $scope.illness.applicants = _.without(applicants, function(applicant){
            return !applicant.selected && applicant.illnesses.length >= 4
          });
        }
      };

      $scope.skip = function(){
        $scope.$emit('illness-edit-complete');
        $state.go($scope.skipState);
      };

      $scope.doneEditing = function(){
        var success = true;

        if ($scope.applicationType == 'self'){
          success = setSelf();
        }
        else if ($scope.illness){
          success = attachIllness($scope.illness);
        }

        if (!success){
          showLimitWarning();
        }
        else {
          alertService.setWarning(null);
          $scope.$emit('illness-edit-complete');
          $state.go('^');
        }
      };

      function showLimitWarning(){
        alertService.setWarning({
          key: 'profile.alert.illnessLimit',
          duration: 10000
        });
      }

      function setSelf(){
        var primary = applicationModel.getPrimary();
        if (!primary.illnesses){
          primary.illnesses = [];
        }

        var selectedItems = _.where($scope.list, { selected: true });

        if (selectedItems.length + primary.illnesses.length > 4) return false;

        _.each(selectedItems, function(selected){
          primary.illnesses.push(selected.name);
        });

        return true;
      }

      function attachIllness(illness){
        return _.every(applicationModel.getMembers(), function(member, index){
          if (!member.illnesses){
            member.illnesses = [];
          }

          member.illnesses = _.without(member.illnesses, illness.name);

          // and only add back to those that are selected
          if (illness.applicants[index] && illness.applicants[index].selected){
            // don't let them add a 5th illness
            if (member.illnesses.length >= 4) return false;

            member.illnesses.push(illness.name);
          }

          return true;
        });
      }

      // get rid of any that are saved
      function filterList(illnesses){
        var savedIllnesses = applicationModel.getIllnesses();

        $scope.list = _.reject(illnesses, function(illness){
          return _.contains(savedIllnesses, illness.name);
        });

        $scope.saved = savedIllnesses;
      }
    }
  ]);
// these are applicant's saved illnesses
angular.module('profile')
  .directive('shSavedIllnesses', [
    'config.paths',
    'application.model',
    function (paths, applicationModel) {

      return {
        scope: true,
        templateUrl: paths.partials + '/components/profile/illnesses/saved.html',
        link: function ($scope, $element) {
          var members = applicationModel.getMembers();
          $scope.applicantCount = members.length;
          setSaved();

          $scope.addIllness = function () {
            $scope.$emit('illness-add');
          };

          function setSaved() {
            $scope.saved = _.map(applicationModel.getIllnesses(), function (illness) {
              return {
                name: illness,
                members: _.filter(members, function (member) {
                  return _.contains(member.illnesses, illness);
                })
              };
            });
          }

          $scope.removeIllness = function (illness) {

            _.each(members, function (member) {
              member.illnesses = _.without(member.illnesses, illness.name);
            });

            setSaved();
            $scope.$emit('illness-remove');
          };
        }
      }

    }
  ]);
angular.module('profile')
  .directive('shAddressForm', [
    'config.paths',
    'profile.details.form',
    'application.model',
    function(paths, detailsForm, applicationModel) {
      return {
        templateUrl: paths.partials + '/components/profile/location/address-form.html',
        scope: {
          address: '=', // address might not always be the address on the application, could be home address vs mailing address
          onChange: '&',
          onNoChange: '&',
          isExtended: '='
        },
        link: function ($scope) {
          detailsForm.setup($scope);

          var cachedRegion      = $scope.address.region;
          var cachedState       = $scope.address.state;

          $scope.locations = null;

          $scope.onZipChange = function(locations){

            if (locations.length > 1){
              $scope.address.city = locations[0].city;
              $scope.locations = locations;
            }
            else if (locations.length < 1) {
              $scope.locations = null;
            }
            else {
              $scope.setAddress(locations[0]);
            }
          };

          $scope.setAddress = function(location){
            angular.extend($scope.address, location);
            $scope.addressChanged = cachedRegion && cachedState && (cachedRegion !== location.region || cachedState !== location.state);
            $scope.locations = null;
          };
        }
      }
    }
  ]);
(function(){

  /**
   * @constructor profile.zipObEntryController
   * @param $scope
   * @param $state
   * @param $location
   * @param applicationModel
   * @param authService
   */
  function ZipObEntryController($scope, $state, $location, applicationModel, authService){

    var self = this;
    var initialStatus = 'initial';
    /**
     * @type {string}
     */
    this.zipcode = ($location.search()).zipcode || _.get(applicationModel, 'address.zipcode', '');
    /**
     * @type {string}
     */
    this.appStatus = initialStatus;

    this.startOver = function(){
      applicationModel
        .reset()
        .then(function(){
          self.appStatus = initialStatus;
        });
    };

    this.go = function(form){
      if (form.$valid){
        $state.go('ob.location', { zipcode: self.zipcode });
      }
    };

    $scope.$watch(authService.isAuthenticated, function(){

      if (applicationModel.isComplete()){
        self.appStatus = 'submitted';
      }
      else {
        self.appStatus = applicationModel.getStatus() === 'onboarding' ? (applicationModel.get().obStep || initialStatus) : 'buy';
      }

    });
  }
  ZipObEntryController.$inject = ['$scope', '$state', '$location', 'application.model', 'services.auth'];

  angular.module('profile')
    .controller('profile.zipObEntry.controller', ZipObEntryController);
}());

angular.module('profile')
  .directive('shZipcode', [
    '$parse',
    'search.geo',
    function($parse, geoService){

      return {
        restrict: 'A',
        require: 'ngModel',
        link: function($scope, $element, $attr, ngModelController){
          var onZipChange = angular.noop;
          var zipChangeAttr = $attr.shOnChange;
          var forceInitial = $attr.forceInitial;

          if (zipChangeAttr){
            onZipChange = $parse(zipChangeAttr);
          }

          $scope.$watch(function(){ return ngModelController.$modelValue; }, function(newValue, oldValue){
            if ((forceInitial && /\d{5}/.test(newValue)) || newValue !== oldValue){
              doSearch(newValue);
              forceInitial = false;
            }
          });

          function doSearch(zip){
            ngModelController.$setValidity('zipExists', false);
            geoService.getByZip(zip)
              .then(function(list){
                ngModelController.$setValidity('zipExists', !!list.length);
                onZipChange($scope, { locations: list });
              });
          }

          ngModelController.$validators.zip = function(value){
            return /\d{5}/.test(value);
          };
        }
      };
    }
  ]);
angular.module('profile')
  .controller('profile.subsidy.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'services.alert',
    'baseUser',
    function ($scope, $state, applicationModel, alertService, userModel) {
      if (!applicationModel.hasValidDemos()) {
        return;
      }

      $scope.decline = function () {
        applicationModel.killSubsidy()
          .save(userModel)
          .then(function () {
            $state.go($state.getData().completeState);
          });
      };

      alertService.setMessage({
        key: 'profile.alert.subsidyIntro'
      });
    }
  ])

  .controller('profile.household.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'baseUser',
    function ($scope, $state, applicationModel, userModel) {
      if (!applicationModel.hasValidDemos()) {
        return;
      }

      var application = applicationModel.get();
      var applicantsSize = applicationModel.getCoveredMembers().length;
      //var applicantsSize = applicationModel.members.length;

      application.taxInfo = application.taxInfo || {};
      $scope.householdSizes = _.times(8, function (n) {
        return n + applicantsSize;
      });

      $scope.selectSize = function (size) {
        application.taxInfo.familySize = size;

        applicationModel.save(userModel)
          .then(function () {
            $state.go($state.getData().nextState);
          });
      };

      // pre-pop family size from the user if possible and skip that step
      var userFamilySize = userModel.getTaxData().familySize;
      if (!application.taxInfo.familySize && _.isNumber(userFamilySize)) {
        $scope.selectSize(userFamilySize);
      }
    }
  ])

  .controller('profile.income.controller', [
    '$scope',
    '$state',
    '$filter',
    'services.subsidy',
    'baseHealthApp',
    'services.alert',
    'plan.stats',
    'plan.utils',
    'utils',
    'services.tracking',
    'baseUser',
    'logger',
    'income.service',
    'member.service',
    'finance.service',
    function ($scope, $state, $filter, subsidyService, applicationModel, alertService, planStats,
              planUtils, utils, trackingService, userModel, logger, incomeService, memberService, financeService) {

      if (!applicationModel.hasValidDemos()) {
        return;
      }

      var self = this;
      var alertKeyPrefix = 'profile.alert.';
      var application = applicationModel.get();
      var state = applicationModel.getState();
      var filterNumber = $filter('number');
      application.taxInfo = _.extend(userModel.getTaxData(), application.taxInfo || {});
      var taxInfo = application.taxInfo;
      var benchmarkPremium = 0;
      var viewModel = $scope.viewModel = {};
      this.estimatedIncome = {};

      // Default to weekly on init
      $scope.taxInfo = taxInfo;
      if (!$scope.taxInfo.frequency) {
        $scope.taxInfo.frequency = 'yearly';
      }

      // Populate amount based off taxInfo.income and frequency chosen
      if ($scope.taxInfo.income && $scope.taxInfo.frequency) {
        this.estimatedIncome = incomeService.calculateAmount($scope.taxInfo.income, $scope.taxInfo.frequency);
      }

      // calculateIncome gets called on selection change
      this.calculateIncome = function () {
        if (this.estimatedIncome && $scope.taxInfo.frequency) {
          $scope.taxInfo.income = incomeService.calculateIncome(this.estimatedIncome, $scope.taxInfo.frequency);
        } else {
          $scope.taxInfo.income = 0;
        }
      };

      // Need to call calculate income on init if user already selected options
      this.calculateIncome();

      if ($state.current.name.indexOf('qualify') === -1){
        planStats.getBenchmark(applicationModel)
          .then(function (premium) {
            benchmarkPremium = premium * 12 || 0;
            //setSubsidy()
            //  .then(function () {
            return subsidyService.getMaxQualifyingIncome(state, taxInfo.familySize, benchmarkPremium)
              //})
              .then(function (maxIncome) {
                alertService.setMessage({
                  key: alertKeyPrefix + 'incomeAmount',
                  model: {
                    amount: filterNumber(maxIncome, 0)
                  }
                });
              });
          })
          .catch(function (err) {
            var payload = {
              message: 'No benchmark premium plan',
              statusCode: err && err.status
            };

            if (err && err.config) {
              payload.req = _.pick(err.config, ['params', 'url']);
            }

            logger.error(payload);
            $scope.noBenchmark = true;
          });
      }

      $scope.isConfirm = false;

      $scope.onNext = function () {
        return setSubsidy()
          .then(function () {
            return $state.go($state.getData().completeState);
          });
      };

      $scope.skip = function () {
        $scope.isConfirm = true;

        alertService.setWarning({
          key: alertKeyPrefix + 'incomeSkip'
        });
      };

      $scope.decline = function () {
        //Mixpanel no savings
        trackingService.setPeopleProp(trackingService.propEnum.subsidy, false);

        return applicationModel.killSubsidy().save(userModel)
          .then(function () {
            $state.go($state.getData().completeState);
          });
      };

      $scope.setIncome = function () {
        return setSubsidy()
          .then(function () {
            return $state.go('.qualify');
          })
          .catch(showError);
      };

      function setSubsidy() {
        application.taxInfo.guided = false;
        console.log('SET APP MODEL taxInfo.guided', false);
        $scope.isConfirm = false;

        trackingService.mixpanelEvent(trackingService.propEnum.obIncome, {
          'Source': 'onboarding: simple',
          'Frequency': taxInfo.frequency,
          'Amount': self.estimatedIncome,
          'Calculated Yearly Estimate': taxInfo.income
        });

        return memberService.getAppMembers(userModel, applicationModel.getId())
          .then(function (members) {
            var appMembers = _.filter(members, function (member) {
              return _.get(member, 'member_application.type') === 'coverage';
            });
            return subsidyService.getEstimate(state, taxInfo.income, taxInfo.familySize, planUtils.getApplicantParams(appMembers), benchmarkPremium)
          })
          .then(function (response) {
            var subsidy = response.estimate;
            if (subsidy.aptc > 0) {
              //Mixpanel: Eligible for Subsidy
              trackingService.setPeopleProp(trackingService.propEnum.subsidy, true);
              application.subsidy = {amount: subsidy.aptc, csr: subsidy.csr};
            }
            else {
              applicationModel.killSubsidy();
            }
          });
      }

      function showError(err) {
        if (err.data) {
          err = err.data;
        }

        if (_.isString(err)) {
          err = {message: err};
        }

        if (!err.message) {
          err.message = 'There has been an error on the server, please try your request again';
        }

        $scope.serverError = err;
      }

      $scope.$on('$destroy', alertService.clear);

      $scope.showHelp = function () {
        utils.toggleBool(viewModel, 'scrollIncomeHelp');
        viewModel.showIncomeMore = true;
      };
    }
  ])
  .controller('profile.income.qualify.controller', [
    '$q',
    '$scope',
    '$state',
    'services.date',
    'services.alert',
    'services.subsidy',
    'member.service',
    'baseUser',
    'baseHealthApp',
    'plan.stats',
    'plan.utils',
    'utils',
    'logger',
    'services.tracking',
    'finance.service',
    function ($q, $scope, $state, dateService, alertService, subsidyService, memberService, userModel, applicationModel,
              planStats, planUtils, utils, logger, trackingService, financeService) {

      var self = this;
      var viewModel = $scope.viewModel = {};
      var application = applicationModel.get();
      var taxInfo = application.taxInfo;
      var householdSize = taxInfo.familySize;

      if (!applicationModel.hasValidDemos()) {
        return;
      }

      // var estimationType = financeService.getEstimationType();
      // user has not come thru either flow
      if (taxInfo.guided === undefined || taxInfo.income === null) {
        return $state.go('ob.savings.estimate');
      }

      // Get income from finance service
      $q.when(true)
        .then(function () {
          return taxInfo.guided ? financeService.getIncomeTotal(applicationModel) : taxInfo.income;
        })
        .then(function (income) {
          taxInfo.income = income;

          // Get app members to get an estimate on
          return memberService.getAppMembers(userModel, applicationModel.getId());
        })
        .then(function (members) {
          // Filter out members not on the app
          var appMembers = applicationModel.getCoveredAndMedicaidMembers(members);

          self.appMembers = appMembers;
          return planStats.getCoveredMembersEstimate(taxInfo.income, householdSize, applicationModel, appMembers);
        })
        .then(function (response) {
          self.subsidyInfo = response;
          _.extend($scope, response.oldMemberEligibility);

          var latestEligibilities = subsidyService.getLatestEligibilities(response.oldMemberStatuses, response.newMemberStatuses);
          var estimate = response.newEstimate;
          var latestArrays = subsidyService.checkApplicants(latestEligibilities, estimate, self.appMembers);
          var medicaidIds = _.pluck(latestArrays.medicaidMembers, 'id');

          $scope.monthlyAmount = estimate.aptc;
          // trackingService.mixpanelEvent('Subsidy Evaluated', {
          //   subsidy: estimate.aptc,
          //   source: applicationModel.get().taxInfo.guided ? 'guided' : 'simple'
          // });
          $scope.coverageMembers = _.reject(self.appMembers, function(member){ return _.contains(medicaidIds, member.id); });
          return subsidyService.getPenalty(taxInfo.income, planUtils.getApplicantParams(self.appMembers));
        })
        .then(function (response) {
          $scope.penalty = response;
          $scope.render = true;
        })
        .catch(function (err) {
          $scope.subsidyType = 'noSavings';

          if (err.status && err.status === 404) {
            var payload = {
              message: 'No benchmark premium plan',
              statusCode: err && err.status
            };

            if (err && err.config) {
              payload.req = _.pick(err.config, ['params', 'url']);
            }

            logger.error(payload);
            $scope.noBenchmark = true;
          } else {
            logger.error(err && err.message || err);
            $state.replace('500');
          }
        });

      /**
       * Show Medicaid description toggle
       */
      $scope.showMedicaidDesc = function () {
        utils.toggleBool(viewModel, 'scrollMedicaidHelp');
        viewModel.showMedicaidMore = true;
      };

      /**
       * Continue on subsidy display screen
       * @returns {*}
       */
      $scope.continue = function () {
        if ($scope.subsidyMembers && $scope.subsidyMembers.length) {
          // Set medicaid members status to 'medicaid'
          if ($scope.medicaidMembers.length) {
            _.each(self.appMembers, function (appMember) {
              if (_.findWhere($scope.medicaidMembers, {id: appMember.id})) {
                _.extend(appMember, {status: 'medicaid'});
              } else {
                _.extend(appMember, {status: 'coverage'});
              }
            });

            // Save updated app members
            return applicationModel.saveMembers(userModel, self.appMembers)
              .then(function () {
                return saveAppAndContinue(self.subsidyInfo);
              });
          } else {
            return saveAppAndContinue(self.subsidyInfo);
          }
        }

        // Kill subsidy if no one is subsidized
        return applicationModel.killSubsidy().save(userModel)
          .then(function () {
            //Mixpanel no savings
            trackingService.setPeopleProp(trackingService.propEnum.subsidy, false);
            $state.go($state.getData().completeState);
          });
      };

      function saveAppAndContinue(subsidyInfo) {
        var subsidy = subsidyInfo.newEstimate || subsidyInfo.oldEstimate;
        if (subsidy.aptc > 0) {
          //Mixpanel: Eligible for Subsidy
          trackingService.setPeopleProp(trackingService.propEnum.subsidy, true);
          applicationModel.setSubsidy(subsidy.aptc, subsidy.csr);
        }
        else {
          applicationModel.killSubsidy();
          trackingService.setPeopleProp(trackingService.propEnum.subsidy, false);
        }

        return applicationModel.save(userModel)
          .then(function () {
            return $state.go($state.getData().completeState);
          })
          .catch(function (err) {
            logger.error(err && err.message || err);
            applicationModel.killSubsidy().save(userModel)
              .then(function () {
                $state.replace('500');
              });

          });
      }

      alertService.clear();
    }
  ]);
angular.module('profile')
  .directive('shVisits', [
    'config.paths',
    'search.visits',
    'user.model',
    'application.model',
    function(paths, visitSearch, userModel, applicationModel){
      var keys = ['primary', 'specialist','obgyn','mental'];

      return {
        scope: true,
        link: function($scope){

          visitSearch.get(applicationModel)
            .then(function(allVisits){

              //$scope.visits = _.map(allVisits, function(val, key){ return { name: key.toLowerCase(), count: val }; });

              //var total = _.reduce(applicationModel.getApplicants(), function(memo, applicant){
              //  var visits = allVisits[applicant.uuid];
              //
              //  _.each(_.keys(visits), function(key){
              //    memo[key] = memo[key] && memo[key] + visits[key] || visits[key];
              //  });
              //
              //  return memo;
              //}, {});
              //

              $scope.visits = _.map(keys, function(key){
                return {
                  name: key,
                  count: allVisits[key.toUpperCase()]
                };
              });
            });


//          var visits = _.map(applicants,

//          $scope.application = applicationModel.get();
//          //$scope.applicants = applicationModel.getApplicants();
//          $scope.expanded = -1;
//
//          $scope.$watch(function(){ return applicationModel.getVisitCount() }, setApplicants);
//
//          $scope.expand = function(index){
//            if ($scope.expanded == index){
//              $scope.expanded = -1;
//            }
//            else {
//              $scope.expanded = index;
//            }
//          };
//
//          $scope.getApplicantTotal = function(applicant){
//            return _.reduce(applicant.visits, function(total, visit){
//              return total + visit.count;
//            }, 0);
//          };
//
//          $scope.save = function($event){
//            $event.preventDefault();
//
//            _.each(applicationModel.getApplicants(), function(applicant){
//              var local = _.findWhere($scope.applicants, { uuid: applicant.uuid });
//
//              if (local){
//                applicant.visits = local.visits;
//              }
//            });
//
//            userModel.save();
//          };
//
//          function setApplicants(){
//            $scope.applicants = _.map(applicationModel.getApplicants(), function(applicant){
//
//              return {
//                name: applicant.name,
//                uuid: applicant.uuid,
//                visits: ngCopy(applicant.visits),
//                total: _.reduce(applicant.visits, function(total, visit){
//                  return total + visit.count;
//                }, 0)
//              }
//
//            });
//          }
        },
        templateUrl: function($elem, $attr){
          return $attr.templateUrl || paths.partials + '/components/profile/visits/visits-directive.html';
        }
      };
    }
  ]);
angular.module('search')
  .factory('search.visits', [
    'plan.search',
    function(planSearch){

      return {
        get: get,
        setApplicants: setApplicants
      };



      function get(applicationModel){
        // TODO: there isn't a separate endpoint set up for this yet
        return planSearch.getRecommendation(applicationModel)
          .then(function(reco){
            return reco && reco.visits || {};
          });
      }

      function setApplicants(applicationModel){
        return get(applicationModel)
          .then(function(allVisits){
            // TODO: we should define how we want visits stored
            return _.each(applicationModel.getMembers(), function(applicant){
//              applicant.visits = _.map(allVisits[applicant.uuid], function(applicantVisits){
//
//              })

              applicant.visits = allVisits[applicant.id] || {};
            })
          })
      }

    }
  ]);
//(function () {
//
//    /**
//     *
//     * @param userModel
//     * @constructor
//     */
//    function ProviderService($rootScope, $q, $http, config, utils, userModel, applicationModel, session,
//                             trackingService, searchRequest) {
//      var self = this;
//      this.providers = [];
//      this.doctors = [];
//      this.dentists = [];
//      this.result = {
//        added: false,
//        removed: false,
//        location: null,
//        reason: null
//      };
//      var baseUrl = config.paths.services;
//      var searchBaseUrl = '/provider';
//
//      /**
//       * Get doctors
//       * @returns {*}
//       */
//      this.getDoctors = function () {
//        //If user is logged in, use resource to get doctors and check if there are any doctors in the session that need to be merged
//        if (userModel.isLoggedIn) {
//          // Get doctors from resource
//          return $http.get(baseUrl + '/user/providers', {params: {userId: userModel.getId(), productType: 'health'}})
//            .then(function (response) {
//              // Get details of all the doctors returned from the resource
//              return getDetailsOfProviderArray(response && response.data);
//            })
//            .then(function (response) {
//              // Resource doctors with details
//              var doctors = _.pluck(response, 'details');
//
//              // Add product type of health to the details
//              self.doctors = _.each(doctors, function (doctor) {
//                _.extend(doctor, {product_type: 'health'});
//              });
//
//              return self.doctors;
//            });
//        } else {
//          return $q.when(session.get('doctors'));
//        }
//      };
//
//
//      /**
//       * Get dentists
//       * @returns {*}
//       */
//      this.getDentists = function () {
//        if (userModel.isLoggedIn) {
//          return $http.get(baseUrl + '/user/providers', {params: {userId: userModel.getId(), productType: 'dental'}})
//            .then(function (response) {
//              // Get details of all the dentists returned from the resource
//              return getDetailsOfProviderArray(response && response.data);
//            })
//            .then(function (dentists) {
//              var dentists = _.pluck(dentists, 'details');
//              self.dentists = _.each(dentists, function (dentist) {
//                _.extend(dentist, {product_type: 'dental'});
//              });
//              return self.dentists;
//            });
//        } else {
//          return $q.when(this.dentists)
//            .then(function () {
//              return self.dentists;
//            });
//        }
//      };
//
//      /**
//       * Get provider of type
//       * @param type
//       */
//      this.getProviders = function (type) {
//        if (type === 'health') {
//          return this.getDoctors();
//        }
//        return this.getDentists();
//      };
//
//      /**
//       * Add a provider
//       * @param provider
//       * @returns {*}
//       */
//      this.addProvider = function (provider) {
//        if (userModel.isLoggedIn && !contains(this.providers, provider)) {
//          // Add provider to user resource if logged in
//          return $http.post(baseUrl + '/member/provider', {
//              provider: provider,
//              userId: userModel.getId(),
//              memberId: userModel.getPrimaryId()
//            })
//            .then(function (response) {
//              trackingService.incrementPeopleProp(trackingService.propEnum.doctorAdd);
//              provider.product_type === 'health' ? self.doctors.push(provider) : self.dentists.push(provider);
//              self.providers.push(provider);
//              utils.dataOrObject(response);
//              self.result.added = true;
//              self.result.location = 'user';
//              $rootScope.$broadcast('provider-added');
//              return self.result;
//            })
//            .catch(function () {
//              return self.result;
//            });
//        } else {
//          // Add to session if there's no app
//
//          // TODO: Dentists aren't allowed outside of onboarding yet. Change this when that feature is ready
//          // add type of health to provider for now as this can only be a doctor at this point
//          var providerWithType = _.extend(provider, {product_type: 'health'});
//
//          var sessionDoctors = session.get('doctors') || [];
//          //var sessionDentists = session.get('dentists') || [];
//
//          // Add to session doctors if not already in the array
//          if (!contains(sessionDoctors, providerWithType) && providerWithType.product_type === 'health') {
//            sessionDoctors.push(providerWithType);
//            session.set('doctors', sessionDoctors);
//          }
//
//          // TODO: Dentists aren't allowed outside of onboarding yet. Enable when that feature is ready
//          // Add to session dentists if not already in the array
//          //if (!contains(sessionDentists, provider) && provider.product_type === 'dental') {
//          //  sessionDentists.push(provider);
//          //  session.set('dentists', sessionDentists);
//          //}
//
//          // Add to service arrays
//          if (!contains(this.providers, providerWithType)) {
//            self.providers.push(providerWithType);
//            self.doctors.push(providerWithType);
//
//            // TODO: Dentists aren't allowed outside of onboarding yet. Enable when that feature is ready
//            //if (provider.product_type === 'health') {
//            //  self.doctors.push(provider);
//            //} else {
//            //  self.dentists.push(provider);
//            //}
//          }
//          trackingService.incrementPeopleProp(trackingService.propEnum.doctorAdd);
//          self.result.added = true;
//          self.result.location = 'session';
//
//          $rootScope.$broadcast('provider-added');
//          return $q.when(self.result);
//        }
//      };
//
//      this.addSessionProvidersToMember = function () {
//        if (userModel.isLoggedIn) {
//          var sessionDoctors = session.get('doctors') || [];
//          _.each(sessionDoctors, self.addProvider);
//        }
//      };
//
//      /**
//       * Gets provider details using provider id
//       * @name provider.service.getById
//       * @methodOf provider.service
//       * @param {string|string[]|number|number[]} id
//       * @param {number} [networkId]
//       * @returns {Promise<doctor.model>}
//       */
//      this.getById = function (id, networkId) {
//        if (_.isArray(id)) {
//          return $q.all(_.map(id, function (_id) {
//            return self.getById(_id, networkId);
//          }));
//        }
//
//        var params = {};
//
//        if (_.isNumber(networkId)) {
//          params.patientNetwork = networkId;
//        }
//
//        return searchRequest
//          .get(searchBaseUrl + '/' + id, {cache: true, params: params})
//          .then(function (result) {
//            if (!result || !result.data) {
//              return {};
//            }
//
//            var data = result.data;
//            data = mapResult(data);
//
//            return setName(data);
//          });
//      };
//
//      /**
//       * Remove provider
//       * @param provider
//       * @returns {*}
//       */
//      this.removeProvider = function (provider) {
//        if (userModel.isLoggedIn) {
//          // Remove provider from user resource if logged in
//          return $http.delete(baseUrl + '/member/provider', {
//              params: {
//                providerId: provider.id,
//                userId: userModel.getId(),
//                memberId: userModel.getPrimaryId()
//              }
//            })
//            .then(function (response) {
//              if (response && response.data === true) {
//                removeProviderFromArrays(provider);
//                self.result.removed = true;
//                self.result.location = 'user';
//                return self.result;
//              }
//            })
//            .catch(function () {
//              return self.result;
//            });
//        } else {
//          return $q.when(removeProviderFromArrays(provider));
//        }
//      };
//
//      /**
//       * Removes provider from the service, application, and session arrays
//       * @param provider
//       */
//      function removeProviderFromArrays(provider) {
//        var remaining = [];
//        var appRemaining = [];
//        var remainingSession = [];
//
//        var userProviders = applicationModel && applicationModel.getPrimary() && applicationModel.getPrimary().providers;
//
//        // Service provider array
//        var remainingProviders = remove(self.providers, provider);
//        self.providers = remainingProviders;
//
//        // Remove provider from application
//        if (userProviders) {
//          appRemaining = remove(userProviders, provider);
//          applicationModel.getPrimary().providers = appRemaining;
//          applicationModel.save();
//        }
//
//        if (provider.product_type === 'dental') {
//          // Remove dentist from service
//          remaining = remove(self.dentists, provider);
//          self.dentists = remaining;
//
//          // Remove dentist from session
//          remainingSession = remove(session.get('dentists'), provider);
//          session.set('dentists', remainingSession);
//        } else {
//          // Remove doctor from service
//          remaining = remove(self.doctors, provider);
//          self.doctors = remaining;
//
//          // Remove doctor from session
//          remainingSession = remove(session.get('doctors'), provider);
//          session.set('doctors', remainingSession);
//        }
//      }
//
//
//      function remove(array, provider) {
//        return _.reject(array, function (currentProvider) {
//          return provider.id === currentProvider.id;
//        });
//      }
//
//      function contains(array, provider) {
//        return _.find(array, function (doc) {
//          return provider.id === doc.id;
//        });
//      }
//
//      /**
//       * Merges 2 arrays of providers and prevent any duplicate provider ids
//       */
//      function mergeProviderArrays(providerArray1, providerArray2) {
//        var toAddProviders = [];
//
//        if (providerArray1 && providerArray2) {
//          _.each(providerArray2, function (doc) {
//            if (!contains(providerArray1, doc)) {
//              toAddProviders.push(doc);
//            }
//          });
//        }
//
//        return providerArray1.concat(toAddProviders);
//      }
//
//      function setName(doc) {
//        doc.name = utils.capitalize(doc.firstName + ' ' + doc.lastName);
//        return doc;
//      }
//
//      function mapResult(result) {
//        var provider = result.provider;
//        provider.networkStatus = result.networkStatus;
//        provider.distanceMi = result.distanceMi;
//        return provider;
//      }
//
//      /**
//       * Gets details given provider object array with 'provider_id'
//       * @param providers
//       * @param networkId
//       * @returns {*}
//       */
//      function getDetailsOfProviderArray(providers, networkId) {
//        if (!providers.length) {
//          return [];
//        }
//
//        return self.getById(_.pluck(providers, 'provider_id'), networkId)
//          .then(function (details) {
//            return _.map(providers, function (provider) {
//
//              return {
//                provider: provider,
//                // not currently possible, but what happens if a user adds
//                // the same doctor for 2 different members? this would just
//                // user the first match of the details, which should be ok
//                // since they would be the same resource
//                details: _.findWhere(details, {id: provider.provider_id})
//              };
//
//            });
//
//          });
//      }
//
//      this.getDetailsFromProviderIdArray = function (providers, networkId) {
//        if (!providers.length) {
//          return [];
//        }
//        return self.getById(providers, networkId);
//      }
//    }
//
//    ProviderService.$inject = ['$rootScope', '$q', '$http', 'config', 'utils', 'user.model', 'application.model',
//      'services.session', 'services.tracking', 'search.request'];
//
//    angular.module('provider')
//      .service('provider.service', ProviderService);
//  }()
//);
angular.module('profile')
  .controller('profile.qualify.controller', [
    '$scope',
    '$state',
    'application.model',
    'user.model',
    'services.date',
    function($scope, $state, applicationModel, userModel, dateService){
      var today = new Date();
      $scope.eventObj = null;

      $scope.lifeEvent = {
        id: applicationModel.qualifying_event,
        date: applicationModel.qualifying_event_date
      };

      $scope.dateRange = [
        new Date(today.getFullYear(), today.getMonth(), today.getDate() - 55),
        new Date(today.getFullYear(), today.getMonth(), today.getDate() + 60)
      ];

      // always make sure they land on qualify first so they can pick their event
      if (!applicationModel.hasLifeEvent() && $state.current.name.indexOf('date') > -1){
        $state.go('^');
      }

      $scope.selectEvent = function(event){
        $scope.eventObj = event;
        $scope.lifeEvent.text = event.text;
        $scope.lifeEvent.id = event.key;
        $state.go('.date');
      };

      $scope.submit = function(){
        applicationModel.saveQE(userModel, $scope.lifeEvent.id, $scope.lifeEvent.date)
          .then(function(ifp_app){

            applicationModel.qualifying_event = ifp_app.qualifying_event;
            applicationModel.qualifying_event_date = dateService.fromIsoDate(ifp_app.qualifying_event_date);

            $state.go($state.current.data.nextState);
          });
      };
    }
  ]);


(function(){

  /**
   * @name questions.builderCtrl Utilizes the Builder interface for get/set values and finish
   * @param {ng.$window} $window
   * @param {ui.router.state.$state} $state
   * @param {$rootScope.Scope} $scope
   * @param {ui.router.state.$stateParams} $stateParams
   * @param {ng.$parse} $parse
   * @param {Builder} builder The Builder instance to work on
   * @constructor
   */
  function Ctrl($window, $state, $scope, $stateParams, $parse, builder){
    var self = this;
    var keys = $stateParams.keys && $stateParams.keys.split(',');
    /**
     * @type {Question[]}
     */
    var questions = builder.getValue('questions') || [];
    var questionIndex = _.findIndex(questions, function(question){ return _.isEqual(question.keys, keys); });
    var question = questionIndex > -1 && questions[questionIndex]; //_.find(questions, function(question){ return _.isEqual(question.keys, keys); });

    if (!question){
      $state.replace('^');
      return;
    }

    /**
     * @type {Question}
     */
    this.question = question;
    this.type = question.response_type;
    this.translationBase = builder.getValue('translationBase');

    var exposedLocals = { 'Math': $window.Math, 'Number': $window.Number };

    if (this.type === 'array' && question.answers){
      var cachedAnswer = builder.getValue(keys);
      this.answers = _.map(question.answers, function(answer){
        return {
          key: answer,
          selected: _.isArray(cachedAnswer) && cachedAnswer.indexOf(answer) > -1
        };
      });
    }

    if (this.type === 'form'){
      if (self.question.modelMapper){
        $scope.model = $parse(self.question.modelMapper.set)(builder, exposedLocals);
      }
      else {
        $scope.model = {};
      }
    }

    this.setValue = function(value){
      builder.setValue(keys[0], value);
      goNext();
    };

    this.setValues = function(){
      var answers = _.where(this.answers, { selected: true });
      builder.setValue(keys[0], _.pluck(answers, 'key'));
      goNext();
    };

    this.submitForm = function(){
      if (self.question.modelMapper){
        var mapFn = $parse(self.question.modelMapper.get);
        builder.setValues(mapFn($scope.model, exposedLocals));
      }
      else {
        builder.setValues($scope.model);
      }

      goNext();
    };

    function goNext(){
      builder.next(questionIndex);
    }
  }
  Ctrl.$inject = ['$window', '$state', '$scope', '$stateParams', '$parse', 'builder'];

  angular.module('questions')
    .controller('questions.builderCtrl', Ctrl);

}());
angular.module('sidebar')
  .constant('sidebar.steps.config', {
    profile: {
      steps: [
        { key: 'location', state: 'ob.location' },
        { key: 'family', state: 'ob.family' },
        { key: 'doctors', state: 'ob.doctors' },
        { key: 'drugs', state: 'ob.drugs' },
        { key: 'illnesses', state: 'ob.illnesses' },
        { key: 'savings', state: 'ob.savings' }
      ]
    },
    plan: {
      steps: [
        { key: 'pickPlan', state: 'recommended' },
        { key: 'compare', state: 'personalPlans' }
      ]
    },
    dental: {
      steps: [
        { key: 'intro', state: 'dental.intro' },
        { key: 'family', state: 'dental.family', isHidden: function($scope, healthApp){
          return healthApp.getMembers().length < 2;
        } },
        { key: 'dentists', state: 'dental.dentists' },
        { key: 'pickPlan', state: 'dental.plans' }
      ]
    },
    apply: {
      steps: [
        { key: 'qualify', state: 'buy.qualify', isHidden: function($scope){
          return $scope.globals.isOep;
        } },
        { key: 'address', state: 'buy.address' },
        { key: 'applicants', state: 'buy.applicants' },
        //{ key: 'extras', state: 'buy.extras' },
        { key: 'billing', state: 'buy.billing' },
        { key: 'confirm', state: 'buy.confirm' },
        { key: 'eSign', state: 'buy.eSign' }
      ]
    },

    subsidy: {
      steps: [
        { key: 'subsidy', state: 'ffm.intro' },
        { key: 'sync', state: 'ffm.sync' },
        { key: 'amount', state: 'ffm.amount' },
        { key: 'confirm', state: 'ffm.confirm' }
      ]
    }
  });
(function(){

  /**
   * Controls disabled, active, done flagging for nav items
   * This is just single level for now
   * @constructor sidebar.steps.controller
   * @param {ui.router.state.$state} $state
   * @param {ng.$scope} $scope
   */
  function SidebarStepsController($state, $scope, userModel){
    var self      = this;

    /**
     * @type {string[]}
     */
    var steps     = $state.current.data.steps;

    /**
     * @typedef {Object} sidebar.step
     * @property {string} name
     * @property {boolean} disabled
     * @property {boolean} active
     * @property {boolean} done
     */


    /**
     * @type {sidebar.step[]}
     */
    this.steps = _.map(steps, function(step){

      var s = angular.copy(step);
      s.disabled = true;
      s.active = s.done = false;

      return s;
    });

    /**
     * Update the disabled, active, done status of each step
     * @param {string} newName
     */
    this.update = function(newName){
      // findLastIndex so most specific step name matches first
      var index = _.findLastIndex(self.steps, function(step){
        // using indexOf instead of equality so child states can match
        return _.isString(step.name) && newName.indexOf(step.name) === 0;
      });

      // don't update the navigation if the step isn't included
      if (index >= 0){
        _.each(self.steps, function(step, i){
          step.disabled = step.active = step.done = false;

          if (_.isFunction(step.isHidden)) {
            step.hidden = step.isHidden(userModel);
          }
          else {
            step.hidden = false;
          }

          if (i > index){
            step.disabled = true;
          }
          else if (i === index){
            step.active = true;
          }
          else {
            step.done = true;
          }

        });
      }

      self.visibleStepCount =_.countBy(self.steps, function(step) {
        return step.hidden !== true;
      }).true;
    };

    var debouncedUpdate = _.debounce(this.update, 50);

    // update on each state change
    $scope.$on('$stateChangeSuccess', function($event, toState){
      debouncedUpdate(toState.name);
    });
    this.update($state.current.name);
  }
  SidebarStepsController.$inject = ['$state', '$scope', 'baseUser'];

  angular.module('sidebar')
    .controller('sidebar.steps.controller', SidebarStepsController);

}());
angular.module('user')
  .controller('user.login.controller', [
    '$q',
    '$scope',
    '$state',
    '$location',
    '$stateParams',
    '$timeout',
    'services.auth',
    'user.service',
    'baseUser',
    'baseHealthApp',
    /**
     *
     * @param $q
     * @param $scope
     * @param $state
     * @param $location
     * @param $stateParams
     * @param $timeout
     * @param authService
     * @param userService
     * @param userModel
     * @param {health.app} workingApp
     */
    function ($q, $scope, $state, $location, $stateParams, $timeout, authService, userService, userModel, workingApp) {

      var lock = false;
      var stateData = $state.getData();
      var existingUser = $stateParams.user;

      var loginModel = {
        username: existingUser || '',
        password: '',
        confirm: ''
      };

      if (authService.isAuthenticated()) {
        onSuccess();
        return;
      }

      // set render flag for any views that prevent render flash
      $scope.render = true;
      $scope.existingUser = !!existingUser;
      $scope.loginModel = loginModel;

      this.create = function (form) {
        if (!lock) {
          lock = true;
          return userService.createFromForm(loginModel.username, loginModel.password, userModel, workingApp, form)
            .then(onSuccess)
            .catch(onError);
        }
      };

      this.login = function (form) {
        if (form.$valid && !lock) {
          lock = true;

          userModel.login(loginModel.username, loginModel.password)
            .then(function () {
              return workingApp.setFromWorking(userModel);
            })
            .then(onSuccess)
            .catch(onError);
        }
      };

      $scope.create = this.create;
      $scope.login = this.login;

      function onError() {
        lock = false;
        $scope.submitError = true;

        if (stateData && stateData.errorState) {
          $state.go(stateData.errorState, {user: loginModel.username});
        }
      }

      /**
       * @returns {{state: string|Object, params: Object}}
       */
      function getNextState() {
        var authPrevious = authService.getPreviousState();
        var nextState = 'dashboard';
        var nextStateParams = null;

        // this redirect state is going to be used mostly by marketing
        // so we should rely on the relative url instead of passing a state name
        // e.g. /broker-of-record/intro
        var redirectState = $stateParams.redirect && $state.fromUrl($stateParams.redirect) || null;

        if (redirectState && !redirectState.state.abstract) {
          nextState = redirectState.state;
          nextStateParams = redirectState.stateArgs;
        }

        else if (stateData && stateData.successState) {
          nextState = stateData.successState;
          nextStateParams = stateData.successStateParams;
        }

        else if (authPrevious) {
          nextState = authPrevious.state;
          nextStateParams = authPrevious.params;
        }

        return {state: nextState, params: nextStateParams};
      }

      function onSuccess() {
        lock = false;
        var nextState = getNextState();

        // Check session for any doctors and add to /member/providers resource
        //providerService.addSessionProvidersToMember();

        $state.go(nextState.state, nextState.params, {location: 'replace'});
      }
    }
  ]);
(function(){

  function Svc(){

  }
  Svc.$inject = ['user.service']

}());
angular.module('user')
  .directive('shUserLogout', [
    'user.model',
    function(userModel){
      return {
        restrict: 'A',
        link: function($scope, $element, $attr){
//          var onSuccess = angular.noop;

//          if ($attr.shUserLogout){
//            onSuccess = $parse($attr.shUserLogout);
//          }

          $element.on('click', function(e){
            e.preventDefault();

            userModel.logout();
          });
        }
      }
    }
  ]);
angular.module('user')
  .controller('user.reset.controller', [
    '$scope',
    '$state',
    '$stateParams',
    'user.model',
    'user.service',
    function($scope, $state, $stateParams, userModel, userService){

      $scope.resetModel = {
        email: $stateParams.email || '',
        password: '',
        confirm: ''
      };

      // if the user is already logged in, they shouldn't need this step
      // so send them to the change password state
//      $scope.$watch('user.isLoggedIn', function(newValue){
//        if (newValue){
//          $scope.$state.go('home')
//        }
//      });

      $scope.request = function(form){
        if (form.$valid){



          userService
            .requestResetPassword($scope.resetModel.email)
            .then(function(response){
              $scope.requestSent = true;

              if (response && response.data){

                if (response.data.status == 'ERROR'){
                  $scope.submitError = response.data.message;
                }

              }
            });
        }
      };

      $scope.reset = function(form){
        var code = $stateParams.code;
        var email = $stateParams.email;

        if (form.$valid && code && email){

          $scope.requestSent = true;

          userService
            .resetPassword(code, email, $scope.resetModel.password)
            .then(function(response){
              var success = false;

              if (response && response.data){
                success = response.data.status == 'OK';
                $scope.submitError = response.data.message;
              }

              $scope.resetSuccess = success;
            });
        }
      };
    }
  ]);
angular.module('user')
  .controller('user.unverified.controller', [
    '$scope',
    '$state',
    'user.service',
    'user.model',
    'application.model',
    function($scope, $state, userService, userModel, applicationModel){

      $scope.$watch('userModel.isVerified', function(newValue){
        if (newValue === true){
          var newState = 'buy';

          switch (applicationModel.getStatus()){
            case 'submitted':
              newState = 'dashboard';
              break;
            case 'onboarding':
              newState = 'ob';
              break;
          }

          $state.go(newState);
        }
      });

      $scope.resend = function(){
        $scope.verifySent = true;
        userService.resendVerify();
      };

      $scope.recheck = function(){
        $scope.checkError = false;

        userModel.syncFromServer()
          .then(function(){
            if (!userModel.isVerified){
              $scope.checkError = true;
            }
          });
      };
    }
  ]);
angular.module('user')
  .controller('user.verify.controller', [
    '$scope',
    '$state',
    '$stateParams',
    'user.model',
    'user.service',
    function($scope, $state, $stateParams, userModel, userService){
      $scope.showSuccess = false;

      // auth service takes care of routing to login page
      if (userModel.isLoggedIn){
        userService.verify($stateParams.code)
          .then(function(userData){
            if (userData){
              userModel.fromServer(userData);
              $scope.showSuccess = true;
            }
            else {
              $scope.verifyFailed = true;
            }
          });
      }
    }
  ]);
(function(){

  /**
   * @name visit.plan.builderFactory
   * @param {ng.$q} $q
   * @param {Builder} Builder
   * @param {visit.service} visitService
   * @returns {visit.plan.builder}
   */
  function PlanBuilderFactory($q, Builder, visitService){
    var directMapKeys = [
      'id',
      'ifp_app',
      'ifp_app_id',
      'provider_id',
      'type',
      'notes',
      'recommended_benefits',
      'suggested_benefits', 
      'requested_benefits',
      'additional_services',
      'appointment_date',
      'reminder_date'
    ];

    /**
     * @name visit.plan.builder
     * @augments Builder
     * @constructor
     */
    function builder(){
      Builder.apply(this, arguments);
    }
    builder.prototype = new Builder();

    /**
     * @name visit.plan.builder.start
     * @methodOf visit.plan.builder
     * @param {object} [data]
     * @returns {visit.plan.builder}
     */
    builder.prototype.start = function(data){
      Builder.prototype.start.call(this, data);
      return this;
    };

    /**
     * @name visit.plan.builder.clear
     * @methodOf visit.plan.builder
     */
    builder.prototype.clear = function(){
      this.data = {};
    };

    /**
     * @name visit.plan.builder.start
     * @methodOf visit.plan.builder
     * @returns {Promise<VisitPlan>}
     */
    builder.prototype.finish = function(){

      /** @type {VisitPlan} **/
      var plan = {};
      var self = this;
      var data = this.data;

      if (!data.type || !data.member){
        return $q.reject('Incomplete builder');
      }

      _.each(directMapKeys, function(key){
        plan[key] = data[key];
      });

      plan.member_id = data.member.id;

      if (!this.changed()){
        console.log('plan not changed');
        return $q.when(plan);
      }

      console.log('saving visit plan', plan);
      return visitService.savePlan(plan)
        .then(function(savedPlan){
          self.setValue('id', savedPlan.id);
          return savedPlan;
        });
    };

    /**
     * @name visit.plan.builder.fromDetails
     * @methodOf visit.plan.builder
     * @param {VisitPlanDetails} details
     */
    builder.prototype.fromDetails = function(details){
      var data = _.pick(details.plan, directMapKeys);
      data.member = details.member;
      data.doctor = details.doctor;

      this.start(data);
    };

    /**
     * @name visit.plan.builder.getPayload
     * @methodOf visit.plan.builder
     * @returns {Object}
     */
    builder.prototype.getPayload = function(){
      var data = this.data || {};
      var type = data.visitType;
      var member = data.member;

      if (!member || !type){
        console.error('Malformed data', data);
        return null;
      }

      var risk_factors = member.risk_factors || {};
      return {
        visitType: type.key,
        age: member.age,
        gender: member.gender,
        pregnant: _.isBoolean(data.pregnant) ? data.pregnant : (risk_factors.pregnant || false),
        illnesses: data.illnesses || member.illnesses || [],
        attributes: _.pick(data, type.questionKeys)
      };
    };

    return new builder();
  }


  PlanBuilderFactory.$inject = ['$q', 'common.class.builder', 'visit.service'];

  angular.module('visit')
    .factory('visit.plan.builder', PlanBuilderFactory);
}());
(function(){

  /**
   * @name routes.bor.basicCtrl
   * @param {ui.router.state.$state} $state
   * @param {member.service} memberService
   * @param {user.model} userModel
   * @param {Member} PrimaryMember
   * @constructor
   */
  function Ctrl($state, memberService, userModel, PrimaryMember){
    var cachedPrimary = angular.copy(PrimaryMember);
    this.primary = PrimaryMember;

    this.next = function(){
      // no need to save
      if (angular.equals(cachedPrimary, this.primary)){
        return $state.goNext();
      }

      return memberService.saveMember(userModel, this.primary)
        .then($state.goNext);
    };
  }
  Ctrl.$inject = ['$state', 'member.service', 'baseUser', 'PrimaryMember'];

  angular.module('routes.bor')
    .controller('routes.bor.basicCtrl', Ctrl);
}());
/**
 * @namespace routes.borPreFunnel
 */

angular.module('routes.borPreFunnel', ['ui.router', 'user', 'common', 'search', 'visit', 'notification', 'session'])

/**
 * @name routes.borPreFunnel.config
 * @property {Object<string, string>} accountSource
 * @property {Object<string, string>} borSource
 * @property {Object<string, string>} notificationKey
 * @property {Object<string, string>} emailRecipient
 */
  .constant('routes.borPreFunnel.config', {
    accountSource: {
      concierge: 'health-concierge',
      taxHelp: 'tax-help'
    },
    borSource: {
      concierge: 'Health Concierge',
      taxHelp: 'Tax Questions'
    },
    notificationKey: {
      concierge: 'BOR_insurance_questions',
      taxHelp: 'BOR_tax_questions'
    },
    emailRecipient: {
      concierge: 'support',
      taxHelp: 'taxhelp'
    }
  })
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {
      $stateProvider
        .state('borPreFunnel', {
          parent: 'base',
          url: '/get-answers/:type',
          controller: 'routes.borPreFunnel.controller as borPreFunnelCtrl',
          templateUrl: paths.partials + '/routes/bor/borPreFunnel/borPreFunnel.html',
          redirectTo: 'borPreFunnel.questions',
          data: {
            scrollTop: true
          }
        })
        .state('borPreFunnel.questions', {
          url: '/questions',
          views: {
            '': {
              templateUrl: paths.partials + '/routes/bor/borPreFunnel/questions/questions.html',
              controller: 'routes.borPreFunnel.questionsCtrl as questionsCtrl'
            },
            'addQuestion@borPreFunnel.questions': {
              templateUrl: paths.partials + '/routes/bor/borPreFunnel/questions/addquestion.html'
            }
          }
        })
        .state('borPreFunnel.details', {
          url: '/details',
          controller: 'routes.borPreFunnel.detailsCtrl as detailsCtrl',
          templateUrl: paths.partials + '/routes/bor/borPreFunnel/details/details.html'
        })
        .state('borPreFunnel.account', {
          url: '/account?:source',
          abstract: true,
          templateUrl: paths.partials + '/routes/user/account/account.html'
        })
        .state('borPreFunnel.account.create', {
          url: '/create',
          templateUrl: paths.partials + '/routes/user/account/create.html',
          controller: 'user.login.controller',
          data: {
            successState: 'borPreFunnel.complete',
            errorState: 'borPreFunnel.account.login'
          }
        })
        .state('borPreFunnel.account.login', {
          url: '/login',
          templateUrl: paths.partials + '/routes/user/account/login.html',
          controller: 'user.login.controller',
          data: {
            successState: 'borPreFunnel.complete',
            errorState: 'borPreFunnel.account.login'
          }
        })
        .state('borPreFunnel.complete', {
          controller: 'routes.borPreFunnel.complete.controller'
        });
    }
  ]);
(function () {

  /**
   *
   * @param {ui.router.state.$state} $state
   * @param {user.model} baseUser
   * @constructor
   */
  function Ctrl($state, $stateParams, baseUser) {
    this.render = true;
  }

  Ctrl.$inject = ['$state', '$stateParams', 'baseUser'];

  angular.module('routes.borPreFunnel')
    .controller('routes.borPreFunnel.controller', Ctrl);
}());
(function () {

    /**
     * @name routes.borPreFunnel.service
     */
    function borPreFunnelService(session, translateService) {
      var self = this;
      this.allQuestions = [];
      this.selectedQuestions = [];

      /**
       * Gets the list of questions from contentful given the translate key
       * @param translateArrayKey
       * @returns {*}
       */
      this.getQuestions = function (translateArrayKey) {
        return translateService.translate(translateArrayKey)
          .then(function (response) {
            self.allQuestions = response;
            return response;
          });
      };

      /**
       * Gets the selected questions of the question array
       * @returns {*}
       */
      this.getSelectedQuestions = function () {
        if (this.selectedQuestions.length === 0) {
          this.selectedQuestions = session.get('selectedQuestions') || [];
        }
        return this.selectedQuestions;
      };

      /**
       * Save selected questions
       * @param selectedQuestions
       */
      this.saveSelectedQuestions = function (selectedQuestions) {
        self.selectedQuestions = [];

        self.selectedQuestions = _.filter(selectedQuestions, function (q) {
          return !!_.findWhere(self.allQuestions, {key: q.key});
        });

        session.set('selectedQuestions', self.selectedQuestions);
      };


      this.getCustomQuestion = function () {
        return this.customQuestion || session.get('customQuestion');
      };

      this.saveCustomQuestion = function (question) {
        this.customQuestion = question;
        if (question && question.length > 0) {
          session.set('customQuestion', question);
        }
      };
    }

    borPreFunnelService.$inject = ['session', 'translate.service'];

    angular.module('routes.borPreFunnel')
      .service('borPreFunnel.service', borPreFunnelService);
  }()
);
(function () {

  /**
   * @param {ui.router.state.$state} $state
   * @param {*} $stateParams
   * @param {ng.$http} $http
   * @param {config} config
   * @param {notification.service} notificationService
   * @param {routes.borPreFunnel.service} borPreFunnelService
   * @param {routes.borPreFunnel.config} borPreFunnelConfig
   * @param {logger} logger
   * @param {userModel} userModel
   */
  function Ctrl($state, $stateParams, $http, config, notificationService, borPreFunnelService, borPreFunnelConfig, logger, userModel) {
    var type = $stateParams.type;
    var questions = borPreFunnelService.getSelectedQuestions();
    var updatedQuestions = _.reject(questions, function (question) {
      return question.key === 'custom';
    });

    var customQuestion = borPreFunnelService.getCustomQuestion();

    // Add custom question if user added one
    if (customQuestion && customQuestion.length > 0) {
      updatedQuestions.push({
        key: 'custom',
        text: customQuestion
      });
    }

    //Add source to each question
    _.each(updatedQuestions, function (question) {
      question.source = type;
    });

    $http.post(config.paths.services + '/support/questions', {
        questions: updatedQuestions,
        sendEmail: true,
        recipient: borPreFunnelConfig.emailRecipient[type]
      })
      .catch(function () {
        logger.error('Unable to send broker of record questions!');
      })
      .finally(function () {
        notificationService.clearQueue('bor');
        notificationService.enqueue('bor', { userId: userModel.getId(), messageType: borPreFunnelConfig.notificationKey[type], payload: {} });
        $state.go('bor.intro', { source: borPreFunnelConfig.borSource[type] });
      });
  }

  Ctrl.$inject = ['$state', '$stateParams', '$http', 'config', 'notification.service', 'borPreFunnel.service', 'routes.borPreFunnel.config', 'logger', 'baseUser'];

  angular.module('routes.borPreFunnel')
    .controller('routes.borPreFunnel.complete.controller', Ctrl);
}());
(function(){

  /**
   * @name routes.bor.carrierCtrl
   * @param {search.carriers} carrierSearch
   * @param {routes.bor.model} borModel
   * @constructor
   */
  function Ctrl(carrierSearch, borModel){
    this.render = false;

    /**
     * @name routes.bor.carrierCtrl.fetchCarriers
     * @methodOf routes.bor.carrierCtrl
     * @returns {Promise<Carrier[]>}
     */
    this.fetchCarriers = function(){
      return carrierSearch.get(borModel.get('geo'), borModel.get('onExchange'), (new Date()).getFullYear())
        .then(this.setCarriers.bind(this));
    };

    /**
     * @name routes.bor.carrierCtrl.setCarriers
     * @methodOf routes.bor.carrierCtrl
     * @param {Carrier[]} carriers
     * @returns {Carrier[]}
     */
    this.setCarriers = function(carriers){
      carriers = carriers.sort(function(a, b){ return a.name.localeCompare(b.name); });

      this.carriers = carriers;

      // match the stored carrier in the new list of carriers for object equality
      if (borModel.get('carrier')){
        var match = _.findWhere(carriers, { id: borModel.get('carrier.id') });
        borModel.set('carrier', match || null);
      }

      this.render = true;
      return carriers;
    };

    this.fetchCarriers();
  }
  Ctrl.$inject = ['search.carriers', 'routes.bor.model'];

  angular.module('routes.bor')
    .controller('routes.bor.carrierCtrl', Ctrl);
}());
(function(){

  /**
   * @name routes.bor.coverageCtrl
   * @constructor
   */
  function Ctrl(){
    //var planYear = borModel.get('plan.planYear');
    //var coverageStart = borModel.get('coverageStart');
    //
    //if (coverageStart){
    //  if ((new Date(coverageStart)).getFullYear() !== planYear){
    //    borModel.set('coverageStart', null);
    //  }
    //}

    var today = new Date();
    //var minDate = new Date(planYear, 0);
    //var maxDate = new Date(planYear, 11);

    //if (maxDate.getTime() > today.getTime()){
    //  maxDate = today;
    //}

    //this.dateRange = [minDate, maxDate];

    this.dateRange = [
      new Date(today.getFullYear() - 3, 0),
      new Date(today.getFullYear(), today.getMonth() + 2)
    ];
  }
  Ctrl.$inject = [];

  angular.module('routes.bor')
    .controller('routes.bor.coverageCtrl', Ctrl);
}());
(function(){

  /**
   * @name routes.bor.eSignCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {routes.bor.model} borModel
   * @param {Member} PrimaryMember
   * @param {member.service} memberService
   * @param {application.service} applicationService
   * @param {plan.search} planSearch
   * @param {notification.service} notificationService
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($q, $state, borModel, PrimaryMember, memberService, applicationService, planSearch, notificationService, userModel){
    var self = this;
    var firstName = PrimaryMember.first_name;
    var lastName = PrimaryMember.last_name;
    this.primaryMember = PrimaryMember;
    this.signature = firstName + ' ' + lastName;
    this.pattern = new RegExp(firstName + ' +' + lastName, 'i');
    this.error = null;

    this.next = function(){
      borModel.set('eSignDate', new Date());
      this.complete()
        .then($state.goNext)
        .catch(function(err){
          self.error = err;
        });
    };

    this.complete = function(){
      self.error = null;
      var appId = '';

      // first find the last incomplete BoR application or create a new one
      return applicationService.query(userModel, { type: 'bor', is_complete: false })
        //.then(function(apps){
        //  if (!_.isArray(apps) || apps.length === 0) {
        //    return applicationService.save(userModel, { type: 'bor' });
        //  }
        //
        //  return apps[0];
        //})
        // update the app with inputs from the flow
        .then(function(apps){
          var plan = borModel.get('plan');
          var carrier = borModel.get('carrier');
          var geo = borModel.get('geo');
          planSearch.attachCarrier(plan, carrier);

          // save will call put if app_id is defined, otherwise it will post
          return applicationService.save(userModel, {
            app_id: _.get(apps, '0.app_id'),
            plan_id: plan.id,
            product_id: plan.id,
            carrier_id: carrier.id,
            carrier_policy_id: borModel.get('memberId') || null,
            premium: borModel.get('premium') || null,
            start_date: borModel.get('coverageStart') || null,
            zipcode: geo.zipcode,
            region: geo.region,
            app_json: {
              plan: plan
            },
            address: geo
          });
        })
        // associate the primary member to the app
        .then(function(app){
          appId = app.app_id;
          var member = _.extend({ status: 'coverage' }, PrimaryMember);
          return memberService.saveForApp(userModel, app.app_id, [member]);
        })
        // e-sign for that member
        .then(function(){ return applicationService.eSign(appId, [PrimaryMember.id]); })
        .then(function(){ return applicationService.submit(userModel, appId); })
        // set the application as complete
        .then(function(){ return applicationService.setActive(userModel, appId, 'bor'); })
        .then(function(){ return notificationService.postQueue('bor'); })
        .then(function(){ borModel.clear(); });
    };

  }
  Ctrl.$inject = ['$q', '$state', 'routes.bor.model', 'PrimaryMember', 'member.service', 'application.service', 'plan.search', 'notification.service', 'baseUser'];

  angular.module('routes.bor')
    .controller('routes.bor.eSignCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.bor.landing
   * @param {ui.router.state.$stateProvider} $stateProvider
   * @param {config} config
   */
  function Config($stateProvider, config) {
    var base = config.paths.partials + '/routes/bor/landing';
    $stateProvider
      .state('borLanding', {
        abstract: true,
        templateUrl: base + '/main.html',
        data: {
          scrollTop: true
        }
      })
      .state('borLanding.concierge', {
        url: '/health-concierge',
        controller: 'routes.bor.landingCtrl as landingCtrl',
        templateUrl: base + '/concierge/landing.html',
        resolve: {
          Questions: ['$state', 'borPreFunnel.service', function ($state, borPreFunnelService) {
            return borPreFunnelService.getQuestions('brokerOfRecord.concierge.questions')
              .then(function (response) {
                if (!response) {
                  $state.replace('home');
                }

                return response;
              });
          }]
        },
        data: {
          gridKey: 'health-concierge-grid',
          type: 'concierge',
          pageViewName: 'Health Concierge'
        }
      })
      .state('borLanding.tax', {
        url: '/tax-help',
        controller: 'routes.bor.landingCtrl as landingCtrl',
        templateUrl: base + '/tax/landing.html',
        resolve: {
          Questions: ['$state', 'borPreFunnel.service', function ($state, borPreFunnelService) {
            return borPreFunnelService.getQuestions('brokerOfRecord.taxHelp.questions')
              .then(function (response) {
                if (!response) {
                  $state.replace('home');
                }

                return response;
              });
          }]
        },
        data: {
          gridKey: 'tax-help-grid',
          type: 'taxHelp',
          pageViewName: 'Tax Help'
        }
      })
      .state('borLanding.marketing', {
        url: '/insurance-help/:type',
        controller: 'routes.bor.landing.marketingCtrl as marketingCtrl',
        templateUrl: base + '/marketing/landing.html',
        data: {
          pageViewName: 'Insurance Help'
        }
      });
  }

  Config.$inject = ['$stateProvider', 'config'];

  angular.module('routes.bor.landing', ['ui.router', 'config', 'content'])
    .config(Config);
}());
(function () {

  /**
   * @name routes.bor.landingCtrl
   * @param {ui.router.state.$state} $state
   * @param {content.service} contentService
   * @param {Array<Object>} Questions
   * @param {routes.borPreFunnel.service} borPreFunnelService
   * @param {services.tracking} trackingService
   */
  function Ctrl($state, Questions, borPreFunnelService, trackingService) {
    var stateData = $state.getData();
    this.questions = Questions;

    this.goToQuestions = function () {
      var question = _.findWhere(Questions, { key: this.questionKey });
      borPreFunnelService.saveSelectedQuestions([question]);

      // Logging landing page and question selected
      trackingService.mixpanelEvent(trackingService.propEnum.bor.landing.cta, {
        'Question Selected': question.text,
        'Landing Page': stateData.type
      });

      $state.go('borPreFunnel', {type: stateData.type});
    };

    trackingService.trackLP(stateData.pageViewName);
  }

  Ctrl.$inject = ['$state', 'Questions', 'borPreFunnel.service', 'services.tracking'];

  angular.module('routes.bor.landing')
    .controller('routes.bor.landingCtrl', Ctrl);
}());
/**
 * @namespace routes.borFunnel
 */
angular.module('routes.borFunnel', ['ui.router', 'user', 'common', 'search', 'visit', 'notification', 'session'])
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {

      var partials = paths.partials;
      var stepKeyPrefix = 'brokerOfRecord.steps.';

      $stateProvider
        .state('borFunnel', {
          url: '/add-insurance/{borsource:concierge|drive|dashboard|ad}',
          parent: 'sidebar',
          redirectTo: 'borFunnel.insuranceCompany',
          // drive is pointing to the wrong entry point, /add-insurance/concierge
          // which isn't being used currently
          // this checks if type: concierge and sends them to the ads funnel
          //transformRedirectParams: function(stateParams){
          //  if (stateParams.borsource === 'concierge'){
          //    stateParams.borsource = 'ad';
          //  }
          //
          //  return stateParams;
          //},
          views: {
            'main@sidebar': {
              templateUrl: partials + '/routes/bor/funnel/borFunnel.html',
              controller: 'routes.borFunnel.controller as bor'
            },
            'side@sidebar': {
              templateUrl: partials + '/components/sidebar/steps/default.html',
              controller: 'sidebar.steps.controller as stepsController'
            },
            'steps@borFunnel': {
              templateUrl: partials + '/components/sidebar/steps/mobile.html',
              controller: 'sidebar.steps.controller as stepsController'
            }
          },
          data: {
            scrollTop: true,
            invalidState: 'borFunnel.insuranceCompany',
            steps: [
              {
                name: 'borFunnel.insuranceCompany',
                key: stepKeyPrefix + 'carrier'
              },
              {
                name: 'borFunnel.identity',
                key: stepKeyPrefix + 'identity'
              },
              {
                name: 'borFunnel.esign',
                key: stepKeyPrefix + 'esign'
              },
              {
                name: 'borFunnel.account',
                key: stepKeyPrefix + 'account',
                isHidden: function (userModel) {
                  return userModel.isLoggedIn;
                }
              }
            ]
          }
        })
        .state('borFunnel.insuranceCompany', {
          url: '/insurance',
          controller: 'routes.borFunnel.insuranceCtrl as insuranceCtrl',
          templateUrl: paths.partials + '/routes/bor/funnel/insurance/insurance.html',
          data: {
            next: 'borFunnel.identity'
          }
        })
        .state('borFunnel.identity', {
          url: '/identity',
          controller: 'routes.borFunnel.identityCtrl as identityCtrl',
          templateUrl: paths.partials + '/routes/bor/funnel/identity/identity.html',
          data: {
            next: 'borFunnel.esign'
          }
        })
        .state('borFunnel.esign', {
          url: '/esign',
          data: {
            next: 'borFunnelcomplete',
            successState: 'borFunnelcomplete',
            errorState: 'borFunnel.esign',
            source: 'bor'
          },
          views: {
            '': {
              templateUrl: paths.partials + '/routes/bor/funnel/esign/e-sign.html',
              controller: 'routes.borFunnel.esignCtrl as esignCtrl'
            },
            'signup@borFunnel.esign': {
              templateUrl: paths.partials + '/routes/bor/funnel/account/signup.html'
            },
            'login@borFunnel.esign': {
              templateUrl: paths.partials + '/routes/bor/funnel/account/login.html'
            }
          }
        })
        .state('borFunnel.account', {
          templateUrl: paths.partials + '/routes/bor/funnel/account/account.html',
          controller: 'routes.borFunnel.accountCtrl as accountCtrl'
        })
        .state('borFunnel.account.create', {
          url: '/create',
          templateUrl: paths.partials + '/routes/bor/funnel/account/create.html'
        })
        .state('borFunnel.account.login', {
          url: '/login?user',
          templateUrl: paths.partials + '/routes/bor/funnel/account/login.html'
        })
        .state('borFunnel.account.reset', {
          url: '/reset',
          templateUrl: paths.partials + '/routes/bor/funnel/account/reset.html',
          data: {
            next: 'borFunnel.esign',
            successState: 'borFunnel.esign',
            errorState: 'borFunnel.account.reset'
          }
        })
        .state('borFunnelcomplete', {
          url: '/add-insurance/complete?{entry:concierge|drive|dashboard|ad}&:carrierName',
          parent: 'base',
          templateUrl: paths.partials + '/routes/bor/funnel/complete/complete.html',
          data: {
            scrollTop: true
          }
        })
        .state('borIntroCards', {
          parent: 'base',
          url: '/add-insurance/intro-cards',
          controller: 'routes.borFunnel.infoCardsCtrl as infoCardsCtrl',
          templateUrl: paths.partials + '/routes/bor/funnel/intro-cards/index.html',
          data: {
            next: 'borFunnel.insuranceCompany'
          }
        })
    }
  ]);

(function () {
  function Ctrl($state, userModel) {

    this.render = true;
    this.next = $state.goNext;

    //var allSteps = $state.getData().steps;
    //if (userModel.isLoggedIn) {
    //  //var accountStep = _.findWhere(allSteps, {key: "brokerOfRecord.steps.account"});
    //  //accountStep.isHidden = true;
    //  //
    //  //debugger;
    //
    //  this.steps = _.filter(allSteps, function (step) {
    //    return step.key != 'brokerOfRecord.steps.account';
    //  });
    //} else {
    //  this.steps = allSteps;
    //}
  }

  Ctrl.$inject = ['$state', 'baseUser'];

  angular.module('routes.bor')
    .controller('routes.borFunnel.controller', Ctrl);
}());
(function () {

    /**
     * @name routes.borFunnel.service
     */
    function borFunnelService($http, session, paths, trackingService, logger, notificationService) {
      var self = this;
      var sessionKey = 'borInfo';
      var notificationMap = {
        ad: 'BOR_insurance_help',
        drive: 'BOR_tax_help'
      };

      this.init = function () {
        session.set(sessionKey, {});
      };

      this.save = function (key, value) {
        var borInfo = session.get(sessionKey);
        if (borInfo) {
          borInfo[key] = value;
        }
        session.set(sessionKey, borInfo);
      };

      this.clear = function () {
        session.remove(sessionKey);
      };

      this.set = function (key, value) {
        session.set(key, value);
      };

      this.get = function (key) {
        return session.get(key);
      };

      this.getBorInfo = function () {
        return session.get(sessionKey);
      };


      this.postInfo = function (userModel, created) {
        var borInfo = this.getBorInfo();

        if (!borInfo) {
          return;
        }

        var carrierInfo = borInfo.carrierInfo;
        var geo = angular.copy(borInfo.location);
        geo.stateCode = geo.state;
        geo.countyFips = geo.county_fips;
        var params =
        {
          "member": {
            "id": borInfo.memberId,
            "first_name": borInfo.signatureFirstName,
            "last_name": borInfo.signatureLastName,
            "dob": borInfo.isoDOB,
            "ssn": borInfo.ssn
          },
          "insurance": {
            "source": borInfo.source,
            "carrier_brand_id": carrierInfo && carrierInfo.id,
            "carrier_brand_name": carrierInfo && carrierInfo.name,
            "insurance_member_id": borInfo.insuranceId
          },
          "geo": geo
        };

        return $http.post(paths.services + '/bor/submit', params)
          .then(function (response) {
            // Mixpanel log "purchase" event
            trackingService.mixpanelEvent(trackingService.propEnum.purchaseComplete, {'BOR': true});
            trackingService.setPeopleProp('BOR Complete', true);

            var source = response.data.source;
            var sharedNotifications = notificationService.getShared();
            var borNotificationType = notificationMap[source] ? notificationMap[source] : notificationMap.ad;

            // only show the drugs/doctors notification for new accounts
            if (created) {
              notificationService.post([sharedNotifications.drugs, sharedNotifications.doctors].concat({
                messageType: borNotificationType,
                payload: {}
              }), userModel.getId());
            }

            self.clear();

            return response;
          })
          .catch(function (err) {
            //Log error
            logger.error({
              err: err && err.message || err
            });
          });
      };
    }

    borFunnelService.$inject = ['$http', 'session', 'config.paths', 'services.tracking', 'logger', 'notification.service'];

    angular.module('routes.borFunnel')
      .service('borFunnel.service', borFunnelService);
  }()
);
//(function(){
//
//  /**
//   * @name routes.bor.specificCtrl
//   * @param {ui.router.state.$state} $state
//   * @param {routes.bor.model} borModel
//   * @constructor
//   */
//  function Ctrl($state, borModel){
//    if (!borModel.plan){
//      $state.replace('bor.intro');
//    }
//
//  }
//  Ctrl.$inject = ['$state', 'routes.bor.model'];
//
//  angular.module('routes.bor')
//    .controller('routes.bor.specificCtrl', Ctrl);
//}());
(function(){

  /**
   * @name routes.bor.sourceCtrl
   * @param {ui.router.state.$state} $state
   * @param {ng.$q} $q
   * @param {routes.bor.model} borModel
   * @param {search.geo} geoSearch
   * @constructor
   */
  function Ctrl($state, $q, borModel, geoSearch){
    this.form = null;
    this.borModel = borModel;
    this.zipcode = borModel.get('geo.zipcode', '');
    this.location = borModel.get('geo');
    this.onExchange = borModel.get('onExchange', null);
    this.invalidZip = true;

    this.onZipChange = function(){

      if (!this.zipcode){
        return;
      }

      var self = this;
      this.invalidZip = true;
      this.locations = null;
      this.location = null;
      this.setZipExists();

      geoSearch.getByZip(this.zipcode)
        .then(function(locations){

          if (!locations.length){
            return $q.reject('Invalid zip code');
          }

          self.invalidZip = false;

          if (locations.length === 1){
            self.setGeo(locations[0]);
          }

          else {
            self.locations = locations;
          }
        })
        .catch(function(err){
          self.invalidZip = true;
        })
        .finally(function(){
          self.setZipExists(!self.invalidZip);
        });
    };

    this.setZipExists = function(bool){
      var validityFn = _.get(this, 'form.zipcode.$setValidity', angular.noop);
      validityFn('zip-exists', bool);
    };

    this.setGeo = function(geo){
      borModel.set('geo', geo);
    };

    this.sources = [
      {
        id: 0,
        text: 'Healthcare.gov',
        value: true
      },
      {
        id: 1,
        text: 'My state\'s exchange',
        value: true
      },
      {
        id: 2,
        text: 'A different website',
        value: null
      },
      {
        id: 3,
        text: 'Insurance broker',
        value: null
      },
      {
        id: 4,
        text: 'Other',
        value: null
      }
    ];

    this.source = _.findWhere(this.sources, { id: borModel.get('source.id', null) }) || null;

    this.onSourceChange = function(){
      borModel.set('source', this.source);
      borModel.set('onExchange', this.source && this.source.value === true);
    };

    this.showSubsidy = function(){
      return !!this.source && this.source.value === null;
    };
  }
  Ctrl.$inject = ['$state', '$q', 'routes.bor.model', 'search.geo'];

  angular.module('routes.bor')
    .controller('routes.bor.sourceCtrl', Ctrl);
}());
(function(){

  /**
   * @name routes.bor.planCtrl
   * @param {ui.router.state.$state} $state
   * @param {routes.bor.model} borModel
   * @param {HealthPlan[]} plans
   * @param {plan.search} planSearch
   * @constructor
   */
  function Ctrl($state, borModel, plans, planSearch){
    if (!plans.length){
      return $state.replace('bor.support');
    }

    var thisYear = (new Date()).getFullYear();

    this.plans = _.chain(plans)
      .filter(function(plan){
        return plan.planYear === thisYear;
      })
      .uniq(false, function(plan){
        return plan.name;
      })
      .sortBy('name')
      .value();

    this.plan = _.findWhere(this.plans, { id: borModel.get('plan.id') }) || null;

    this.onPlanChange = function(){
      borModel.set('plan', this.plan);
    };

    this.next = function(){
      planSearch.getById(this.plan.id, true)
        .then(function(plan){
          borModel.set('plan', plan);
          return $state.goNext();
        })
        .catch(function(err){
          console.error(err);
        });
    };

    this.render = true;
  }
  Ctrl.$inject = ['$state', 'routes.bor.model', 'plans', 'plan.search'];

  angular.module('routes.bor')
    .controller('routes.bor.planCtrl', Ctrl);
}());
angular.module('routes.buy')
  .controller('routes.buy.address.controller', [
    '$q',
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'application.service',
    'logger',
    'cart.service',
    function($q, $scope, $state, userModel, applicationModel, applicationService, logger, cartService){
      var self = this;
      self.address = applicationModel.getAddress();

      $scope.continue = goNext;
      $scope.onNoChange = goNext;
      $scope.onChange = function(){
        $scope.changed = true;
      };

      var dentalApp = cartService.getAppByType('dental');
      $scope.carrierName = (!!dentalApp ? _.get(dentalApp, 'plan.carrier') + ' and ' : '') + applicationModel.getPlan().carrier;

      $scope.getAddress = function(){
        return applicationModel.getAddress();
      };

      function goNext(){
        cartService.updateDisplayPrice(applicationModel.getPlan().mods.premiumMonth);
        cartService.saveAddress(self.address)
          .then(function(address){
            applicationModel.address = address;
            $state.go('^.applicants');
          })
          .catch(function(err){
            logger.error({
              err: err
            });
          });
      }
    }
  ]);
angular.module('routes.buy')
  .controller('routes.buy.applicants.controller', [
    '$q',
    '$scope',
    '$state',
    'logger',
    'baseHealthApp',
    'baseUser',
    'member.service',
    'cart.service',
    'plan.utils',
    'services.date',
    function ($q, $scope, $state, logger, applicationModel, userModel, memberService, cartService, planUtils, dateService) {
      var self = this;
      var cachedApplication = angular.copy(applicationModel);
      $scope.application = applicationModel.get();
      self.appMembers = memberService.sortAllMembers(applicationModel.getCoveredMembers());
      self.isComplete = _.every(self.appMembers, memberService.isComplete);

      $scope.render = true;
      var dentalApp = cartService.getAppByType('dental');
      $scope.carrierName = (!!dentalApp ? _.get(dentalApp, 'plan.carrier') + ' and ' : '') + $scope.application.plan.carrier;

      this.editMember = function (member) {
        $state.go('.member', {memberId: member.id});
      };

      $scope.$on('member-updated', function (event, member) {
        updateMemberIfInArray(self.appMembers, member);
      });

      function updateMemberIfInArray(array, member) {
        var index = _.findIndex(array, {id: member.id});
        if (index > -1) {
          array[index] = _.extend(array[index], member);
        }
      }

      this.next = function () {
        if (angular.equals(cachedApplication.getCoveredMembers(), applicationModel.getCoveredMembers())){
          return $scope.continue();
        }

        // Save updated information
        memberService.saveMembers(userModel, self.appMembers)
          .then(function (updatedMembers){
            _.each(updatedMembers, _.partial(updateMemberIfInArray, applicationModel.getCoveredMembers(), _));
            return applicationModel.setEffectiveAges();
          })
          .then(function(){
            if (!planUtils.isSameDetails(applicationModel, cachedApplication)) {
              $scope.changed = true;
            } else {
              $scope.continue();
            }
          })
          .catch(function (error) {
            $scope.$broadcast('submit-error');
          });
      };


      $scope.continue = function () {
        //var newPremium = applicationModel.getPlan().mods.premiumMonth && applicationModel.getPlan().mods.premiumMonth.toFixed(2);
        cartService.updateDisplayPrice(applicationModel.getPremium());
        $state.go('buy.billing');
      };
    }
  ]);

(function () {
  /**
   *
   * @param $scope
   * @param $state
   * @param $stateParams
   * @param userModel
   * @param memberService
   * @param dateService
   * @param applicationModel
   * @constructor
   */
  function Ctrl($scope, $state, $stateParams, userModel, memberService, dateService, applicationModel) {
    var self = this;
    this.render = false;

    // Get member and make a copy so user can cancel changes
    memberService.getById($stateParams.memberId)
      .then(function (member) {
        self.savedMember = member;
        $scope.member = angular.copy(member);
        self.render = true;
      });

    /**
     * Save member
     */
    this.save = function () {
      // Calculate age on start date
      dateService.getStartDateAge($scope.member.dob, applicationModel)
        .then(function (age) {
          $scope.member.age = age;

          if (!memberService.isValid($scope.member)) {
            $scope.member.invalid = true;
            return;
          }
          return memberService.saveMember(userModel, $scope.member);
        })
        .then(function (response) {
          if (response) {
            $scope.$emit('member-updated', response);
            $state.replace('^');
          }
        });
    };
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'baseUser', 'member.service', 'services.date', 'baseHealthApp'];

  angular.module('routes.buy')
    .controller('routes.buy.applicants.member.controller', Ctrl);
}());

angular.module('routes.buy')
  .controller('routes.buy.confirm.controller', [
    '$scope',
    '$state',
    'utils',
    'baseHealthApp',
    'cart.service',
    'dental.service',
    function($scope, $state, utils, applicationModel, cartService, dentalService){
      $scope.model = {};
      $scope.plan = applicationModel.getPlan();
      $scope.carrierKey = utils.toDash($scope.plan.carrier);

      $scope.next = function(){
        applicationModel.setStatus('eSign');
        $state.go('^.eSign');
      };

      $scope.$watch(function(){ return cartService.hasAppType('dental'); }, function(hasDental){
        $scope.hasDental = !!hasDental;

        if (hasDental){
          var dentalPlanId = _.get(cartService.getAppByType('dental'), 'plan.id');
          $scope.dentalDocsUrl = dentalService.getPlanDocumentsUrl(dentalPlanId);
        }
      });
    }
  ]);
angular.module('routes.buy')
  .controller('routes.buy.extras.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'application.service',
    'questions',
    function($scope, $state, applicationModel, applicationService, questions){


      if (!questions || !questions.length){
        applicationModel.setExtras({});
      }

      if ($state.is('buy.extras')){
        if (questions.length){
          $state.go('.question', { steps: '1' });
        }
        else {
          done().then(function(){
            $state.replace($state.current.data.nextState);
          });
        }
      }

      // save each time a question is done
      $scope.$on('questions-done', function(){
        done().then(function(){
          $state.go($state.current.data.nextState);
        });
      });

      function done(){
        return applicationService.postExtras(applicationModel, 'extras');
      }

    }
  ]);
angular.module('routes.buy')
  .controller('routes.buy.submitted.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'services.date',
    'cart.service',
    'services.share',
    '$filter',
    'application.service',
    'baseUser',
    function ($scope, $state, applicationModel, dateService, cartService, shareService, $filter, applicationService, userModel) {
      this.render = false;
      var self = this;

      applicationService.getActive(userModel, 'health')
        .then(function (ifp_app) {
          applicationModel.setFromDb(ifp_app);

          if (!applicationModel.isComplete()) {
            $state.replace('home');
            return;
          }

          var application = applicationModel.get();
          var startDate = dateService.fromIsoDate(applicationModel.start_date);
          var lifeEvent = applicationModel.qualifying_event || null;

          dateService.isOepAsync({onExchange: applicationModel.hasSubsidy(), state: applicationModel.getState()})
            .then(function (isOep) {
              $scope.isOpenEnrollment = isOep && !lifeEvent;
            });

          self.openPopup = shareService.openPopup;

          $scope.application = application;
          $scope.startMonth = startDate.getMonth();
          cartService.hide();
          $scope.dentalApp = cartService.getAppByType('dental');
          $scope.hasDental = !!$scope.dentalApp;

          if (lifeEvent) {
            var qeDate = applicationModel.getLifeEventDate();
            var expiryDate = new Date(qeDate);
            expiryDate.setDate(expiryDate.getDate() + 60);
            $scope.lifeEvent = {
              date: qeDate,
              id: lifeEvent
            };
            $scope.expiryDate = $filter('ordinalDate')(expiryDate, 'MMMM doo, yyyy');
          }

          self.render = true;
        });


      //if (!applicationModel.isComplete()) {
      //  $state.replace('home');
      //  return;
      //}
      //
      //var application = applicationModel.get();
      //var startDate = dateService.fromIsoDate(applicationModel.start_date);
      //var lifeEvent = applicationModel.qualifying_event || null;
      //
      //dateService.isOepAsync({onExchange: applicationModel.hasSubsidy(), state: applicationModel.getState()})
      //  .then(function (isOep) {
      //    $scope.isOpenEnrollment = isOep && !lifeEvent;
      //  });
      //
      //this.openPopup = shareService.openPopup;
      //
      //$scope.application = application;
      //$scope.startMonth = startDate.getMonth();
      //cartService.hide();
      //$scope.hasDental = cartService.hasAppType('dental');
      //
      //if (lifeEvent) {
      //  var qeDate = applicationModel.getLifeEventDate();
      //  var expiryDate = new Date(qeDate);
      //  expiryDate.setDate(expiryDate.getDate() + 60);
      //  $scope.lifeEvent = {
      //    date: qeDate,
      //    id: lifeEvent
      //  };
      //  $scope.expiryDate = $filter('ordinalDate')(expiryDate, 'MMMM doo, yyyy');
      //}
    }
  ]);
(function(){

  /**
   * @name routes.checkout.addressCtrl
   * @param {ui.router.state.$state} $state
   * @param {address.service} addressService
   * @param {user.model} userModel
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function AddressCtrl($state, addressService, userModel, CartApps){
    this.apps = CartApps;
    this.render = true;
    var self = this;

    var addressIds = _.uniq(_.pluck(CartApps, 'address_id'));
    if (addressIds.length > 1){
      console.log("Do some address reconciling");
    }

    // for now just take the first apps address
    this.address = CartApps[0].address;
    this.cache = angular.copy(this.address);
    this.keyLabels = {
      street: "Street Address",
      unit: "Unit/Apt",
      city: "City",
      county: "County",
      state: "State",
      zipcode: "Zip Code",
      phone_number: "Phone Number"
    };

    this.staticKeys = ['city', 'county', 'state', 'zipcode'];
    this.editKeys = ['street', 'unit', 'phone_number'];
    this.requiredKeys = _.without(this.staticKeys.concat(this.editKeys), 'unit');

    this.next = function(){
      var isValid = _.every(this.requiredKeys, function(key){
        return _.isString(this.address[key]) && this.address[key].length > 0;
      }, this);

      // do some error messaging here
      if (!isValid){
        console.log('invalid address');
        return;
      }

      // don't hit the server if nothing was changed
      if (angular.equals(this.cache, this.address)){
        return $state.goNext();
      }

      return addressService.put(userModel, this.address)
        .then(function(){
          $state.goNext();
        });
    };

  }
  AddressCtrl.$inject = ['$state', 'address.service', 'baseUser', 'CartApps'];

  angular.module('routes.checkout')
    .controller('routes.checkout.addressCtrl', AddressCtrl);
}());

(function(){

  /**
   * @name routes.checkout.billingCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {services.date} dateService
   * @param {address.service} addressService
   * @param {application.service} applicationService
   * @param {billing.service} billingService
   * @param {cart.service} cartService
   * @param {logger} logger
   * @param {user.model} userModel
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function BillingCtrl($q, $state, dateService, addressService, applicationService, billingService, cartService, logger, userModel, CartApps, $scope, geoService){
    var self = this;
    var lock = false;
    var fields = {
      credit: ['card_number', 'expiration_date', 'name_on_card', 'security_code'],
      debit: ['account_number', 'routing_number']
    };
    var billingState = 'checkout.billing';
    this.apps = CartApps;

    // TODO: when this flow supports multiple apps, if there are different billing objects assigned to each app, reconcile
    if (_.uniq(_.pluck(CartApps, 'billing_id')).length > 1){
      console.log('Various billing ids');
    }

    cartService.show();
    this.app = CartApps[0];
    // for debit view
    $scope.render = true;
    $scope.billingType = "cc_preferred";
    this.acceptsCredit = $scope.acceptsCredit = [_.get(this.app, 'app_json.plan.carrier')];
    this.acceptsAch = $scope.acceptsAch = [_.get(this.app, 'app_json.plan.carrier')];
    $scope.model = {};
    $scope.forms = {};

    this.debitInfo = $scope.model;

    $scope.submitDebit = function(){
      var debitForm = $scope.forms.debit;
      if (!debitForm || !debitForm.$valid){
        return false;
      }

      self.cleanFields('credit');
      //prep billing object for submit to billing service
      _.extend(self.billing, {
        type:'debit',
        address_id: self.app.address_id,
        account_number : self.debitInfo.account_number,
        routing_number : self.debitInfo.routing_number
      })
      return self.submit();
    };

    this.savedBilling = this.app.billing;
    this.hasInitialBilling = !_.isEmpty(this.savedBilling);
    this.billing = angular.copy(this.savedBilling) || {};
    this.savedAddress = this.billing.address;
    this.address = angular.copy(this.savedAddress) || {};
    this.preferredType = _.get(this.billing, 'type', 'credit'); //TODO: implement debit
    this.member = applicationService.getUniqueMembers(CartApps)[0];

    // todo: this is defaulted to the first of the next month for now
    var now = new Date();
    this.startDate = new Date(now.getFullYear(), now.getMonth() + 1);
    this.expDateRange = [this.startDate, new Date(this.startDate.getFullYear() + 20, 11, 31)];

    this.isPriAndBillEqual = function(){
      return angular.equals(this.address, this.app.address)
    }

    this.showPress = function(){
      return $state.current.name !== 'checkout.billing.debit'
    }

    this.fillToggle = false;

    this.fillAddress = function(){
      if (this.fillToggle) {
        this.address = angular.copy(this.app.address);
        this.billing.name_on_card = this.member.first_name + ' ' + this.member.last_name;
        // watch on the address object to uncheck sameAddress box if user edits address
        this.unwatchAddrChanges = $scope.$watch(function(){return self.address}, function(nVal, oVal){
          if(nVal!==oVal){
            self.fillToggle = false;
            self.unwatchAddrChanges();
          }
        },true)
      } else {
        this.address = {};
      }
    };

    this.submitCredit = function(){
      if (!this.creditForm || !this.creditForm.$valid){
        return false;
      }

      this.cleanFields('debit');
      this.billing.type = 'credit';
      this.billing.expiration_date = dateService.toIsoDate(this.billing.expiration_date);

      return $q.when(angular.equals(this.address, this.savedAddress))
      .then(function(isSameAddress){
         // send the old address id through
         if(isSameAddress){
           return { id: self.address.id };
         }
         // if the zipcode they submitted is different than what was saved to the app
         // fetch a new geo object to get a new address_id
         if(self.address.zipcode != _.get(self.savedBilling, 'address.zipcode')){
           return geoService.getByZip(self.address.zipcode)
                 .then(
                   function(zipInfoList){
                     // possible data inconsistency when zipInfoList.length > 1
                     return _.extend({}, self.address, zipInfoList[0]);
                 })
                 .then(function(addressInfo){
                   return addressService.post(userModel, _.omit(addressInfo, ['id']));
                 });
         }
         // address has changed, get a new address_id
         return $q.when(_.extend({}, self.savedBilling.address, self.address))
                   .then(function(addressInfo){
                     return addressService.post(userModel, _.omit(addressInfo, ['id']));
                   })
       })
      // associate the address with the billing model
      .then(function(address){
        self.billing.address = address;
        self.billing.address_id = address.id;
        return self.submit();
      });
    };

    this.submit = function(){
      return $q.when(angular.equals(self.billing, self.savedBilling))
        .then(function(isSameBilling){
          if (isSameBilling){
            // billing post only returns the { id } of the billing row created so mimic that here
            return { id: self.billing.id };
          }

          return billingService.postForApp(self.app.app_id, self.billing);
        })
        // associate each app with this billing information
        .then(function(billing/** @type {{ id: number }} **/){
          _.extend(self.billing, { id: billing.id }); // get the fresh db model w/ id if posted
          // if no billing ids have changed, don't hit the server
          if (_.every(CartApps, function(app){ return app.billing_id === billing.id; })){
            return true;
          }

          return $q.all(_.map(CartApps, function(app){
            return billingService.putForApp(app.app_id, billing.id);
          }));
        })
        .then(function(){
          // update in memory
          _.each(CartApps, function(app){
            app.billing = self.billing;
            app.billing_id = self.billing.id;
          });

          return $state.goNext();
        })
        .catch(function(err){
          console.log(err);
          var message = err && err.data && err.data.message || 'Error submitting billing information';
          lock = false;

          if (message === 'Must only use a test bank account number when making transfers or debits in test mode'){
            self.serverError = 'Please enter a valid account number';
          }
          else {
            self.serverError = message;
          }


          logger
            .error({
              message: message,
              stack: err,
              userOid: userModel.getId()
            });
        });
    };

    // null out other fields to avoid admin portal confusion
    this.cleanFields = function(type){
      return _.each(fields[type], function(key){
        delete this.billing[key];
      }, this);
    };

    this.changeBilling = function(){
      this.billing = {};
      this.address = {};
      $state.replace(billingState + '.' + this.preferredType);
    };


    // if there's already saved billing information, just show what is saved
    if (this.savedBilling && !$state.is(billingState)){
      $state.replace(billingState)
        .then(_.bind(function(){
          this.render = true;
        }, this));
    }
    // if there isn't billing info, go to the preferred type
    else if (!this.savedBilling && $state.is(billingState)){
      $state.replace(billingState + '.' + this.preferredType)
        .then(_.bind(function(){
          this.render = true;
        }, this));
    }
    else {
      this.render = true;
    }
  }
  BillingCtrl.$inject = ['$q', '$state', 'services.date', 'address.service', 'application.service', 'billing.service', 'cart.service', 'logger', 'baseUser', 'CartApps', '$scope', 'search.geo'];

  angular.module('routes.checkout')
    .controller('routes.checkout.billingCtrl', BillingCtrl);
}());

(function(){

  /**
   * @name routes.checkout.completeCtrl
   * @param {services.date} dateService
   * @param {cart.service} cartService
   * @param {ifp_app[]} CartApps
   * @param {bor.service} borService
   * @constructor
   */
  function CompleteCtrl(dateService, cartService, CartApps, borService){
    var self = this;
    this.apps = CartApps;
    this.render = false;
    this.hasBor = false;
    this.appTypes = _.pluck(CartApps, 'type');
    this.startDate = dateService.fromIsoDate(CartApps[0].start_date);

    cartService.clearApps();
    cartService.hide();
    borService.hasGrantedBor()
      .then(function(hasBor){
        self.hasBor = hasBor;
        self.render = true;
      });

  }
  CompleteCtrl.$inject = ['services.date', 'cart.service', 'CartApps', 'bor.service'];

  angular.module('routes.checkout')
    .controller('routes.checkout.completeCtrl', CompleteCtrl);
}());
(function(){

  /**
   * @name routes.checkout.legalCtrl
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function LegalCtrl(CartApps){
    var billing = CartApps[0].billing;
    this.billingType = billing.type;
    this.last4 = (billing.type === 'credit' ? billing.card_number : billing.account_number).slice(-4);
  }
  LegalCtrl.$inject = ['CartApps'];

  angular.module('routes.checkout')
    .controller('routes.checkout.legalCtrl', LegalCtrl);
}());
(function(){

  /**
   * @name routes.checkout.eSignCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {services.date} dateService
   * @param {services.tracking} trackingService
   * @param {application.service} applicationService
   * @param {cart.service} cartService
   * @param {user.model} userModel
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function ESignCtrl($q, $state, dateService, trackingService, applicationService, cartService, userModel, CartApps){
    var loggingObject;
    this.members = applicationService.getUniqueMembers(CartApps);
    this.signingMembers = _.filter(this.members, function(member){
      return member.age > 17;
    });
    this.signatures = _.map(this.signingMembers, function(member){
      return {
        first: member.first_name,
        last: member.last_name,
        firstValue: '',
        lastValue: ''
      };
    });

    this.submit = function(){

      // create an esign request for all applications in cart
      var requests = _.map(CartApps, function(cartApp){

        var memberIds = _.chain(cartApp.members)
          // all member ids for the app
          .pluck(['id'])
          // find all members that esigned
          .filter(function(memberId){
            return !!_.findWhere(this.signingMembers, { id: memberId });
          }, this)
          .value();

        return applicationService.eSign(cartApp.app_id, memberIds);
      }, this);

      return $q.all(requests)
        .then(function(){
          var billing_id = CartApps[0].billing_id;
          loggingObject = cartService.getTrackingPayload();

          // TODO: this works fine for just dental, but need to set up effective date logic in cart
          return cartService.purchase(_.pluck(CartApps, 'app_id'), billing_id, dateService.toIsoDate(dateService.getNextMonth()));
        })
        .then(function(){
          if (loggingObject) {
            trackingService.mixpanelEvent(trackingService.propEnum.purchaseComplete, loggingObject);

            if (loggingObject.Dental) {
              trackingService.setPeopleProp(trackingService.propEnum.dentalPurchased, true);
            }
          }

          return $state.goNext();
        })
        .catch(function(err){
          console.error(err);
        });
    };

    this.render = true;
  }
  ESignCtrl.$inject = ['$q', '$state', 'services.date', 'services.tracking', 'application.service', 'cart.service', 'baseUser', 'CartApps'];

  angular.module('routes.checkout')
    .controller('routes.checkout.eSignCtrl', ESignCtrl);
}());
(function(){

  /**
   * @name routes.checkout.membersCtrl
   * @param {ui.router.state.$state} $state
   * @param {member.service} memberService
   * @param {application.service} applicationService
   * @param {user.model} userModel
   * @param {ifp_app[]} CartApps
   * @constructor
   */
  function MembersCtrl($state, memberService, applicationService, userModel, CartApps){
    this.apps = CartApps;
    this.members = applicationService.getUniqueMembers(CartApps);
    this.cache = angular.copy(this.members);
    this.isComplete = _.every(this.members, memberService.isComplete);
    this.render = false;

    if(this.isComplete){
      return $state.goNext();
    }
    
    this.render = true;
    this.next = function(){
      var updatedMembers = _.reject(this.members, function(member){
        var cache = _.findWhere(this.cache, { id: member.id });
        return angular.equals(cache, member);
      }, this);

      if (!updatedMembers.length){
        return $state.goNext();
      }

      return memberService.saveMembers(userModel, updatedMembers)
        .then(_.bind(this.updateAppMembers, this))
        .then(function(){
          return $state.goNext();
        });
    };

    this.updateAppMembers = function(updatedMembers){
      return _.each(updatedMembers, function(updatedMember){
        var member = _.findWhere(this.members, { id: updatedMember.id });
        _.extend(member, updatedMember);
      }, this);
    };

  }
  MembersCtrl.$inject = ['$state', 'member.service', 'application.service', 'baseUser', 'CartApps'];

  angular.module('routes.checkout')
    .controller('routes.checkout.membersCtrl', MembersCtrl);
}());

(function(){

  /** @namespace routes.dashboard.dental */

  function DashboardDentalConfig($stateProvider, config){
    var partials = config.paths.partials;
    var partialBase = partials + '/routes/dashboard/dental';
    var stateNameBase = 'dashboard.coverage.dental';

    $stateProvider
      .state(stateNameBase, {
        url: '/dental',
        views: {
          '': {
            templateUrl: partialBase + '/dental.html',
            controller: 'routes.dashboard.dental.controller as dentalCtrl'
          },
          'list@dashboard.coverage.dental': {
            templateUrl: partialBase + '/old-apps.html',
            //controller: 'dental.listCtrl as listCtrl'
          },
          'new-app@dashboard.coverage.dental': {
            templateUrl: partialBase + '/new-plan.html',
            //controller: 'application.newCtrl as newCtrl'
          }
        }
      })
      .state(stateNameBase + '.payment', {
        url: '/payment',
        templateUrl: partialBase + '/payment.html'
      })

      .state(stateNameBase + '.plan', {
        url: '/plan/:appId',
        templateUrl: partialBase + '/plan-details.html',
        controller: 'dental.detail.idCtrl as detailCtrl',
        resolve: {
          IfpApp: ['$stateParams', 'DentalApps', function($stateParams, DentalApps){
            return _.findWhere(DentalApps, { app_id: $stateParams.appId });
          }]
        }
      })

      .state(stateNameBase + '.plan.scenario', {
        url: '/scenarios',
        controller: 'routes.plan.scenario.controller',
        templateUrl: partials + '/components/plan/scenario-list.html'
      });
  }
  DashboardDentalConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.dashboard.dental', ['ui.router', 'config', 'application', 'plan', 'health'])
    .config(DashboardDentalConfig);
}());
(function () {

  /**
   * @namespace dashboard.dental
   */

  /**
   * @name dashboard.dental.controller
   * @param {dental.service} dentalService
   * @param {ifp_app[]} DentalApps
   */
  function Controller($state, dentalService, dateService, DentalApps) {

    var self = this;

    this.goToDental = function(form){
      if (form.$valid){
        $state.go('dental.location', { zipcode: self.zipcode });
      }
    };

    this.effectiveDate = dateService.getNextMonth();

    if (!DentalApps.length) {
      // If there are no dental apps at all, show message to find a dental plan
      this.noApps = true;
    } else {

      this.lastSubmittedDentalApp = _.find(DentalApps, function (app) {
        return app.submitted_on !== null && !app.cancel_date;
      });

      // Find latest app in progress
      this.latestInProgressDentalApp = _.find(DentalApps, function (app) {
        return app.submitted_on === null;
      });

      if (this.lastSubmittedDentalApp) {
        this.lastSubmittedDentalApp.status = this.lastSubmittedDentalApp.ifp_enroll_statuses[0];
        this.lastSubmittedDentalPlan = this.lastSubmittedDentalApp.app_json.plan;
        //dentalSearchResource.get({id: self.lastSubmittedDentalApp.plan_id}).$promise
        //  .then(function (response) {
        //    if (response && response.plan) {
        //      self.lastSubmittedDentalPlan = response.plan;
        //    }
        //  });
      }

      if (this.latestInProgressDentalApp) {
        this.latestInProgressDentalApp.status = this.latestInProgressDentalApp.ifp_enroll_statuses[0];
        this.latestInProgressDentalPlan = this.latestInProgressDentalApp.app_json.plan;
        //dentalSearchResource.get({id: self.latestInProgressDentalApp.plan_id}).$promise
        //  .then(function (response) {
        //    if (response && response.plan) {
        //      self.latestInProgressDentalPlan = response.plan;
        //    }
        //  });
      }
      var submittedApps = [];
      var inProgressApps = [];
      _.each(DentalApps, function (app) {
        if (app.cancel_date){
          return;
        }

        app.submitted_on ? submittedApps.push(app) : inProgressApps.push(app);
      });

      if (submittedApps.length > 0) {
        // Show latest submitted app in the left
        getPlanInfo(submittedApps[0])
          .then(function (response) {
            self.latestPlan = response;
          });

        // not showing this anymore
        //// Show in progress app on the side
        //if (inProgressApps.length > 0 && inProgressApps[0].plan_id) {
        //  getPlanInfo(inProgressApps[0])
        //    .then(function (response) {
        //      self.progressPlan = response;
        //    });
        //}

        // Show previous apps at the bottom
        var previousSubmittedApps = _.rest(submittedApps);
        if (previousSubmittedApps.length > 0) {
          this.previousSubmittedPlans = [];
          _.each(previousSubmittedApps, function (app) {
            getPlanInfo(app)
              .then(function (response) {
                self.previousSubmittedPlans.push(response);
              });
          })
        }

      } else if(inProgressApps[0].plan_id){
          getPlanInfo(inProgressApps[0])
          .then(function (response) {
            self.latestPlan = response;
          });
      }
    }

    function getPlanInfo(app) {
      return dentalService.getPlanDetails(app.plan_id)
        .then(function (response) {
          return {
            app_id: app.app_id,
            premium: app.premium,
            name: response.plan.name,
            carrier: response.plan.carrier,
            effectiveDate: app.start_date
          };
        });
    }
  }

  Controller.$inject = ['$state', 'dental.service', 'services.date', 'DentalApps'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.dental.controller', Controller);
}());

(function () {

  /**
   * @name dashboard.doctors.controller
   * @param {ui.router.state.$state} $state
   * @param {google.maps} googleMaps
   * @param {doctor.service} doctorService
   * @param {user.model} userModel
   * @constructor
   */
  function DoctorsController($state, googleMaps, doctorService, userModel) {
    var self = this;

    var stateData = $state.current.data || {};

    this.isPreview = !!stateData.previewModule;
    this.displayLimit = this.isPreview && 2 || 20;

    doctorService.getMergedForUser(userModel, null, 'health')
      .then(function (response) {
        self.doctors = _.pluck(response, 'details');
      });

    this.remove = function (doc) {
      doctorService.deleteForMember(userModel, userModel.getPrimaryId(), doc.id)
        .then(function () {
          self.doctors.splice(_.findIndex(self.doctors, { id: doc.id }), 1);
        });
    };

    self.getDirectionsUrl = function (doc) {
      return googleMaps.getDirectionsUrl(doctorService.doctorToAddress(doc));
    };

    //self.editGeo = function(){
    //  self.editingGeo = true;
    //};
    //
    //self.onPlaceChange = function(place){
    //  return setDoctorCount(place)
    //    .then(function(){
    //
    //      self.editingGeo = false;
    //    });
    //};
    //
    //function setDoctorCount(geo){
    //  self.geo = geo;
    //  self.geoString = googleMaps.getAddressString(geo);
    //  doctorService.saveSetting('geo', geo);
    //
    //  return doctorService.getStatsByZip(geo.zipcode)
    //    .then(function(stats){
    //      self.doctorCount = stats.providers;
    //    });
    //}
    //
    //doctorService.getGeo(userModel)
    //  .then(setDoctorCount);
  }

  DoctorsController.$inject = ['$state', 'google.maps', 'doctor.service', 'user.model'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.doctors.controller', DoctorsController);

}());
(function () {

  /**
   *
   * @param {ui.router.state.$state} $state
   * @param {user.model} userModel
   * @param {health.app} DrugHealthCtx
   * @param {drug.editor} drugEditor
   * @param {drug.service} drugService
   * @constructor
   */
  function DashboardDrugsController($state, userModel, DrugHealthCtx, drugEditor, drugService) {
    var self = this;
    this.isPreview = !!$state.getData().previewModule;
    this.displayLimit = this.isPreview && 2 || 20;
    this.render = false;

    /**
     * @type {MemberDrug[]}
     */
    this.drugs = [];

    drugService.getAllForUser(userModel)
      .then(function (response) {
        self.drugs = response;
        self.render = true;
      });

    /**
     * @type {boolean}
     */
    //this.hasHealthApp = applicationModel.isComplete();//!_.isEmpty(userDrugModel.getHealthApp());

    /**
     * @type {function}
     * @returns {string}
     */
    this.getDoseForm = drugEditor.getDoseForm;

    /**
     * @type {boolean}
     */
    //this[xSellKey] = userModel.getSetting(xSellKey) !== false;

    /**
     * @param {MemberDrug} drugModel
     */
    this.addPharmacy = function (drugModel) {
      var toState = 'dashboard.care.drugs.edit.';
      drugEditor.setDrug(drugModel);

      var drugJson = drugModel.drug_json || {};

      if (!drugJson.dose) {
        toState += 'dose';
      }
      else if (!drugJson.fillQty || !drugJson.durationDays) {
        toState += 'quantity';
      }
      else if (!drugJson.fillCount) {
        toState += 'refills';
      }
      else {
        toState += 'pharmacy';
      }

      $state.go(toState);
    };

    /**
     * @param {MemberDrug} drugModel
     */
    this.removeDrug = function (drugModel) {
      drugService.removeDrug(userModel, drugModel)
        .then(function (response) {
          if (response) {
            self.drugs = _.reject(self.drugs, function (d) {
              return d.drug_json.uuid === drugModel.drug_json.uuid;
            });
          }
        });
    };
  }

  DashboardDrugsController.$inject = ['$state', 'user.model', 'DrugHealthCtx', 'drug.editor', 'drug.service'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.drugs.controller', DashboardDrugsController);
}());
(function(){

  /** @namespace routes.dashboard.document */

  function DashboardDocumentConfig($stateProvider, config){
    var partials = config.paths.partials;
    var partialBase = partials + '/routes/dashboard/document';
    var stateNameBase = 'dashboard.coverage.document';

    $stateProvider
      .state(stateNameBase, {
        url: '/document',
        views: {
          '': {
            templateUrl: partialBase + '/document.html',
            controller: 'routes.dashboard.document.controller as documentCtrl'
          }
        }
      });
  }
  DashboardDocumentConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.dashboard.document', ['ui.router', 'config', 'ngFileUpload', 'document'])
    .config(DashboardDocumentConfig);
}());
(function () {

  /**
   * @name routes.dashboard.document.controller
   * @param {ng.$q} $q
   * @param {user.model} userModel
   * @param {*} Upload
   * @param {document.service} documentService
   * @param {config.service} configService
   * @param {services.tracking} trackingService
   * @param {logger} logger
   * @constructor
   */
  function Ctrl($q, userModel, Upload, documentService, configService, trackingService, logger) {
    var self = this;
    this.render = false;
    this.form = null;
    var primary = _.findWhere(userModel.activeHealth.members, { type: 'primary' });
    this.firstName = _.get(primary, 'first_name', '');

    // Get doc tags and see if anything needs to be displayed. Set logging to true on init of document controller
    getDocTags(true);

    /**
     * Get all document tags
     */
    function getDocTags(log) {
      return documentService
        .getDocTags({appId: userModel.activeHealth.app_id })
        .then(function (response) {
          self.numDocsRequired = _.reject(response, function (tag) {
            return tag.documents && tag.documents.length > 0;
          }).length;

          // Sort doc tags
          self.docTags = _.sortBy(response, function (tag) {
            return tag.id;
          });

          if (log) {
            trackingService.mixpanelEvent(trackingService.propEnum.taskList, {'# of unresolved tasks': self.numDocsRequired});
          }

          self.render = true;
        });
    }

    /**
     * Delete uploaded document
     * @param doc
     */
    this.deleteDoc = function (uploadedDoc, doc) {
      doc.loading = true;
      documentService.deleteDoc({docId: uploadedDoc.docId})
        .then(function (response) {
          if (response.deletedAt) {
            // On successful delete, update screen with latest doc tags
            getDocTags();
          }
        })
        .catch(function (response) {
          logger.error({
            message: response
          });
        })
        .finally(function () {
          doc.loading = false;
        });
    };

    /**
     * Upload file
     * @param file
     * @param doc
     */
    this.upload = function (file, doc) {
      if (!file) {
        return;
      }

      doc.loading = true;

      var key = userModel.getId() + '_' + (+new Date());
      var bucket = 'document.' + (configService.isProd() ? '' : 'dev-') + 'www.stridehealth.com';

      return documentService.getPolicy({fileName: key, fileType: file.type, fileSize: file.size, bucket: bucket})
        .then(function (data) {
          var payload = data.fields;
          payload['Content-Type'] = file.type;
          payload.key = key;

          // file must be last, aws ignores all fields after file
          payload.file = file;

          return Upload
            .upload({
              url: data.url,
              data: payload
            });
        })
        .then(function (response) {
          if (response.status !== 201) {
            return $q.reject(response);
          }

          return documentService.postDoc({
            appId: userModel.activeHealth.app_id,
            docType: file.type,
            docBucket: bucket,
            docKey: key,
            docName: file.name,
            tagItemId: doc.id
          });
        })
        .then(function () {
          trackingService.mixpanelEvent(trackingService.propEnum.docUploaded, {
            'Issue Name': doc.tag.name,
            'First Document': doc.documents ? doc.documents.length === 0 : true
          });

          // Successful post to server
          return getDocTags();
        })
        .catch(function (err) {
          logger.error(err);
        })
        .finally(function () {
          doc.loading = false;
        });
    };
  }

  Ctrl.$inject = ['$q', 'baseUser', 'Upload', 'document.service', 'config.service', 'services.tracking', 'logger'];

  angular.module('routes.dashboard.document')
    .controller('routes.dashboard.document.controller', Ctrl);
}());

//(function(){
//  /**
//   * @name dashboard.financeTracker
//   * @param {ui.router.state.$stateProvider} $stateProvider
//   * @param {config} config
//   * @constructor
//   */
//  function Config($stateProvider, config){
//    var pathBase = config.paths.partials + '/routes/dashboard/finance-tracker';
//    var componentBase = config.paths.partials + '/components/finance-tracker';
//
//    $stateProvider
//      .state('dashboard.financeTracker', {
//        url: '/finance-tracker',
//        templateUrl: pathBase + '/finance.html',
//        data: {
//          scrollTop: true,
//          authenticate: true
//        },
//        controller: 'routes.dashboard.financeTrackerCtrl as financeCtrl',
//        resolve: {
//          categories: ['financeTracker.service', function(financeService){
//            return financeService.getCategories();
//          }]
//        }
//      })
//
//      // Income routes
//      .state('dashboard.financeTracker.income', {
//        url: '/income',
//        template: '<div ui-view></div>',
//        redirectTo: 'dashboard.financeTracker.income.source',
//        data: {
//          doneState: 'dashboard.financeTracker'
//        }
//      })
//      .state('dashboard.financeTracker.income.source', {
//        url: '/source',
//        templateUrl: componentBase + '/income/source/source.html',
//        controller: 'financeTracker.income.sourceCtrl as sourceCtrl',
//        data: {
//          headline: 'finance.dashboard.income.source.headline',
//          nextState: 'dashboard.financeTracker.income.amount'
//        }
//      })
//      .state('dashboard.financeTracker.income.source.other', {
//        url: '/other',
//        templateUrl: componentBase + '/income/source/other.html'
//      })
//      .state('dashboard.financeTracker.income.amount', {
//        url: '/amount',
//        templateUrl: componentBase + '/amount/amount.html',
//        controller: 'financeTracker.amountCtrl as amountCtrl',
//        data: {
//          headline: 'finance.dashboard.income.amount.headline',
//          doneCtaText: 'finance.income.amount.doneCta',
//          moreCtaText: 'finance.income.amount.moreCta',
//          nextState: 'dashboard.financeTracker'
//        }
//      })
//
//      // Expense routes
//      .state('dashboard.financeTracker.expense', {
//        url: '/expense',
//        template: '<div ui-view></div>',
//        redirectTo: 'dashboard.financeTracker.expense.source',
//        data: {
//          doneState: 'dashboard.financeTracker'
//        }
//      })
//
//      .state('dashboard.financeTracker.expense.source', {
//        url: '/source',
//        templateUrl: componentBase + '/expense/source/source.html',
//        controller: 'financeTracker.expense.sourceCtrl as sourceCtrl',
//        data: {
//          headline: 'finance.dashboard.expense.source.headline',
//          nextState: 'dashboard.financeTracker.expense.amount'
//        }
//      })
//      .state('dashboard.financeTracker.expense.source.other', {
//        url: '/other',
//        templateUrl: componentBase + '/expense/source/other.html'
//      })
//      .state('dashboard.financeTracker.expense.amount', {
//        url: '/amount',
//        templateUrl: componentBase + '/amount/amount.html',
//        controller: 'financeTracker.amountCtrl as amountCtrl',
//        data: {
//          headline: 'finance.dashboard.expense.amount.headline',
//          doneCtaText: 'finance.expense.amount.doneCta',
//          moreCtaText: 'finance.expense.amount.moreCta',
//          nextState: 'dashboard.financeTracker'
//        }
//      })
//
//      // Tax routes
//      .state('dashboard.financeTracker.taxHelp', {
//        url: '/tax-help',
//        templateUrl: pathBase + '/tax-help.html'
//      });
//  }
//  Config.$inject = ['$stateProvider', 'config'];
//
//  angular.module('routes.dashboard.financeTracker', ['ui.router', 'config', 'common', 'financeTracker'])
//    .config(Config);
//}());

//(function(){
//
//  /**
//   * @name routes.dashboard.financeTrackerCtrl
//   * @param {ng.$rootScope.Scope} $scope
//   * @param {ui.router.state.$state} $state
//   * @param {services.date} dateService
//   * @param {financeTracker.service} financeService
//   * @param {services.tax} taxService
//   * @param {services.tracking} trackingService
//   * @param {financeTracker.txnBuilder} txnBuilder
//   * @param {Object} stateConfig
//   * @param {application.model} applicationModel
//   * @constructor
//   */
//  function Ctrl($scope, $state, dateService, financeService, taxService, trackingService, txnBuilder, stateConfig, applicationModel){
//    var self = this;
//    var weekIndex = 0; // used for tracking
//
//    this.render = false;
//    console.log("asdfasidfjaosdfjaspalk");
//    this.week = financeService.getLastWeek();
//    this.summary = {};
//    this.showTaxes = stateConfig && stateConfig.key === 'CA' && applicationModel.getFilingStatus() === 'single';
//
//    /**
//     * @param {TransactionSummary} data
//     */
//    this.processSummary = function(data){
//
//      self.summary = data;
//      self.usedThisWeek = data.income.period !== 0 || data.expenses.period !== 0;
//
//      var trackingData = {
//        'Week Index': weekIndex,
//        'Earnings Amount': data.earnings.period,
//        'Expense Amount': data.expenses.period,
//        'Income Amount': data.income.period
//      };
//
//      if (self.showTaxes){
//        var taxes = taxService.getTotalSeTax(
//          data.earnings.period,
//          applicationModel.getMembers(),
//          applicationModel.getFilingStatus(),
//          stateConfig.key,
//          null,
//          7
//        );
//
//        self.taxes = taxes.total;
//        trackingData['Estimated Tax Amount'] = taxes.total;
//      }
//
//      self.render = true;
//      trackingService.mixpanelEvent('Earnings: Dashboard: View', trackingData);
//    };
//
//    this.setSummary = function(){
//      return financeService
//        .getSummary(self.week[0], self.week[6])
//        .then(this.processSummary);
//    };
//
//
//    this.setSummary()
//      .then(bindSummaryUpdate);
//
//
//    function bindSummaryUpdate(){
//      $scope.$on('$stateChangeSuccess', function(event, toState){
//        if (toState.name === 'dashboard.financeTracker'){
//          self.setSummary();
//        }
//      });
//    }
//
//    /**
//     * @param {number} direction -1 or 1
//     */
//    this.setWeek = function(direction){
//      weekIndex += direction; //used for tracking
//      var targetThursday = new Date(this.week[3]);
//      targetThursday.setDate(targetThursday.getDate() + direction * 7);
//
//      this.week = dateService.getWeek(targetThursday, 1);
//      this.setSummary();
//    };
//
//    this.startTxn = function(type){
//      txnBuilder
//        .start(type)
//        .setValue('week', this.week);
//
//      $state.go('.' + type);
//    };
//
//    trackingService.setPeopleProps({ 'Earnings User': true });
//  }
//  Ctrl.$inject = ['$scope', '$state', 'services.date', 'financeTracker.service', 'services.tax', 'services.tracking', 'financeTracker.txnBuilder', 'stateConfig', 'baseHealthApp'];
//
//  angular.module('routes.dashboard.financeTracker')
//    .controller('routes.dashboard.financeTrackerCtrl', Ctrl);
//}());
(function(){

  /** @namespace routes.dashboard */

  function DashboardHealthConfig($stateProvider, config){
    var partials = config.paths.partials;
    var partialBase = partials + '/routes/dashboard/health';
    var stateNameBase = 'dashboard.coverage.health';

    $stateProvider
      .state(stateNameBase, {
        url: '/health',
        views: {
          '': {
            templateUrl: partialBase + '/health.html',
            controller: 'routes.dashboard.health.controller as healthCtrl'
          },
          'list@dashboard.coverage.health': {
            templateUrl: partialBase + '/list/old-apps.html',
            controller: 'routes.dashboard.health.listCtrl as listCtrl'
          },
          'new-app@dashboard.coverage.health': {
            templateUrl: partialBase + '/new-plan.html',
            controller: 'application.newCtrl as newCtrl'
          }
        }
      })

      .state(stateNameBase + '.payment', {
        url: '/payment',
        templateUrl: partialBase + '/payment.html'
      })

      .state(stateNameBase + '.activate', {
        url: '/activate/:appId',
        templateUrl: partialBase + '/activate/template.html',
        controller: 'routes.dashboard.health.activateCtrl as activateCtrl',
        resolve: {
          App: ['baseUser', 'application.service', '$stateParams', function(userModel, applicationService, $stateParams){
            return applicationService.get(userModel, $stateParams.appId);
          }]
        }
      })

      //.state(stateNameBase + '.delete', {
      //  url: '/delete/:appId',
      //  templateUrl: partialBase + '/delete/template.html',
      //  controller: 'routes.dashboard.health.deleteCtrl as deleteCtrl',
      //  resolve: {
      //    App: ['resources.application', '$stateParams', function(appResource, $stateParams){
      //      return appResource.get({ app_id: $stateParams.appId });
      //    }]
      //  }
      //})

      .state(stateNameBase + '.plan', {
        url: '/plan/:appId',
        templateUrl: partialBase + '/plan-details.html',
        controller: 'plan.detail.byIdCtrl as detailCtrl'
      })

      .state(stateNameBase + '.plan.scenario', {
        url: '/scenarios',
        controller: 'routes.plan.scenario.controller',
        templateUrl: partials + '/components/plan/scenario-list.html'
      });
  }
  DashboardHealthConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.dashboard.health', ['ui.router', 'config', 'application', 'plan', 'health'])
    .config(DashboardHealthConfig);
}());
(function () {

  /**
   * @namespace dashboard.health
   */

  /**
   * @name dashboard.health.controller
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.Scope} $scope
   * @param {application.model} currentApp
   * @param {{ current: EnrollmentPeriod, next: EnrollmentPeriod }} EnrollmentPeriods
   * @param {user.model} userModel
   * @param {dashboard.service} dashboardService
   * @param {application.service} applicationService
   * @param {broker_of_record} ActiveBor
   */
  function HealthController($state, $scope, currentApp, EnrollmentPeriods, userModel, dashboardService, applicationService, ActiveBor) {
    var self = this;

    if (!userModel.isLoggedIn) {
      return;
    }

    // why is this here? it was causing https://stridehealth.atlassian.net/browse/SH-1557 when the user had a completed app and a newly started app
    //applicationService.getWorking(userModel, 'health')
    //  .then(function (ifp_app) {
    //    userModel.activeHealth = ifp_app;
    //  });

    $scope.$watch(function () {
      return userModel.activeHealth;
    }, function (app /** @type {ifp_app} **/) {
      var statusId = _.get(userModel.activeHealthStatus, 'status_id');
      // don't show docs message for 'bor' apps
      self.docRequired = app.qualifying_event && app.type === 'health' && (statusId === 101 || statusId === 111);
      self.isBorLatest = dashboardService.isBorLatest(userModel.activeHealth, currentApp, ActiveBor);
    });

    this.isEmptyApp = function () {
      return !_.get(userModel.activeHealthStatus, 'isComplete') && !currentApp.members.length;
    };

    this.isWorkingActiveSame = function () {
      return _.get(currentApp, 'app_id') === _.get(userModel, 'activeHealth.app_id');
    };

    //this.progress = currentApp.progress.get();
    this.nextStartDate = EnrollmentPeriods.current.effective_date;
    this.applyByDate = EnrollmentPeriods.current.stride_end_date;
    this.activeBor = ActiveBor;

    this.startOver = function () {
      currentApp.startOver(userModel)
        .then(function () {
          $state.reload($state.current);
        });
    };

    applicationService.query(userModel, {types: 'health,bor', is_complete: true})
      .then(function (apps) {
        dashboardService.completedHealthApps = apps;
      });
  }

  HealthController.$inject = ['$state', '$scope', 'baseHealthApp', 'EnrollmentPeriods', 'baseUser', 'dashboard.service', 'application.service', 'ActiveBor'];


  angular.module('routes.dashboard')
    .controller('routes.dashboard.health.controller', HealthController);
}());
(function(){

  /** @namespace routes.dashboard */

  function DashboardVisitsConfig($stateProvider, config){
    var partials = config.paths.partials;
    var partialBase = partials + '/routes/dashboard/visits';
    var stateNameBase = 'dashboard.care.visits';

    $stateProvider
      .state(stateNameBase, {
        url: '/visits',
        templateUrl: partialBase + '/main.html',
        controller: 'routes.dashboard.visitsCtrl as visitsCtrl'
      })

      .state(stateNameBase + '.details', {
        url: '/details/:id',
        templateUrl: partials + '/components/visit/plan/detail/detail.html',
        controller: 'visit.plan.detailCtrl as detailCtrl',
        resolve: {
          Details: ['$stateParams', 'visit.plan.detail.service', function($stateParams, detailService){
            return detailService.getDetails($stateParams.id);
          }],
          HealthContext: ['Details', 'baseUser', function(details, userModel){
            var attachedHealthApp = _.get(details, 'plan.ifp_app');
            if (attachedHealthApp){
              return attachedHealthApp;
            }

            return userModel.fetchActiveHealth();
          }]
        }
      })
      .state(stateNameBase + '.details.doctor', {
        url: '/doctor/:providerId',
        templateUrl: partialBase + '/doctor/profile.html',
        controller: 'doctor.profileCtrl as profileCtrl'
      })
      .state(stateNameBase + '.details.edit', {
        url: '/edit',
        templateUrl: partials + '/components/visit/plan/edit/edit.html',
        controller: 'visit.plan.editCtrl as editCtrl'
      })
      //.state(stateNameBase + '.details.edit.doctor', {
      //  url: '/doctor',
      //
      //  templateUrl: partials + '/routes/visit/plan/doctor/main.html',
      //  controller: 'visit.plan.doctorCtrl as doctorCtrl',
      //  data: {
      //    next: stateNameBase + '.details.edit'
      //  }
      //})
      .state(stateNameBase + '.details.edit.services', {
        url: '/services',
        data: {
          next: '^'
        },
        views: {
          '': {
            templateUrl: partialBase + '/detail/services.html'
          },
          'list@dashboard.care.visits.details.edit.services': {
            templateUrl: partials + '/components/visit/plan/benefit/all/list.html',
            controller: 'visit.plan.benefit.allCtrl as allCtrl'
          }
        }
      })
      .state(stateNameBase + '.details.edit.doctor', {
        url: '/doctor',
        data: {
          termPlaceholder: 'visit.plan.doctor.termPlaceholder',
          geoPlaceholder: 'visit.plan.doctor.geoPlaceholder',
          next: stateNameBase + '.details.edit',
          settings: {
            inNetworkOnly: true
          }
        },
        resolve: {
          visitPlan: ['Details', function(details){
            return details.plan;
          }]
        },
        views: {
          '': {
            templateUrl: partials + '/routes/visit/plan/doctor/search.html',
            controller: 'visit.plan.doctorCtrl as doctorCtrl'
          },
          'search@dashboard.care.visits.details.edit.doctor': {
            templateUrl: partials + '/components/doctor/search/form.html',
            controller: 'visit.doctor.searchCtrl as searchCtrl'
          },
          'results@dashboard.care.visits.details.edit.doctor': {
            templateUrl: partials + '/components/doctor/search/results/list.html',
            controller: 'visit.plan.doctor.resultsCtrl as resultsCtrl'
          }
        }
      })
      .state(stateNameBase + '.details.edit.date', {
        url: '/date',
        templateUrl: partials + '/components/visit/plan/date/date.html',
        controller: 'visit.plan.dateCtrl as dateCtrl',
        data: {
          next: '^'
        }
      });
  }
  DashboardVisitsConfig.$inject = ['$stateProvider', 'config'];

  angular.module('routes.dashboard.visits', ['ui.router', 'config', 'visit'])
    .config(DashboardVisitsConfig);

}());
(function(){

  function Ctrl($state, $scope, visitDetailService, dashboardService, ActiveHealth){
    var self = this;
    var plan = _.get(ActiveHealth, 'app_json.plan');

    this.render = false;
    this.allowAdd = false;
    setDetails($state.current);

    $scope.$on('$stateChangeStart', function($event, toState){
      setDetails(toState);
    });

    function setDetails(toState){
      self.allowAdd = !!_.get(ActiveHealth, 'app_json.plan');

      if (toState.name === 'dashboard' || toState.name === 'dashboard.care.visits'){
        visitDetailService.getPlansWithDoctors(_.get(plan, 'networkId'))
          .then(function(details){
            self.details = _.each(details, function(detail){
              visitDetailService.setStatus(detail.plan);
            });

            dashboardService.hasVisitPlans = details && details.length > 0;
            self.render = true;
          })
          .catch(function(err){
            console.error(err);
          });
      }
    }
  }
  Ctrl.$inject = ['$state', '$scope', 'visit.plan.detail.service', 'dashboard.service', 'ActiveHealth'];

  angular.module('routes.dashboard.visits')
    .controller('routes.dashboard.visitsCtrl', Ctrl);
}());
(function () {

  /**
   *
   * @param $q
   * @param $state
   * @param $scope
   * @param {ifp_app} DentalApp
   * @param alertService
   * @param {services.tracking} trackingService
   * @param {plan.utils} planUtils
   * @param {dental.service} dentalService
   * @param {member.service} memberService
   * @param {Member[]} AllMembers
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($q, $state, $scope, DentalApp, alertService, trackingService, planUtils, dentalService, memberService, AllMembers, userModel) {
    var self = this;
    var nextState = 'dental.dentists';
    self.app = DentalApp;
    self.render = false;
    //self.allMembers = AllMembers;

    // Get Members
    $scope.members = {
      allMembers: [],
      appMembers: [],
      newMembers: []
    };
    memberService.getMemberSet(userModel, DentalApp.app_id)
      .then(function (response) {
        $scope.members.allMembers = response.allMembers;
        $scope.members.appMembers = _.filter(response.allMembers, function (member) {
          return !!_.findWhere(response.appMembers, {id: member.id});
        });
        self.render = true;
      });
    self.members = $scope.members;

    /**
     * When the user edits the member detail and saves, the member is saved to the server but the client needs to be
     * updated until the server does a get on members again
     */
    $scope.$on('member-updated', function (event, member) {
      // Find the member in the arrays and update
      var allIndex = _.findIndex(self.members.allMembers, {id: member.id});
      var appIndex = _.findIndex(self.members.appMembers, {id: member.id});
      self.members.allMembers[allIndex] = member;
      self.members.appMembers[appIndex] = member;
    });

    $scope.$on('updated-app-members', function (event, data) {
      $scope.members.appMembers = data.appMembers;
      self.updateBanner(data.appMembers,DentalApp.address.state);
     });


    /**
     * Save all members
     */
    this.goNext = function () {
      // Save app members
      var appMembers = _.chain($scope.members.allMembers)
        .filter(function (member) {
          return _.contains($scope.members.appMembers, member);
        })
        .map(function (member) {
          return _.extend({}, member, {status: 'coverage'});
        })
        .value();

      // $state.go('dental.dentists');
      setMembers(appMembers);
      memberService.saveForApp(userModel, DentalApp.app_id, appMembers)
       .then(setMembers)
       .then(function () {
      //    $scope.ob.setMaxProgress('doctors');
         $state.go('dental.dentists');
       })
       .catch(function (error) {

       });
    };

    self.applicants = _.filter(AllMembers, function(member){
     return !!_.some(DentalApp.members, { id: member.id });
    });

    if (!self.applicants.length){
     self.applicants = AllMembers.slice(0, 1);
    }

    // if there's only one, auto select and send to dentists
    // if (AllMembers.length === 1) {
    //  return $q.when(true)
    //    .then(function(){
    //      if (self.applicants.length === 1){
    //        return self.applicants;
    //      }
    //
    //      var members = _.map(AllMembers, function(member){ return _.extend({ status: 'coverage' }, member); });
    //      return memberService.saveForApp(userModel, DentalApp.app_id, members);
    //    })
    //    .then(setMembers)
    //    .then(function(){
    //      return $state.replace(nextState);
    //    });
    // }


    // Alert Banner
    this.updateBanner = function(applicants, state){
      var memberDemos = planUtils.getApplicantParams(applicants) || 'p27f';
      dentalService.getSortedPlans(state, memberDemos)
        .then(function (dentalPlans) {
          var wordNumbers = {
            0: 'no',
            1: 'one',
            2: 'two',
            3: 'three'
          };

          var numDentalPlans = dentalPlans.length;
          alertService.setMessage({
            key: numDentalPlans < 2 ? 'dental.alert.dentalPlan' : 'dental.alert.dentalPlans',
            model: {
              count: wordNumbers[numDentalPlans],
              plural: numDentalPlans === 1 ? '' : 's'
            }
          });
        });
    }

    //hmmm is this the right check? ---CODEREVIEW
    if(DentalApp.address.state){
      this.updateBanner(this.applicants, DentalApp.address.state)
    }

    // Any applicants selected check
    this.anySelected = function () {
     return this.applicants.length > 0;
    };

    this.done = function () {
     return memberService.getAppMembers(userModel, DentalApp.app_id)
       .then(setMembers)
       .then(function () {
         $state.go(nextState);
       });
    };

    this.getNumActiveDentalMembers = function () {
     return this.applicants.length;
    };

    function setMembers(members) {
     DentalApp.members = members;
     trackingService.setPeopleProp(trackingService.propEnum.dentalMembers, members.length);
    }

    $scope.$on('$destroy', alertService.clear);
  }

  Ctrl.$inject = ['$q', '$state', '$scope', 'DentalApp', 'services.alert', 'services.tracking', 'plan.utils', 'dental.service', 'member.service', 'AllMembers', 'baseUser'];

  angular.module('routes.dental')
    .controller('routes.dental.family.controller', Ctrl);
}());

(function () {

  /**
   *
   * @param $state
   * @param $scope
   * @param $http
   * @param $filter
   * @param paths
   * @param {ifp_app} DentalApp
   * @param {doctor.service} doctorService
   * @param planUtils
   * @param alertService
   * @param trackingService
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($state, $scope, $http, $filter, paths, DentalApp, doctorService,
                planUtils, alertService, trackingService, userModel) {
    var self = this;
    this.address = DentalApp.address;
    this.dentists = [];
    this.app_id = DentalApp.app_id;
    this.members = DentalApp.members || [];

    var messageKeyPrefix = 'profile.alert.';
    var filterNumber = $filter('number');

    // Alert banner on dentist main page
    var demos = planUtils.getApplicantParams(this.members);
    var key = messageKeyPrefix + this.members.length === 1 ? '' : 'Family';
    if (_.some(this.members, function (member) { return _.isNumber(member.age); })) {
      key = messageKeyPrefix + (self.members.length === 1 ? 'planCostStartAt' : 'planCostRangeFamily');
    }

    doctorService.getDetails(_.pluck(DentalApp.member_providers, 'provider_id'))
      .then(function(dentists){
        return doctorService.attachNetworkStats(dentists, self.address, 'dental');
      })
      .then(function(dentists){
        self.dentists = dentists;
        self.render = true;
      });

    $http.get(paths.partials + '/search/dental/plans/stats', {
      params: {
        state: self.address.state,
        demos: demos
      }
    })
    .then(function (response) {
      var stats = response.data;
      alertService.setMessage({
        key: key,
        model: {
          familySize: self.members.length,
          min: filterNumber(stats.minCost, 0),
          max: filterNumber(stats.maxCost, 0),
          avg: filterNumber(stats.medianCost, 0),
          state: self.address.state,
          city: self.address.city,
          age: self.members[0].age
        }
      });
    });


    $scope.$on('$destroy', alertService.clear);

    this.goToNext = function() {
      trackingService.setPeopleProp(trackingService.propEnum.dentists, this.dentists.length);
      $state.go('dental.plans');
    };
  }

  Ctrl.$inject = ['$state', '$scope', '$http', '$filter', 'config.paths', 'DentalApp',
    'doctor.service', 'plan.utils', 'services.alert', 'services.tracking', 'baseUser'];

  angular.module('routes.dental')
    .controller('routes.dental.dentists.controller', Ctrl);
}());

(function(){

  function DentalLandingCtrl($state){

    this.zipcode = '';

    this.go = function(form){
      if (form && form.$valid){
        $state.go('dental.location', { zipcode: this.zipcode });
      }
    };
  }
  DentalLandingCtrl.$inject = ['$state'];

  angular.module('routes.dental')
    .controller('routes.dental.landingCtrl', DentalLandingCtrl);
}());
(function () {

  /**
   */
  function Ctrl($scope, $state, $stateParams, alertService, DentalApp, addressService, userModel, doctorService) {
    var self = this;
    self.zipcode = $stateParams.zipcode || _.get(DentalApp, ['address', 'zipcode']) || '';
    self.render = $stateParams.zipcode ? false : true;
    // if(DentalApp.address.zipcode){
    //   self.zipLocations = [DentalApp.address];
    // }
    var initialZip = self.zipcode;
    this.multipleCounties = false;

    this.setMultipleCounties = function (setting) {
      this.multipleCounties = setting;
    };

    this.saveToDentalApp = function (key, val) {
      //persist to session, doctor-service.js looks at session storage
      doctorService.setGeo(val);
      //persist to server
      return addressService.saveForApp(userModel, DentalApp.app_id, val)
        .then(function (res) {
          //this does not seem like a good for managing state
          DentalApp[key] = res;
          DentalApp.address_id = res.id;
        });
    };

    this.saveAndGo = function (geo, replace) {
      // need to find out what is the unique key on county
      self.saveToDentalApp('address', geo)
        .then(function () {
          if (replace) {
            return $state.replace('dental.family');
          }
          $state.go('dental.family');
        })
    };

    $scope.changeHandler = function (list) {
      if ($stateParams.zipcode && list.length === 1) {
        return self.saveAndGo(list[0], true);
      }
      self.render = true;
      self.zipLocations = list
      // only toggle multipleCounties if zipcode is in the route
      if ($stateParams.zipcode) {
        self.setMultipleCounties(list.length > 1);
      }
    };

    $scope.goTo = function () {
      if (self.zipLocations.length > 1) {
        $state.go('dental.location', {zipcode: self.zipcode});
      } else {
        self.saveAndGo(self.zipLocations[0]);
      }
    };

    $scope.logCounty = function (geo) {
      self.saveAndGo(geo);
    }
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'services.alert', 'DentalApp', 'address.service', 'user.model', 'doctor.service'];

  angular.module('routes.dental')
    .controller('routes.dental.location.controller', Ctrl);
}());

(function () {

  /**
   * @name routes.profile.doctorCtrl
   * @param {ui.router.state.$state} $state
   * @param {google.maps} googleMaps
   * @param {doctor.service} doctorService
   * @param {user.model} userModel
   * @param {doctor.model} doctor
   * @param {Boolean} isSaved
   * @constructor
   */
  function Ctrl($state, googleMaps, doctorService, userModel, doctor, isSaved) {
    var self = this;
    this.doctor = doctor;
    this.center = null;
    this.isSaved = isSaved;

    this.setMap = function () {
      googleMaps.promise
        .then(function () {
          var position = self.doctor.position;

          if (position) {
            return {
              lat: position.latitude,
              lng: position.longitude
            };
          }

          return googleMaps.getAddress({
            address: googleMaps.getAddressString(doctorService.doctorToAddress(self.doctor))
          });
        })
        .then(function (position) {
          self.center = position;
          self.directionsUrl = googleMaps.getDirectionsUrl(position);
        });
    };

    this.saveDoctor = function () {
      doctorService.addForMember(userModel, userModel.getPrimaryId(), self.doctor.id)
        .then(function () {
          if (userModel.isLoggedIn) {
            $state.go('dashboard.care.doctors');
          } else {
            $state.go('doctor.account.create');
          }
        });
    };

    self.setMap();
  }

  Ctrl.$inject = ['$state', 'google.maps', 'doctor.service', 'baseUser', 'doctor', 'isSaved'];

  angular.module('routes.doctor')
    .controller('routes.doctor.profileCtrl', Ctrl);
}());
(function(){

  /**
   * @name doctor.landing.ctrl
   * @param {doctor.service} doctorService
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl(doctorService, trackingService){
    this.showResults = function(){
      return doctorService.didSearch && _.isArray(doctorService.searchResults);
    };

    trackingService.trackLP('Doctor Search');
  }
  Ctrl.$inject = ['doctor.service', 'services.tracking'];

  angular.module('routes.doctor')
    .controller('routes.doctor.landingCtrl', Ctrl);
}());
(function(){

  /**
   * @param {ui.router.state.$state} $state
   * @name routes.doctor.searchCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {doctor.service} doctorService
   * @param {user.model} userModel
   * @param {ifp_app} ActiveHealth
   * @constructor
   */
  function Ctrl($state, $scope, DoctorSearchModel, doctorService, userModel, ActiveHealth){
    var stateData = $state.current.data || {};
    var settings = _.extend({
      inNetworkOnly: doctorService.getSetting('inNetworkOnly') || false,
      patientNetwork: _.get(ActiveHealth, 'app_json.plan.networkId'),
      showClear: false
    }, stateData.settings || {});

    this.model = new DoctorSearchModel(settings);
    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));
  }
  Ctrl.$inject = ['$state', '$scope', 'doctor.search.model', 'doctor.service', 'baseUser', 'ActiveHealth'];

  angular.module('routes.doctor')
    .controller('routes.doctor.searchCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.getStarted.infoCtrl
   * @param {ui.router.state.$state} $state
   * @param {routes.getStarted.model} getStartedModel
   * @param {services.date} dateService
   * @param {services.tracking} trackingService
   * @param {ng.$filter} $filter
   */
  function Ctrl($state, getStartedModel, dateService, trackingService, $filter) {
    var self = this;
    this.model = getStartedModel.data;

    // allow for user to hit back and not have to refill data
    this.zipcode = _.get(getStartedModel, 'data.geo.zipcode', '');

    /**
     * @name routes.getStarted.infoCtrl.selectInsurance
     * @param hasInsurance
     */
    this.selectInsurance = function (hasInsurance) {
      this.model.hasInsurance = hasInsurance;
    };

    /**
     * @name routes.getStarted.infoCtrl.selectGender
     * @param gender
     */
    this.selectGender = function (gender) {
      this.model.gender = gender;
    };

    /**
     * @name routes.getStarted.infoCtrl.checkZip
     * @param locations
     */
    this.checkZip = function (locations) {
      this.validZip = locations.length > 0;
      this.zipMessage = this.validZip ? 'Searching in ' + locations[0].county : '';

      if (locations.length === 1) {
        this.model.geo = locations[0];
      }
    };

    /**
     * @name routes.getStarted.infoCtrl.getInsurance
     */
    this.getInsurance = function () {
      var prop = {};
      prop[trackingService.propEnum.getstarted.hasHealthInsurance] = false;
      trackingService.setPeopleProps(prop);
      $state.go('ob.location');
    };

    /**
     * @name routes.getStarted.infoCtrl.goToRecommended
     */
    this.goToRecommended = function () {
      var prop = {};
      prop[trackingService.propEnum.getstarted.age] = this.model.age;
      prop[trackingService.propEnum.getstarted.gender] = this.model.gender;
      prop[trackingService.propEnum.getstarted.hasHealthInsurance] = true;
      trackingService.setPeopleProps(prop);
      $state.go('^.services');
    };
  }

  Ctrl.$inject = ['$state', 'routes.getStarted.model', 'services.date', 'services.tracking', '$filter'];

  angular.module('routes.getStarted')
    .controller('routes.getStarted.infoCtrl', Ctrl);
}());
(function () {

  /**
   * @name getStarted.servicesCtrl
   * @param {ui.router.state.$state} $state
   * @param {routes.getStarted.model} getStartedModel
   * @param {VisitBenefitRecommendation[]} Recommendations
   * @param {VisitBenefitService[]} AllServices
   * @param {visit.plan.builder} visitPlanBuilder
   */
  function Ctrl($state, Recommendations, AllServices, visitPlanBuilder, trackingService) {
    var self = this;
    if (!_.isArray(AllServices) || AllServices.length === 0) {
      return $state.replace('^.info');
    }

    visitPlanBuilder.setValues({
      recommended_benefits: _.pluck(_.where(Recommendations, { strength: 'recommended' }), 'id'),
      suggested_benefits: _.pluck(_.where(Recommendations, { strength: 'suggested' }), 'id')
    });

    // all this junk for determining which services the user selected already
    var requested_benefits = visitPlanBuilder.getValue('requested_benefits');
    var additional_services = visitPlanBuilder.getValue('additional_services');
    var selectedRecommendations = Recommendations;
    var selectedServices = [];

    if (requested_benefits && requested_benefits.length){
      selectedRecommendations = _.filter(Recommendations, function(rec){
        return _.contains(requested_benefits, rec.id);
      });
    }

    var recommendedServices = _.filter(AllServices, function (service) {
      return !!_.findWhere(Recommendations, { serviceId: service.id });
    });

    var selectedRecommendedServices = _.filter(AllServices, function (service) {
      return !!_.findWhere(selectedRecommendations, { serviceId: service.id });
    });

    var otherServices = _.difference(AllServices, recommendedServices);
    if (additional_services && additional_services.length){
      selectedServices = _.filter(otherServices, function(service){
        return _.contains(additional_services, service.id);
      });
    }

    /**
     * @name routes.getStarted.servicesCtrl.recommended
     * @memberOf routes.getStarted.servicesCtrl
     * @type {{all, selected: (*|Blob|ArrayBuffer|Array.<T>|string)}}
     */
    this.recommended = {
      all: recommendedServices,
      selected: selectedRecommendedServices
    };
    this.other = {
      // exclude any from recommended
      all: otherServices,
      selected: selectedServices
    };

    setTotalSelected();

    /**
     * @name routes.getStarted.servicesCtrl.goToSignup
     */
    this.goToSignup = function () {
      var selectedServiceIds = _.pluck(this.recommended.selected, 'id');
      var selectedRecommendations = _.filter(Recommendations, function(rec){
        return _.contains(selectedServiceIds, rec.serviceId);
      });

      visitPlanBuilder.setValues({
        requested_benefits: _.pluck(selectedRecommendations, 'id'),
        additional_services: _.pluck(this.other.selected, 'id')
      });

      var prop = {};
      prop[trackingService.propEnum.getstarted.recommendedServices] = _.pluck(self.recommended.all, 'serviceName');
      prop[trackingService.propEnum.getstarted.recommendedServicesSel] = _.pluck(self.recommended.selected, 'serviceName') ;
      prop[trackingService.propEnum.getstarted.suggestedServices] = _.pluck(self.other.all, 'serviceName');
      prop[trackingService.propEnum.getstarted.suggestedServicesSel] = _.pluck(self.other.selected, 'serviceName');
      prop[trackingService.propEnum.getstarted.selectedValue] = self.selectedSum;
      //trackingService.setPeopleProps(prop);
      trackingService.mixpanelEvent('Get Started: Services Selected', prop);
      $state.go('^.signup');
    };

    /**
     * @name routes.getStarted.servicesCtrl.toggleRecommended
     */
    this.toggleRecommended = _.partial(toggle, 'recommended');

    /**
     * @name routes.getStarted.servicesCtrl.toggleOther
     */
    this.toggleOther = _.partial(toggle, 'other');

    /**
     * Calculates the total value of selected services
     */
    function setTotalSelected() {
      var recommendedCosts = _.pluck(self.recommended.selected, 'estimatedCost');
      var otherCosts = _.pluck(self.other.selected, 'estimatedCost');
      var recommendedSum = _.reduce(recommendedCosts, function (memo, num) {
        return memo + num;
      }, 0);
      var otherSum = _.reduce(otherCosts, function (memo, num) {
        return memo + num;
      }, 0);

      self.selectedSum = recommendedSum + otherSum;
      visitPlanBuilder.setValues({
        selectedSum: self.selectedSum
      });
    }

    /**
     * Toggles services to be checked or unchecked
     * @param arrayName
     * @param item
     */
    function toggle(arrayName, item) {
      var array = this[arrayName].selected;
      var index = array.indexOf(item);

      if (index > -1) {
        array.splice(index, 1);
      }
      else {
        array.push(item);
      }
      setTotalSelected();
    }
  }

  Ctrl.$inject = ['$state', 'Recommendations', 'AllServices', 'visit.plan.builder', 'services.tracking'];

  angular.module('routes.getStarted')
    .controller('routes.getStarted.servicesCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.getStarted.signupCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {user.model} userModel
   * @param {health.app} applicationModel
   * @param {user.service} userService
   * @param {routes.getStarted.model} getStartedModel
   * @param {visit.plan.builder} visitPlanBuilder
   * @param {member.service} memberService
   * @param {address.service} addressService
   * @param {logger} logger
   * @param {notification.service} notificationService
   */
  function Ctrl($q, $state, userModel, applicationModel, userService, getStartedModel, visitPlanBuilder, memberService, addressService, logger, notificationService) {
    var self = this;
    var lock = false;

    this.selectedAmount = visitPlanBuilder.getValue('selectedSum') || 0;

    this.loginModel = {
      username: '',
      password: '',
      confirm: ''
    };

    /**
     * @name routes.getStarted.signupCtrl.create
     * @param form
     * @returns {*}
     */
    this.create = function (form) {
      if (lock) {
        return;
      }

      lock = true;
      self.submitError = false;
      return userService.createFromForm(this.loginModel.username, this.loginModel.password, userModel, applicationModel, form)
        .then(function () {
          // If new account is created, update the primary member for the user
          // with info they provided in FTUX flow
          return $q.all([
            memberService.getPrimary(userModel),
            addressService.post(userModel, getStartedModel.data.geo)
          ]);
        })
        .then(function (responses) {
          var primaryMember = responses[0];
          var address = responses[1];

          primaryMember.dob = getStartedModel.data.isoDOB;
          primaryMember.gender = getStartedModel.data.gender.toUpperCase();
          primaryMember.address_id = address.id;
          return memberService.saveMember(userModel, primaryMember);
        })
        .then(function (primaryMember) {
          visitPlanBuilder.setValue('member', {id: primaryMember.id});

          return $q.all([
            visitPlanBuilder.finish(),
            visitPlanBuilder.data.selectedSum
          ]);
        })
        .then(function(responses){
          var visitPlan = responses[0];
          var shared = notificationService.getShared();

          var notifications = [
            shared.drugs,
            shared.doctors,
            shared.concierge,
            {
              "messageType": "FTUX_visit_plan_ready",
              "payload": {
                "estimatedValue": self.selectedAmount,
                "visitPlanId": visitPlan.id
              }
            }
          ];

          return $q.all([
            notificationService.post(notifications, userModel.getId()),
            getStartedModel.complete(userModel, self.selectedAmount)
          ]);
        })
        .then(function(res){
          visitPlanBuilder.clear();
          return $state.go('dashboard');
        })
        .catch(function (response) {
          var stateData = $state.getData();

          // User already exists
          logger.error({
            message: 'FTUX create error',
            stack: response
          });

          self.submitError = true;

          if (stateData && stateData.errorState) {
            $state.go(stateData.errorState, {user: self.loginModel.username});
          }
        })
        .finally(function () {
          lock = false;
        });

    };
  }

  Ctrl.$inject = ['$q', '$state', 'baseUser', 'baseHealthApp', 'user.service', 'routes.getStarted.model', 'visit.plan.builder', 'member.service', 'address.service', 'logger', 'notification.service'];

  angular.module('routes.getStarted')
    .controller('routes.getStarted.signupCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.partner.flushotsController
   * @param {ng.$rootScope.Scope} $scope
   * @param {ui.router.state.$state} $state
   * @param {user.model} userModel
   * @param {services.promo} promoService
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl($scope, $state, userModel, promoService, trackingService) {
    var self = this;

    if (!userModel.isLoggedIn && $state.includes('flushots.redeem')) {
      $state.replace('flushots');
    } else if (userModel.isLoggedIn && $state.includes('flushots.redeem')) {
      redeem();
    }

    function redeem() {
      promoService.redeemFlu()
        .then(function (data) {
          if (data.status === 200) {
            self.maxReached = false;
            trackingService.incrementPeopleProp(trackingService.propEnum.flushotSent);
          }
        })
        .catch(function (error) {
          var errorMessage = error.data.message;
          if (errorMessage === 'User has already redeemed') {
            self.alreadyRedeemed = true;
          } else if (errorMessage === 'Redemption Limit Reached') {
            self.maxReached = true;
          }
        });
    }

    this.render = true;
  }

  Ctrl.$inject = ['$scope', '$state', 'user.model', 'services.promo', 'services.tracking'];

  angular.module('routes.partner')
    .controller('routes.partner.flushotsController', Ctrl);
}());

angular.module('routes.plan')
  .controller('routes.plan.recommended.controller', [
    '$q',
    '$state',
    '$scope',
    '$stateParams',
    'baseUser',
    'baseHealthApp',
    'plan.utils',
    'plan.search',
    'logger',
    'services.tracking',
    'snackbar.service',
    'services.date',
    function ($q, $state, $scope, $stateParams, userModel, applicationModel, planUtils, planSearch, logger, trackingService, snackbarService, dateService) {
      var self = this;
      var errObj = {
        userOid: userModel.getId(),
        healthApp: applicationModel.get()
      };

      if (!applicationModel.hasValidDemos()){
        errObj.message = 'Invalid demographic information on health application';
        logger.error(errObj);

        // go home in case ob step is on recommended to avoid looping
        return $state.replace('home');
      }

      planSearch
        .getMerged(applicationModel)
        .then(function (plans) {

          if (!plans.length){
            return $q.reject('No plan found');
          }

          self.bestPlan = planUtils.getTopPlan(plans);
          self.similarPlan = planUtils.getSimilarPlan(plans);
          self.lowestPlan = planUtils.getLowestPlan(plans);
          self.render = true;

          //setSnackbar(self.bestPlan);

          var trackingObj = {
            'Recommended Plan Name': getPlanName(self.bestPlan),
            'Recommended Plan Stride Plan ID': self.bestPlan.id,
            'Recommended Plan HIOS ID': self.bestPlan.planId
          };

          if (plans.length >= 3) {
            _.each(['lowestPlan', 'similarPlan'], function(key, index){
              var keyStart = 'Secondary Plan ' + (index + 1) + ' ';
              trackingObj[keyStart + 'Name'] = getPlanName(self[key]);
              trackingObj[keyStart + 'Flag'] = self[key].special;
              trackingObj[keyStart + 'Stride Rank'] = self[key].mods.ranks.strideRank;
              trackingObj[keyStart + 'Stride Plan ID'] = self[key].id;
              trackingObj[keyStart + 'HIOS ID'] = self[key].planId;
            });
          }

          trackingService.mixpanelEvent('Plan Compare: Recommendation', trackingObj);
          trackingService.setPeopleProps({
            'Recommended Network Data': self.bestPlan.mods.providers.qtyNearby > 0,
            'Plan year viewed': self.bestPlan.planYear
          });

          if (!applicationModel.isComplete() && applicationModel.get().obStep !== 'recommended'){
            applicationModel.get().obStep = 'recommended';
          }

          sendQuotitTracking();
        })
        .catch(function (err) {
          errObj.message = err && err.message || err;
          logger.error(errObj);
          $state.replace('500');
        });

      this.pickPlan = function(plan){
        planUtils.trackDetailView(plan);
        $state.go('.planDetail', planUtils.getDetailParams(plan));
      };

      function getPlanName(plan){
        return plan.carrier + ' ' + plan.name;
      }

      //function setSnackbar(plan){
      //  var snackbarItemKey;
      //  var keyPrefix = 'planDetail.oep.';
      //
      //  return dateService.isOepAsync({ onExchange: applicationModel.hasSubsidy(), state: applicationModel.getState() })
      //    .then(function(isOep){
      //      if (plan.planYear === 2015){
      //        snackbarItemKey = keyPrefix + 'oldPlan' + (userModel.isLoggedIn ? '' : 'LoggedOut');
      //      }
      //      else if (
      //        !isOep &&
      //        plan.planYear === 2016 &&
      //        !userModel.isLoggedIn){
      //        snackbarItemKey = keyPrefix + 'newPlanLoggedOut';
      //      }
      //
      //      if (snackbarItemKey){
      //        snackbarService.push({
      //          key: snackbarItemKey,
      //          tokens: { createHref: $state.href('ob.account') },
      //          duration: -1
      //        });
      //
      //        $scope.$on('$destroy', snackbarService.clear);
      //      }
      //    });
      //}

      function sendQuotitTracking(){
        return dateService.getEffectiveDate({
          onExchange: applicationModel.hasSubsidy(),
          state: applicationModel.getState()
        })
          .then(function(effectiveDate){
            return planSearch.trackQuote(applicationModel, effectiveDate);
          });
      }
    }
  ]);
(function(){

  /**
   * @name routes.ob.deadlineCtrl
   * @param {object} $state
   * @param {{ stateConfig: object, periods: { current: EnrollmentPeriod, next: EnrollmentPeriod} }} Deadline
   * @param {plan.deadlineSvc} planDeadlineSvc
   */
  function Ctrl($state, Deadline, planDeadlineSvc){
    this.model = planDeadlineSvc.getModel(Deadline.periods.current, Deadline.periods.next);
    this.stateConfig = Deadline.stateConfig;

    // skip over this page if it's not around cutoff time
    if (!this.model.showCutoffNear && !this.model.showCutoffMissed){
      $state.replace($state.getData().nextState);
    }
  }
  Ctrl.$inject = ['$state', 'Deadline', 'plan.deadlineSvc'];

  angular.module('routes.ob')
    .controller('routes.ob.deadlineCtrl', Ctrl);
}());
angular.module('routes.ob')
  .controller('routes.ob.doctors.controller', [
    '$scope',
    '$state',
    '$filter',
    'baseUser',
    'baseHealthApp',
    'application.service',
    'services.alert',
    'doctor.service',
    'plan.utils',
    'AppDoctors',
    function ($scope, $state, $filter, userModel, applicationModel, applicationService, alertService, doctorService, planUtils, AppDoctors) {
      $scope.render = false;
      if (!applicationModel.hasValidDemos()) {
        return;
      }

      $scope.statsModel = {};

      function showGenericStats() {
        alertService.setMessage({
          key: 'profile.alert.doctorCount',
          model: $scope.statsModel
        });
      }

      $scope.doctors = AppDoctors;
      $scope.hasDoctors = function(){
        return $scope.doctors.length > 0;
      };

      updateBanner();

      $scope.$on('provider-added', function($event, result){
        $scope.doctors.push(result.details);
        applicationModel.member_providers.push(result.provider);
      });

      $scope.$on('provider-removed', function($event, result){
        var id = result.details.id;
        var removedIndex = _.findIndex(applicationModel.member_providers, { provider_id: id });

        $scope.doctors.splice(_.findIndex($scope.doctors, { id: id }), 1);
        applicationModel.member_providers.splice(removedIndex, 1);
        updateBanner();
      });

      function updateBanner() {
        var count = $scope.doctors.length;
        var address = applicationModel.getAddress();

        if (!count) {
          doctorService.getStatsByZip(address.zipcode)
            .then(function (stats) {
              $scope.statsModel = {
                count: $filter('number')(stats.providers, 0),
                state: address.state,
                city: address.city
              };
              showGenericStats();
            });
        }
        else {
          var params = planUtils.getDateParams();
          params.state = address.state;
          params.region = address.region;
          params.countyFips = address.county_fips;
          params.productType = 'health';

          doctorService.getNetworkStats(_.pluck($scope.doctors, 'id'), params)
            .then(function (stats) {
              alertService.setMessage({
                key: 'profile.alert.doctorNetworks',
                model: {
                  count: stats.sharedPlans
                }
              });
            });
        }
      }

      $scope.onNext = function () {
        $scope.ob.setMaxProgress('drugs');
        $state.go('ob.privacy');
      };

      $scope.$watch(function(){ return $scope.doctors.length; }, function(newValue){
        if (newValue === 0 && $state.is('ob.doctors.list')){
          $state.go('ob.doctors');
        }
      });

      $scope.$on('clear-search', $scope.hideSearch);
      $scope.$on('$destroy', alertService.clear);
      $scope.$on('$stateChangeSuccess', checkRedirect);
      checkRedirect();
      function checkRedirect(){
        if ($scope.hasDoctors() && $state.is('ob.doctors')){
          $state.replace('.list');
        }
        else if (!$scope.hasDoctors() && $state.is('ob.doctors.list')){
          $state.replace('^');
        }
      }
    }
  ]);
(function () {

  /**
   *
   * @param $state
   * @param $scope
   * @param {application.model} applicationModel
   * @param {drug.editor} drugEditor
   * @param alertService
   * @param {user.model} userModel
   * @param {drug.service} drugService
   * @param {application.service} applicationService
   */
  function ObDrugsController($state, $scope, applicationModel, drugEditor, alertService, userModel, drugService, applicationService) {
    var self = this;

    if (!applicationModel.hasValidDemos()) {
      return;
    }

    this.render = false;

    applicationService.getDrugs(userModel, applicationModel.getId())
      .then(function (response) {
        self.render = true;
        $scope.drugs = response;
      });

    $scope.applicationType = applicationModel.getType();
    $scope.showDrugSearch = false;

    $scope.showSearch = function () {
      $scope.showDrugSearch = true;
    };

    $scope.hideSearch = function () {
      $scope.showDrugSearch = false;
    };

    $scope.onNext = function () {
      $scope.ob.setMaxProgress('illnesses');
      $state.go('ob.illnesses.edit');
    };

    $scope.$on('drug-select', function ($event, drug) {
      drugEditor.setDrug(drug);
      $state.go('.edit.dose');
    });

    $scope.$on('drug-remove', function ($event, drug) {
      drugService.removeDrug(userModel, drug, applicationModel)
        .then(function (response) {
          if (response) {
            $scope.drugs = applicationModel.member_drugs = _.reject($scope.drugs, { id: drug.id });
          }
        });
    });

    $scope.$on('drug-saved', function($event, drug){
      var index = _.findIndex(applicationModel.member_drugs, { id: drug.id });
      if (index > -1) {
        applicationModel.member_drugs[index] = drug;
      } else {
        applicationModel.member_drugs.push(drug);
      }

      $scope.drugs = applicationModel.member_drugs;
    });

    $scope.$on('drug-edit', function ($event, drug) {
      drugEditor.setDrug(drug);
      $state.go('.edit.dose');
    });

    $scope.$on('clear-search', function () {
      $scope.hideSearch();
    });

    $scope.$on('$stateChangeSuccess', function () {
      if ($state.is('ob.drugs')) {
        alertService.clear();
      }
    });
  }

  ObDrugsController.$inject = ['$state', '$scope', 'baseHealthApp', 'drug.editor', 'services.alert', 'baseUser', 'drug.service', 'application.service'];

  angular.module('routes.ob')
    .controller('routes.ob.drugs.controller', ObDrugsController);
}());
angular.module('routes.ob')
  .controller('routes.ob.familyCtrl', [
    '$scope',
    '$state',
    '$filter',
    'baseHealthApp',
    'baseUser',
    'snackbar.service',
    'plan.stats',
    'services.alert',
    'member.service',
    /**
     *
     * @param $scope
     * @param $state
     * @param $filter
     * @param applicationModel
     * @param userModel
     * @param snackbarService
     * @param planStats
     * @param alertService
     */
      function ($scope, $state, $filter, applicationModel, userModel, snackbarService, planStats, alertService, memberService) {
      var self = this;

      if (!applicationModel.hasAddress()) {
        return;
      }

      // Data teaser
      $scope.ob.addDefaultMessage();
      $scope.$on('$destroy', snackbarService.clear);
      $scope.$on('app-members-update', function ($event, data) {
        applicationModel.members = data.appMembers;
      });

      // Get Members
      $scope.members = {
        allMembers: [],
        appMembers: [],
        newMembers: []
      };
      memberService.getMemberSet(userModel, applicationModel.getId())
        .then(function (response) {
          $scope.members.allMembers = response.allMembers;

          // Do not add household members into app members array
          var filteredAppMembers = _.reject(response.appMembers, function (member) {
            return member.member_application && member.member_application.type === 'household';
          });
          $scope.members.appMembers = filteredAppMembers;

          $scope.render = true;
        });
      self.members = $scope.members;

      /**
       * When the user edits the member detail and saves, the member is saved to the server but the client needs to be
       * updated until the server does a get on members again
       */
      $scope.$on('member-updated', function (event, member) {
        // Find the member in the arrays and update
        var allIndex = _.findIndex(self.members.allMembers, {id: member.id});
        var appIndex = _.findIndex(self.members.appMembers, {id: member.id});

        self.members.allMembers[allIndex] = _.extend(self.members.allMembers[allIndex], member);
        self.members.appMembers[appIndex] = _.extend(self.members.appMembers[appIndex], member);
      });


      this.goNext = function () {
        // Save app members
        var appMembers = _.chain($scope.members.allMembers)
          .filter(function (member) {
            var appMember = _.findWhere($scope.members.appMembers, {id: member.id});
            if (appMember && !memberService.isMedicaid(appMember)) {
              return true;
            }
            return false;
          })
          .map(function (member) {
            return _.extend({}, member, {status: 'coverage'});
          })
          .value();

        applicationModel.saveMembers(userModel, appMembers)
          .then(function () {
            $scope.ob.setMaxProgress('doctors');
            $state.go('ob.doctors');
          })
          .catch(function (error) {

          });
      };

      $scope.$on('updated-app-members', function (event, data) {
        updateMessage(data);
      });


      this.getAppMemberCount = function () {
        return memberService.filterNonMedicaidAppMembers($scope.members.appMembers).length;
      };

      function updateMessage(data) {
        var messageKeyPrefix = 'profile.alert.';
        var filterNumber = $filter('number');

        var applicants = data.appMembers;
        var address = applicationModel.getAddress();
        var numAppMembers = applicants.length;
        var key = messageKeyPrefix + 'planCostAvg' + (numAppMembers < 2 ? '' : 'Family');

        if (_.every(applicants, function (applicant) {
            return applicant.age;
          })) {
          key = messageKeyPrefix + (numAppMembers < 2 ? 'planCostStartAt' : 'planCostRangeFamily');

          planStats.getRangeForApp(applicationModel, applicants)
            .then(function (stats) {
              alertService.setMessage({
                key: key,
                model: {
                  familySize: numAppMembers,
                  min: filterNumber(stats.minCost, 0),
                  max: filterNumber(stats.maxCost, 0),
                  avg: filterNumber(stats.medianCost, 0),
                  state: address.state,
                  city: address.city,
                  age: applicants[0].age
                }
              });
            });
        }

      };

    }

  ]);
angular.module('routes.ob')
  .controller('routes.ob.illnesses.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'application.service',
    'services.alert',
    'member.service',
    'plan.search',
    'baseUser',
    function($scope, $state, applicationModel, applicationService, alertService, memberService, planSearch, userModel){
      if (!applicationModel.hasValidDemos()){
        return;
      }

      $scope.$on('$stateChangeSuccess', function($event, toState){
        var alertKey = 'profile.alert.illnessIntro';
        if (toState.name.indexOf('smoking') > -1){
          alertKey = 'profile.alert.smoking';
        }

        alertService.setMessage({
          key: alertKey
        });
      });

      $scope.applicationType = applicationModel.getType();

      function onEdit(){
        memberService.saveMembers(userModel, applicationModel.getMembers())
          .catch(function(err){
            $scope.ob.logSyncError(err);
          });
      }

      function goToEdit(){
        $state.go('.edit');
      }

      $scope.hasIllnesses = function(){
        return _.some(applicationModel.getMembers(), function(member){
          return _.isArray(member.illnesses) && member.illnesses.length > 0;
        });
      };

      $scope.$on('illness-add', goToEdit);
      $scope.$on('illness-edit-complete', onEdit);
      $scope.$on('illness-remove', onEdit);

      if (!$scope.hasIllnesses() && $state.is('ob.illnesses')){
        goToEdit();
      }
    }
  ]);
angular.module('routes.ob')
  .controller('routes.ob.smoking.controller', [
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'member.service',
    /**
     * @param $scope
     * @param $state
     * @param {user.model} userModel
     * @param {health.app} applicationModel
     * @param {member.service} memberService
     */
    function($scope, $state, userModel, applicationModel, memberService){
      $scope.applicants = applicationModel.getMembers();

      $scope.setSelf = function(bool){
        applicationModel.getPrimary().tobacco = bool;
        $scope.done();
      };

      $scope.done = function(){
        memberService.saveMembers(userModel, applicationModel.getMembers())
          .then(function(){
            $scope.ob.setMaxProgress('savings');
            $state.go('ob.savings.subsidy');
          })
          .catch(function(err){
            $scope.ob.logSyncError(err);
          });
      };

      $scope.anySelected = function(){
        return !!_.findWhere(applicationModel.getMembers(), { tobacco: true });
      };
    }
  ]);
(function(){

  /**
   *
   * @param $state
   * @param $scope
   * @param $stateParams
   * @param applicationModel
   * @param alertService
   * @param geoSearch
   * @param {plan.stats} planStats
   * @param {plan.utils} planUtils
   * @param {user.model} userModel
   * @param {address.service} addressService
   * @constructor
   */
  function LocationController($state, $scope, $stateParams, applicationModel, alertService, geoSearch, planStats, planUtils, userModel, addressService){
    var currentState = $state.current;
    var self = this;

    self.locations = [];
    self.zipcode = $stateParams.zipcode || '';

    addressService.getForApp(userModel, applicationModel.getId())
      .then(function(address){
        self.address = address || {};

        if (!self.zipcode && !self.address.zipcode && userModel.getPartnerData('zipcode')){
          self.zipcode = userModel.getPartnerData('zipcode');
        }

        self.autoSearch = self.zipcode && /^\d{5}$/.test(self.zipcode);
        self.searching = self.autoSearch;

        if (!self.searching && self.address.zipcode){
          self.zipcode = self.address.zipcode;
        }

        // do the search immediately if zipcode was passed in via querystring
        if (self.searching){
          self.search();
        }
      });

    self.search = function(){
      self.searching = true;
      geoSearch.getByZip(self.zipcode)
        .then(function(list){
          self.locations = list;
          self.invalidZip = list.length === 0;

          if (list.length === 1){
            self.confirm(list[0]);
          }
          else {
            self.searching = false;
            self.invalidZip = true;
          }
        })
        .catch(function(){
          self.searching = false;
          self.invalidZip = true;
        });
    };

    self.confirm = function(location){
      if (location){
        geoSearch.checkValidState(location.state)
          .then(function(valid){
            // always try to get get plans for 2016 first
            if (valid){
              planUtils.setOepDate();
            }

            return valid && planStats.get(geoSearch.fromAddress(location), 'p18f');
          })

          // try on exchange too
          //.then(function(stats){
          //  if (stats && stats.planCount === 0){
          //    return planStats.get(location, 'p18f', true);
          //  }
          //
          //  return stats;
          //})

          .then(function(stats){
            var nextState = 'invalid-region';
            _.extend(self.address, location);

            if (stats && stats.planCount > 0){
              nextState = currentState.data.nextState;
            }

            $scope.ob.setMaxProgress('family');
            return applicationModel.saveAddress(userModel, self.address)
              .then(function(){
                if (self.autoSearch){
                  $state.replace(nextState);
                }
                else {
                  $state.go(nextState);
                }

              });
          })
          .catch(function(err){
            console.log(err);
            $scope.ob.logSyncError(err);
          });
      }
    };

    alertService.clear();
  }
  LocationController.$inject = ['$state', '$scope', '$stateParams', 'baseHealthApp', 'services.alert', 'search.geo', 'plan.stats', 'plan.utils', 'baseUser', 'address.service'];

  angular.module('routes.ob')
    .controller('routes.ob.location.controller', LocationController);
}());

(function () {

  /**
   * Estimation controller - go to either guided or exact income estimation
   * @name routes.ob.estimateSelect.controller
   * @param $state
   * @param StartYear
   * @param financeService
   * @constructor
   */
  function Ctrl($state, StartYear) {
    this.year = StartYear;

    this.goToExactEstimation = function () {
      $state.go('ob.savings.income');
    };

    this.goToGuidedEstimation = function () {
      $state.go('ob.savings.guided.members');
    };
  }

  Ctrl.$inject = ['$state', 'StartYear'];

  angular.module('routes.ob')
    .controller('routes.ob.estimateSelect.controller', Ctrl);
}());
angular.module('routes.subsidy')
  .controller('routes.subsidy.calculate.controller', [
    '$scope',
    '$state',
    'application.model',
    function($scope, $state, applicationModel){
      $scope.continueState = $state.current.data.continueState;
      $scope.plan = applicationModel.getPlan();
    }
  ]);
angular.module('routes.ffm', [
  'ui.router',
  'user',
  'config',
  'common',
  'search',
  'application',
  'member'
])
  //.constant('routes.subsidy.ffm.steps', {
  //  profile: {
  //    state: 'ob',
  //    steps: []
  //  },
  //
  //  plan: {
  //    state: 'compare',
  //    steps: []
  //  },
  //
  //  subsidy: {
  //    state: 'subsidy',
  //    steps: [
  //      { key: 'subsidy', state: 'ffm.intro' },
  //      { key: 'sync', state: 'ffm.sync' },
  //      { key: 'amount', state: 'ffm.amount' },
  //      { key: 'confirm', state: 'ffm.confirm' }
  //    ]
  //  }
  //})

  .config([
    '$stateProvider',
    'config.paths',
    function($stateProvider, paths){
      var subsidyBase = paths.partials + '/routes/subsidy';
      var base = subsidyBase + '/ffm';

      /**
       * @namespace routes.ffm
       */

      $stateProvider
        .state('ffm', {
          url: '/shop-ffm',
          parent: 'purchase',
          templateUrl: base + '/ffm.html',
          controller: 'routes.subsidy.ffm.controller',
          data: {
            isFFM: true
          }
        })

        .state('ffm.sync', {
          url: '/sync',
          templateUrl: base + '/sync/sync.html',
          controller: 'routes.subsidy.ffm.sync.controller',
          resolve: {
            ffmApplication: ['routes.ffm.service', 'baseHealthApp', function(ffmService, applicationModel){
              return ffmService.getApplication(applicationModel.getId());
            }],
            Members: ['member.service', 'baseUser', function(memberService, userModel){
              return memberService.get(userModel);
            }]
          }
        })

        .state('ffm.sync.partial', {
          url: '/partial',
          templateUrl: base + '/sync/partial.html',
          controller: 'routes.subsidy.ffm.sync.partial.controller'
        })

        .state('ffm.sync.ineligible', {
          url: '/ineligible',
          templateUrl: base + '/ineligible/ineligible.html',
          controller: 'routes.subsidy.ffm.ineligible.controller'
        })

        .state('ffm.check', {
          url: '/plan-check',
          templateUrl: subsidyBase + '/calculate/calculate.html',
          controller: 'routes.subsidy.calculate.controller',
          data: {
            continueState: 'ffm.amount'
          }
        })

        .state('ffm.amount', {
          url: '/amount',
          templateUrl: base + '/amount/amount.html',
          controller: 'routes.subsidy.ffm.amount.controller',
          data: {
            next: 'ffm.eSign'
          }
        })

        .state('ffm.amount.partial', {
          url: '/partial',
          templateUrl: base + '/amount/partial-amount.html'
        })

        .state('ffm.eSign', {
          url: '/e-sign',
          templateUrl: base + '/e-sign/template.html',
          controller: 'routes.subsidy.ffm.eSignCtrl'
        })

        .state('ffm.submitted', {
          url: '/complete',
          templateUrl: base + '/submitted/submitted.html',
          controller: 'routes.buy.submitted.controller as submittedCtrl'
        })

        .state('ffm.error', {
          url: '/error',
          templateUrl: base + '/error.html'
        });
    }
  ]);


angular.module('routes.subsidy')
  .controller('routes.subsidy.ffm.controller', [
    '$q',
    '$scope',
    '$state',
    'baseHealthApp',
    'application.service',
    'baseUser',
    'routes.ffm.service',
    'cart.service',
    function($q, $scope, $state, applicationModel, applicationService, userModel, ffmService, cartService){
      var application = applicationModel.get();
      $scope.dentalApp = null;
      // if they don't have a subsidy attached, send them to our buy flow
      if (!applicationModel.getPlan() || !applicationModel.getPlan().qhpStatus){
        return $state.go('buy');
      }

      // if they have an aptc attached already, they already went to healthcare.gov
      // could potentially be coming back from a changed recommendation
      // should send to the amount choice screen
      if (application.aptc && ($state.includes('ffm.sync') || $state.is('ffm'))){
        $state.go('ffm.amount');
      }

      var lock = false;
      $scope.application = application;
      $scope.savings = application.subsidy ? Math.floor(application.subsidy.amount) : 0;
      cartService.show();

      var cartApps = _.isArray(cartService.apps) && cartService.apps || [];

      $q.when(cartApps)
        .then(function(apps){
          if (!apps.length){
            return cartService.getApps();
          }

          return apps;
        })
        .then(function(){
          $scope.dentalApp = cartService.getAppByType('dental');
        });

      $scope.goToHCG = function(){
        if (!lock){
          lock = true;
          var requests = [
            ffmService.postToSaml(userModel.email, userModel.getId(), applicationModel.getState(), applicationModel.getId())
          ];

          if ($scope.dentalApp){
            requests.push(applicationService.deletePlan(userModel, $scope.dentalApp.app_id));
          }

          $q.all(requests)
            .then(function(responses){
              var samlResponse = responses[0];
              if (samlResponse && samlResponse.data){
                $('body').append(samlResponse.data.samlForm);
                $('#' + samlResponse.data.samlFormId).submit();
              }
            });
        }

      };
    }
  ]);
angular.module('routes.subsidy')
  .factory('routes.ffm.service', [
    '$q',
    '$http',
    'utils',
    'config.paths',
    function($q, $http, utils, paths){

      /**
       * @name routes.ffm.service
       */


      return {
        /**
         * @name routes.ffm.service.getConfig
         * @methodOf routes.ffm.service
         * @returns {Promise}
         */
        getConfig: function(){
          return $http.get(paths.services + '/content/entry/4bc8yuU4GkyAIa2wYK24ci/10', { cache: true })
            .then(function(response){
              return response && response.data && response.data.data || {};
            });
        },

        /**
         * @name routes.ffm.service.getApplication
         * @methodOf routes.ffm.service
         * @param {string} appId
         * @returns {Promise}
         */
        getApplication: function(appId){
          //return $q.when({
          //  status: "OK",
          //  isLoggedIn: true,
          //  ffmApplicants: {
          //    Person1: {
          //      name: {
          //        PersonGivenName: "PATRICK",
          //        PersonSurName: "BARNES"
          //      },
          //      dateOfBirth: "1984-03-17",
          //      gender: 'M',
          //      relationship: 'Self',
          //      ffmId: "275038359961434822",
          //      aptcAmount: "0.00",
          //      isAPTCEligible: true,
          //      phone: "301-372-8527",
          //      address: {
          //        street: "6407 W 80TH ST",
          //        city: "OVERLAND PARK",
          //        countyCode: "091",
          //        state: "KS",
          //        zipcode: "66204-3809"
          //      }
          //    },
          //
          //    Person2: {
          //      name: {
          //        PersonGivenName: "JANE",
          //        PersonSurName: "BARNES"
          //      },
          //      dateOfBirth: "1984-03-17",
          //      gender: 'F',
          //      relationship: 'Spouse',
          //      ffmId: "275038123421434822",
          //      aptcAmount: "0.00",
          //      isAPTCEligible: false,
          //      phone: "301-372-8527",
          //      address: {
          //        street: "6407 W 80TH ST",
          //        city: "OVERLAND PARK",
          //        countyCode: "091",
          //        state: "KS",
          //        zipcode: "66204-3809"
          //      }
          //    },
          //
          //    Person3: {
          //      name: {
          //        PersonGivenName: "JONNY",
          //        PersonSurName: "BARNES"
          //      },
          //      dateOfBirth: "2011-03-17",
          //      gender: 'M',
          //      relationship: 'Dependent',
          //      ffmId: "2750383599612334822",
          //      aptcAmount: "0.00",
          //      isAPTCEligible: true,
          //      phone: "301-372-8527",
          //      address: {
          //        street: "6407 W 80TH ST",
          //        city: "OVERLAND PARK",
          //        countyCode: "091",
          //        state: "KS",
          //        zipcode: "66204-3809"
          //      }
          //    }
          //  },
          //  totalAptc: "130.00"
          //
          //})

          return $http.get(paths.services + '/ffm/application', { params: { appId: appId } })
            .then(function(response){
              var json = response.data;

              if (_.isEmpty(json)) {
                return false;
              }

              var applicants = _.map(json.ffmApplicants, function(person){
                var relationship = person.relationship.toLowerCase();
                var type = relationship === 'self' ? 'primary' : relationship === 'spouse' ? 'spouse' : 'dependent';


                return {
                  ffmId: person.ffmId,
                  phone: person.phone,
                  address: person.address,
                  gender: person.gender,
                  relation: relationship,
                  type: type,
                  dob: person.dateOfBirth,
                  aptcEligible: person.isAPTCEligible,
                  exchangeEligible: person.isExchangeEligible,
                  first_name: person.name.PersonGivenName,
                  last_name: person.name.PersonSurName
                };
              });

              return {
                total: json.totalAptc,
                applicants: applicants,
                primaryAddress: (_.findWhere(applicants, { type: 'primary' }) || {}).address || null
              };

            });
        },

        /**
         * @name routes.ffm.service.postToSaml
         * @methodOf routes.ffm.service
         * @param {string} email
         * @param {UUID} oid
         * @param {string} state
         * @param {string} appId
         * @returns {Promise}
         */
        postToSaml: function(email, oid, state, appId){
          return $http.post(paths.services + '/ffm/samlize', { email: email, oid: oid, stateExchangeCode: state, appId: appId });
        },

        /**
         * @name routes.ffm.service.enroll
         * @methodOf routes.ffm.service
         * @param {health.app} applicationModel
         * @param {string} effectiveDate
         * @returns {Promise}
         */
        enroll: function(applicationModel, effectiveDate){
          return $http.post(paths.services + '/ffm/enrollment', {
            appId: applicationModel.getId(),
            premium: applicationModel.getPremium(),
            aptcApplied: applicationModel.get().aptc.applied,
            planId: applicationModel.getPlan().planId,
            policyEffectiveDate: effectiveDate,
            rateArea: applicationModel.getAddress().region
          });
        }
      };

    }
  ]);
/**
 * @namespace routes.subsidy.exchange
 */

angular.module('routes.subsidy')
  .config([
    '$stateProvider',
    'config.paths',
    function ($stateProvider, paths) {
      var partials = paths.partials;
      var subsidyBase = partials + '/routes/subsidy';
      var base = subsidyBase + '/exchange';
      var ctrlBase = 'routes.subsidy.exchange.';

      $stateProvider
        .state('exchange', {
          url: '/exchange/:stateCode',
          parent: 'subsidy',
          templateUrl: base + '/exchange.html',
          controller: ctrlBase + 'controller as exchangeCtrl',
          data: {
            scrollTop: true
          }
        })

        .state('exchange.qualifications', {
          url: '/qualifications',
          templateUrl: base + '/qualifications.html'
        })

        .state('exchange.address', {
          url: '/address',
          templateUrl: base + '/address/home.html',
          controller: ctrlBase + 'address.controller',
          data: {
            step: 'address'
          }
        })

        // applicant forms
        .state('exchange.applicants', {
          url: '/applicants',
          templateUrl: base + '/applicants/applicants.html',
          controller: ctrlBase + 'applicants.controller as applicantsCtrl',
          data: {
            continueState: '',
            step: 'applicants'
          }
        })
        .state('exchange.applicants.member', {
          url: '/:memberId',
          controller: ctrlBase + 'applicants.member.controller as memberDetailCtrl',
          templateUrl: paths.partials + '/components/member/member-detail.html',
          data: {
            backState: 'exchange.applicants',
            backKey: 'shared.buttons.cancel'
          }
        })
        .state('exchange.additional', {
          url: '/additional',
          templateUrl: base + '/applicants/additional.html',
          controller: ctrlBase + 'additional.controller',
          data: {
            step: 'additional'
          }
        })
        .state('exchange.pregnant', {
          url: '/pregnant',
          templateUrl: base + '/applicants/pregnant.html',
          controller: ctrlBase + 'pregnant.controller',
          data: {
            step: 'pregnant'
          }
        })
        .state('exchange.pregnant.applicants', {
          url: '/applicants',
          templateUrl: base + '/applicants/pregnant-applicants.html',
          controller: ctrlBase + 'pregnant.applicants.controller'
        })
        .state('exchange.pregnant.applicants.applicant', {
          url: '/:index',
          templateUrl: base + '/applicants/pregnant-applicant.html',
          controller: ctrlBase + 'pregnant.applicant.controller'
        })
        .state('exchange.pregnant.applicants.applicant.expecting', {
          url: '/expecting',
          templateUrl: base + '/applicants/pregnant-expecting.html'
        })

        // tax screens
        .state('exchange.taxes', {
          url: '/taxes',
          templateUrl: base + '/taxes/intro.html',
          controller: ctrlBase + 'taxes.controller',
          data: {
            step: 'taxes'
          },
          resolve: {
            StartYear: ['baseHealthApp', 'plan.deadlineSvc', function (healthApp, planDeadlineSvc) {
              return planDeadlineSvc.getStateEnrollment(healthApp)
                .then(function (response) {
                  return response.periods.next.stride_start_date.getUTCFullYear();
                });
            }]
          }
        })
        .state('exchange.taxes.primary', {
          url: '/primary',
          templateUrl: base + '/taxes/primary.html',
          controller: ctrlBase + 'taxes.primary.controller as primaryCtrl'
        })
        .state('exchange.taxes.primary.filingStatus', {
          url: '/filing-status',
          templateUrl: base + '/taxes/primary-filing-status.html'
        })
        .state('exchange.taxes.primary.filingStatus.invalid', {
          url: '/invalid',
          templateUrl: base + '/taxes/primary-filing-status-invalid.html',
          controller: ctrlBase + 'taxes.primary.controller.invalidStatus as invalidStatusCtrl',
          params: {
            invalidStatus: ''
          }
        })
        .state('exchange.taxes.income', {
          url: '/income',
          templateUrl: base + '/taxes/income/income.html',
          controller: ctrlBase + 'taxes.source.controller as incomeCtrl',
          data: {
            isOnboarding: false,
            financeType: 'income',
            summaryState: 'exchange.taxes.income.summary'
          }
        })
        .state('exchange.taxes.income.applicant', {
          url: '/source/:index',
          templateUrl: base + '/taxes/income/income-member.html',
          controller: ctrlBase + 'taxes.source.member.controller as incomeSourceMemberCtrl'
        })
        .state('exchange.taxes.income.summary', {
          url: '/summary',
          templateUrl: partials + '/routes/ob/savings/guided/guided-summary.html',
          controller: 'profile.guided.summary.controller as incomeSummaryCtrl',
          data: {
            next: 'exchange.taxes.deductions'
          }
        })
        .state('exchange.taxes.income.summary.edit', {
          url: '/member/:member_id',
          controller: 'profile.guided.summary.edit.controller as guidedSummaryEditCtrl',
          templateUrl: partials + '/routes/ob/savings/guided/edit-finance.html',
          params: {
            finances:null
          },
          data: {
            backState: 'exchange.taxes.income.summary',
            backKey: 'shared.buttons.cancel',
            stateReplace: 'true'
          }
        })
        .state('exchange.taxes.deductions', {
          // /subsidy/exchange/CA/taxes/deductions
          url: '/deductions',
          templateUrl: base + '/taxes/deductions/deductions.html',
          controller: ctrlBase + 'taxes.source.controller as deductionsCtrl',
          data: {
            isOnboarding: false,
            financeType: 'deduction',
            summaryState: 'exchange.taxes.deductions.summary'
          }
        })
        .state('exchange.taxes.deductions.applicant', {
          url: '/source/:index',
          templateUrl: base + '/taxes/deductions/deductions-member.html',
          controller: ctrlBase + 'taxes.source.member.controller as deductionsSourceCtrl'
        })
        .state('exchange.taxes.deductions.summary', {
          url: '/summary',
          templateUrl: base + '/taxes/deductions/deductions-summary.html',
          controller: 'profile.guided.summary.controller as deductionsSummaryCtrl',
          data: {
            next: 'exchange.taxes.eligibility'
          }
        })
        .state('exchange.taxes.deductions.summary.edit', {
          url: '/member/:member_id',
          controller: 'profile.guided.summary.edit.controller as guidedSummaryEditCtrl',
          templateUrl: partials + '/routes/ob/savings/guided/edit-finance.html',
          params: {
            finances:null
          },
          data: {
            backState: 'exchange.taxes.deductions.summary',
            backKey: 'shared.buttons.cancel',
            stateReplace: 'true'
          }
        })


        .state('exchange.taxes.eligibility', {
          url: '/eligibility',
          templateUrl: base + '/taxes/eligibility.html',
          controller: ctrlBase + 'taxes.eligibilityCtrl',
          data: {
            completedState: 'exchange.questions'
          }
        })

        .state('exchange.taxes.check', {
          url: '/check',
          templateUrl: base + '/taxes/check.html'
        })

        .state('exchange.questions', {
          url: '/questions',
          template: '<div ui-view class="module"></div>',
          controller: [
            '$scope',
            '$state',
            '$timeout',
            'baseHealthApp',
            'baseUser',
            function ($scope, $state, $timeout, applicationModel, userModel) {
              //if ($state.is('exchange.questions')){
              $timeout(function () {
                $state.go('exchange.questions.question', {steps: '1'}, {location: 'replace'});

              }, 10);
              //}

              $scope.$on('question-done', function () {
              });

              // save when all questions are done
              $scope.$on('questions-done', function () {
                applicationModel.save(userModel)
                  .then(function () {
                    $state.go('exchange.billing');
                  });
              });
            }
          ],
          data: {
            step: 'questions'
          },
          resolve: {
            questions: ['baseHealthApp', 'search.geo', 'stateConfig', 'routes.ffm.service', function (applicationModel, geoSearch, stateConfig, ffmService) {
              var request;
              if (stateConfig.ffm) {
                request = ffmService.getConfig();
              }
              else {
                request = geoSearch.getStateExchange(applicationModel.getState());
              }

              return request
                .then(function (exchange) {
                  return exchange && exchange.questions || [];
                });
            }],
            applicants: ['baseHealthApp', function (applicationModel) {
              return applicationModel.getMembers();
            }]
          }
        })
        .state('exchange.questions.question', {
          url: '/:steps',
          controller: 'questions.question.controller',
          templateUrl: partials + '/components/questions/question.html',
          resolve: {
            baseModel: ['baseHealthApp', function (applicationModel) {
              return applicationModel.getStateExchange();
            }]
          }
        })

        .state('exchange.billing', {
          url: '/billing',
          controller: 'billing.combined.controller',
          templateUrl: partials + '/components/billing/debit.html',
          data: {
            step: 'billing',
            nextState: 'exchange.confirm'
          }
        })
        .state('exchange.billing.credit', {
          url: '/credit',
          templateUrl: partials + '/components/billing/credit.html'
        })
        .state('exchange.billing.notAccepted', {
          url: '/credit',
          templateUrl: partials + '/components/billing/not-accepted.html'
        })

        .state('exchange.confirm', {
          url: '/agreement',
          controller: 'routes.buy.confirm.controller',
          templateUrl: partials + '/routes/buy/confirm/confirm.html',
          data: {
            step: 'confirm',
            nextState: 'exchange.eSign'
          }
        })

        .state('exchange.eSign', {
          url: '/e-sign',
          controller: 'profile.eSign.controller',
          templateUrl: partials + '/components/profile/e-sign/e-sign.html'
        })

        .state('exchange.submitted', {
          url: '/complete',
          templateUrl: partials + '/routes/buy/submitted/submitted.html',
          controller: 'routes.buy.submitted.controller as submittedCtrl'
        });
    }
  ]);
(function(){

  /**
   * @name routes.subsidy.exchange.controllerScope
   * @augments stride.rootScope
   * @property {string} stateName
   * @property {Object} qualifications
   * @property {Object} cartPlan
   * @property {Function} getStateExchange
   */

  /**
   * State Exchange Controller
   * @name routes.subsidy.exchange.controller
   * @memberOf services
   * @param {routes.subsidy.exchange.controllerScope} $scope
   * @param {ui.router.state.$state} $state
   * @param {Object} stateConfig
   * @param {application.model} applicationModel
   * @param {cart.service} cartService
   * @ngInject
   */
  function Controller($scope, $state, stateConfig, applicationModel, cartService){
    var self = this;
    this.render = false;
    console.warn('CART CHECK BYPASS %c remove for prod ','background:red; color:white')
    if (!cartService.apps || !cartService.apps.length){
      cartService.getApps()
      .then(function(){
        self.render = true;
      });
      // return $state.replace('cart');
    }

    $scope.stateName = stateConfig.name;
    var application = applicationModel.get();

    application.stateExchange = application.stateExchange || {};
    $scope.qualifications = {
      taxes: true,
      resident: true,
      incarcerated: true,
      minimumCoverage: true
    };

    $scope.$on('$stateChangeSuccess', function(){
      if ($state.current.data && $state.current.data.step){
        applicationModel.getStateExchange().step = $state.current.data.step;
      }
    });

    $scope.$on('$destroy', function(){
      if (!$state.is('cart')){
        cartService.clearApps();
      }
    });

    // if applicants have changed, wipe out the previous stateExchange
    //var applicants = applicationModel.getMembers();

    //if (
    //  applicants.length !== _.filter(exchangeApplicants, function(a){ return !a.excluded; }).length ||
    //  application.taxInfo.familySize !== exchangeApplicants.length ||
    //  !_.every(applicants, function(a){ return _.findWhere(exchangeApplicants, { uuid: a.uuid }); })
    //){
    //  application.stateExchange = {
    //    applicants: []
    //  };
    //}

    // jump to the step only after checking for previous applicant changes
    //var step = application.stateExchange.step;
    //var stepState = 'exchange.' + step;
    //if (step && $state.get(stepState) && !$state.includes(stepState)){
    //  $state.replace(stepState);
    //}
    //else if (!step && !$state.is('exchange')){
    //  $state.replace('exchange');
    //}


    //if (!applicationModel.get().addressId){
    //  return $state.replace('exchange.address');
    //}
    //
    //if (!$state.is('exchange') || !applicationModel.get().addressId){
    //  $state.replace('exchange');
    //}

    this.render = true;
  }

  Controller.$inject = ['$scope', '$state', 'stateConfig', 'baseHealthApp', 'cart.service'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.controller', Controller);
}());
(function(){

  /**
   * @namespace routes.visit
   */

  /**
   * @name routes.visit.plan
   * @param {ui.router.state.$stateProvider} $stateProvider
   * @param {ui.router.router.$urlRouterProvider} $urlRouterProvider
   * @param {config} config
   * @constructor
   */
  function Config($stateProvider, $urlRouterProvider, config){
    var pathBase = config.paths.partials + '/routes/visit/plan';
    var componentBase = config.paths.partials + '/components/visit/plan';
    var stepKeyPrefix = 'visit.plan.steps.';
    var stateNameBase = 'visitPlan';
    var namespaceBase = 'routes.visit.plan';

    $urlRouterProvider.when('/visit', '/visit/plan/intro')
      .when('/visit/plan', '/visit/plan/intro');

    $stateProvider
      .state(stateNameBase, {
        parent: 'sidebar',
        url: '/visit/plan',
        data: {
          scrollTop: true,
          authenticate: true,
          steps: [
            {
              name: stateNameBase + '.intro',
              key: 'shared.buttons.getStarted'
            },
            //{
            //  name: stateNameBase + '.member',
            //  key: stepKeyPrefix + 'who'
            //},
            {
              name: stateNameBase + '.type',
              key: stepKeyPrefix + 'what'
            },
            {
              name: stateNameBase + '.questions',
              key: stepKeyPrefix + 'qa'
            },
            {
              name: stateNameBase + '.benefits',
              key: stepKeyPrefix + 'recommendation'
            },
            {
              name: stateNameBase + '.doctor',
              key: stepKeyPrefix + 'provider'
            },
            {
              name: stateNameBase + '.complete',
              key: stepKeyPrefix + 'complete'
            }
          ]
        },
        views: {
          'main@sidebar': {
            templateUrl: pathBase + '/main.html',
            controller: namespaceBase + 'Ctrl as planCtrl'
          },
          'side@sidebar': {
            templateUrl: config.paths.partials + '/components/sidebar/steps/default.html',
            controller: 'sidebar.steps.controller as stepsController'
          },
          'steps@visitPlan': {
            templateUrl: config.paths.partials + '/components/sidebar/steps/mobile.html',
            controller: 'sidebar.steps.controller as stepsController'
          }
        },
        resolve: {
          ActiveHealth: ['baseUser', function(userModel){
            return userModel.fetchActiveHealth();
          }],
          PrimaryMember: ['baseUser', 'member.service', function(userModel, memberService){
            return memberService.getPrimary(userModel);
          }]
        }
      })
      .state(stateNameBase + '.intro', {
        url: '/intro',
        //controller: namespaceBase + '.introCtrl as introCtrl',
        templateUrl: pathBase + '/intro/intro.html'
      })
      //.state(stateNameBase + '.member', {
      //  url: '/member',
      //  controller: namespaceBase + '.memberCtrl as memberCtrl',
      //  templateUrl: pathBase + '/member/list.html',
      //  data: {
      //    next: stateNameBase + '.type',
      //    validParam: 'started'
      //  }
      //})
      .state(stateNameBase + '.type', {
        url: '/type',
        controller: namespaceBase + '.typeCtrl as typeCtrl',
        templateUrl: pathBase + '/type/list.html',
        data: {
          next: stateNameBase + '.type.details',
          validParam: 'member'
        }
      })
      .state(stateNameBase + '.type.details', {
        url: '/details',
        templateUrl: pathBase + '/type/details.html',
        data: {
          next: stateNameBase + '.questions'
        }
      })
      .state(stateNameBase + '.questions', {
        url: '/questions',
        controller: namespaceBase + '.questionsCtrl as questionsCtrl',
        templateUrl: pathBase + '/questions/questions.html',
        data: {
          validParam: 'type'
        },
        resolve: {
          questions: ['questions.service', 'visit.plan.builder', function(questionsService, planBuilder){
            var visitType = planBuilder.getValue('visitType');
            return visitType && questionsService.getByKeys(visitType.questionKeys, 'care') || null;
          }],

          builder: ['$state', 'common.class.builder', 'visit.plan.builder', 'questions', function($state, Builder, planBuilder, questions){
            console.log('creating question builder');

            var qBuilder = new Builder();
            qBuilder.setValue('questions', questions);
            qBuilder.setValue('translationBase', 'visit.plan');

            var keySets = _.pluck(qBuilder.getValue('questions'), 'keys');
            // need to set initial values for back button use
            var allKeys = _.flatten(keySets);
            _.each(allKeys, function(key){
              var val = planBuilder.getValue(key);
              if (!_.isUndefined(val)){
                qBuilder.setValue(key, val);
              }
            });

            qBuilder.next = function(currentIndex){
              // don't rely on questions being in some defined order
              // look through the keys that are required and find the first
              // one that hasn't been answered yet
              var nextKey = _.find(keySets, function(keys){
                return _.some(keys, function(key){
                  return _.isUndefined(qBuilder.getValue(key));
                });
              });

              if (!nextKey){
                if (currentIndex + 1 >= questions.length){
                  qBuilder.done();
                }

                else {
                  $state.go('^.question', { keys: keySets[currentIndex + 1] });
                }
              }
              else {
                $state.go('^.question', { keys: nextKey });
              }
            };

            qBuilder.done = function(){
              planBuilder.setValues(qBuilder.data);
              console.log(qBuilder.data);
              console.log(planBuilder.data);
              $state.go(stateNameBase + '.illnesses');
            };

            return qBuilder;
          }]
        }
      })
      .state(stateNameBase + '.questions.question', {
        url: '/:keys',
        controller: 'questions.builderCtrl as questionCtrl',
        templateUrl: config.paths.partials + '/components/questions/builder/question.html'
      })
      .state(stateNameBase + '.illnesses', {
        url: '/conditions',
        templateUrl: pathBase + '/illnesses/list.html',
        controller: namespaceBase + '.illnessesCtrl as illnessesCtrl',
        data: {
          validParam: 'questions',
          next: stateNameBase + '.benefits'
        },
        resolve: {
          illnesses: ['search.illnesses', function(illnessService){
            return illnessService.get();
          }]
        }
      })
      .state(stateNameBase + '.benefits', {
        url: '/benefits',
        templateUrl: pathBase + '/benefits/recommended.html',
        controller: 'visit.plan.benefitCtrl as benefitCtrl',
        data: {
          validParam: 'questions',
          next: '.suggested'
        }
      })
      .state(stateNameBase + '.benefits.suggested', {
        url: '/suggested',
        templateUrl: pathBase + '/benefits/suggested.html',
        data: {
          next: stateNameBase + '.doctor'
        }
      })
      .state(stateNameBase + '.benefits.all', {
        url: '/additional',
        templateUrl: componentBase + '/benefit/all/list.html',
        controller: 'visit.plan.benefit.allCtrl as allCtrl',
        data: {
          next: '^.suggested'
        }
      })
      .state(stateNameBase + '.doctor', {
        url: '/doctor',

        data: {
          validParam: 'requested_benefits',
          next: stateNameBase + '.complete'
        },
        resolve: {
          visitPlan: ['visit.plan.builder', function(builder){
            return builder.data;
          }]
        },
        views: {
          '': {
            controller: 'visit.plan.doctorCtrl as doctorCtrl',
            templateUrl: pathBase + '/doctor/main.html'
          },
          'results@visitPlan.doctor': {
            templateUrl: config.paths.partials + '/components/doctor/search/results/list.html',
            controller: 'routes.visit.plan.doctor.resultsCtrl as resultsCtrl'
          }
        }
      })
      .state(stateNameBase + '.doctor.search', {
        url: '/search',
        data: {
          termPlaceholder: 'visit.plan.doctor.termPlaceholder',
          geoPlaceholder: 'visit.plan.doctor.geoPlaceholder'
        },
        views: {
          '': {
            templateUrl: pathBase + '/doctor/search.html'
          },
          'search@visitPlan.doctor.search': {
            templateUrl: config.paths.partials + '/components/doctor/search/form.html',
            controller: 'visit.doctor.searchCtrl as searchCtrl'
          },
          'results@visitPlan.doctor.search': {
            templateUrl: config.paths.partials + '/components/doctor/search/results/list.html',
            controller: 'visit.plan.doctor.resultsCtrl as resultsCtrl'
          }
        }
      })
      .state(stateNameBase + '.complete', {
        url: '/complete',
        templateUrl: pathBase + '/complete/complete.html',
        controller: namespaceBase + '.completeCtrl as completeCtrl'
      });

  }
  Config.$inject = ['$stateProvider', '$urlRouterProvider', 'config'];

  angular.module('routes.visit.plan', ['ui.router', 'config', 'common', 'visit', 'questions', 'search', 'doctor', 'member'])
    .config(Config);

}());
(function(){

  /**
   * @name routes.visit.planCtrl
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.Scope} $scope
   * @param {visit.plan.builder} planBuilder
   * @param {user.model} userModel Remove this once we're allowing user to pick which member the visit is for
   * @param {ifp_app} ActiveHealth
   * @param {Member} PrimaryMember
   */
  function Ctrl($state, $scope, planBuilder, userModel, ActiveHealth, PrimaryMember){
    var self = this;

    //if (!userModel.isActiveHealthComplete()){
    //  return $state.replace('404');
    //}

    if (!planBuilder.getValue('started')){
      planBuilder.start();
    }

    this.redirect = function(event, toState){
      var data = toState.data;

      if (data && data.validParam){
        if (_.isUndefined(planBuilder.getValue(data.validParam))){

          if (event){
            event.preventDefault();
            $state.go('visitPlan');
          }
          else {
            $state.replace('visitPlan');
          }
        }
      }
    };

    // TODO: allow this to be chosen from a list of members attached to ActiveHealth
    self.member = PrimaryMember;
    planBuilder.setValues({
      member: PrimaryMember,
      ifp_app_id: _.get(ActiveHealth, 'app_id') // ActiveHealth could be null
    });

    $scope.$on('$stateChangeStart', this.redirect);
    this.redirect(null, $state.current);
  }
  Ctrl.$inject = ['$state', '$scope', 'visit.plan.builder', 'baseUser', 'ActiveHealth', 'PrimaryMember'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.planCtrl', Ctrl);
}());
angular.module('common.directives')
  .directive('shBackBar', [
    'config.paths',
    function (paths) {
      return {
        scope: {
          backState: '@',
          backKey: '@',
          stateReplace: '@'
        },
        templateUrl: paths.partials + '/common/directives/back/bar/template.html'
      };
    }
  ]);
//(function(){
//
//  /**
//   * @name application.planPreviewDirective
//   * @param $state
//   * @param {config.paths} paths
//   * @constructor
//   */
//  function Config($state, paths){
//    return {
//      templateUrl: paths.partials + '/components/application/plan/preview/directive.html',
//      scope: {
//        app: '=appPlanPreview',
//        detailStateName: '@'
//      },
//      link: function($scope){
//        $scope.detailState = $state.href($scope.detailStateName, { appId: $scope.app.app_id });
//      }
//    };
//  }
//  Config.$inject = ['$state', 'config.paths'];
//
//  angular.module('application')
//    .directive('appPlanPreview', Config);
//}());
(function(){
  function Ctrl($state, $scope, DoctorResultsModel){
    this.model = new DoctorResultsModel($state.getData().settings);
    this.model.watchResults($scope);
  }
  Ctrl.$inject = ['$state', '$scope', 'doctor.results.model'];

  angular.module('doctor')
    .controller('doctor.resultsCtrl', Ctrl);
}());
(function(){

  function Factory(doctorService, trackingService){

    /**
     * @constructor doctor.results.model
     * @param {Object} [settings]
     * @param {string} settings.trackingCategory
     * @param {number} settings.pageSize
     * @param {string} settings.viewType
     * @param {number[]} settings.omitted Array of provider ids to omit, useful for not showing docs that are already added
     * @param {ifp_app} [settings.ifp_app]
     */
    function Model(settings){

      this.results = [];
      this.rendered = [];
      /**
       * @name doctor.results.model.opts
       * @memberOf doctor.results.model
       */
      this.opts = _.extend({
        pageSize: Number.MAX_VALUE,
        trackingCategory: '',
        viewType: 'list'
      }, settings || {});

      this.showCount = this.opts.pageSize;
      this.markers = [];
    }

    Model.prototype.hasMore = function(){
      return this.results.length > this.rendered.length;
    };

    Model.prototype.showMore = function(){
      this.showCount += this.opts.pageSize;
      this.renderResults();

      if (this.opts.trackingCategory){
        trackingService.event(this.opts.trackingCategory, 'click', 'see_more');
      }
    };

    Model.prototype.searchTooShort = function(){
      return doctorService.searchTerm && doctorService.searchTerm.length < 3;
    };

    Model.prototype.showNoResults = function(){
      return doctorService.searchTerm && !doctorService.isSearching() && !this.rendered.length;
    };

    Model.prototype.isSearching = doctorService.isSearching;

    /**
     * @param {string} type
     */
    Model.prototype.setViewType = function(type){
      this.opts.viewType = type;

      if (this.opts.trackingCategory){
        trackingService.event(this.opts.trackingCategory, 'click', 'toggle_view');
      }
    };

    Model.prototype.renderResults = function(){
      this.rendered = this.results.slice(0, this.showCount);
      this.markers = _.chain(this.rendered)
        .filter(function(result){
          return _.isObject(result.location);
        })
        .map(function(result){
          return {
            lat: result.location.latitude,
            lng: result.location.longitude
          };
        })
        .value();
    };

    Model.prototype.watchResults = function($scope){
      $scope.$watch(function(){ return doctorService.searchResults; }, _.bind(this.updateResults, this));
    };

    Model.prototype.updateResults = function(results){
      var omitted = this.opts.omitted;
      if (_.isArray(omitted)){
        results = _.reject(results, function(result){
          return _.contains(omitted, result.id);
        });
      }

      this.showCount = this.opts.pageSize;
      this.results = results || [];
      this.renderResults();
    };

    Model.prototype.onClick = function($event, result){
      if (_.isFunction(this.opts.onClick)){
        $event.preventDefault();
        this.opts.onClick(result);
      }
    };

    return Model;
  }
  Factory.$inject = ['doctor.service', 'services.tracking'];

  angular.module('doctor')
    .factory('doctor.results.model', Factory);
}());
(function(){

  /**
   * @namespace financeTracker.expense
   */

  /**
   * @name financeTracker.expense.sourceCtrl
   * @param {ui.router.state.$state} $state
   * @param {$filter} $filter
   * @param {financeTracker.config} financeConfig
   * @param {services.tracking} trackingService
   * @param {financeTracker.txnBuilder} txnBuilder
   * @param {TransactionCategory[]} categories
   * @constructor
   */
  function Ctrl($state, $filter, financeConfig, trackingService, txnBuilder, categories){
    var expenseStr = 'expense';
    if (txnBuilder.getValue('started') !== true){
      txnBuilder.start(expenseStr);
    }

    this.week = txnBuilder.getValue('week');
    this.source = '';
    this.categories = _.where(categories, { transactionType: expenseStr });

    this.tokens = {
      weekStart: $filter('date')(this.week[0], 'EEEE M/d')
    };

    this.setCategory = function(category){
      var nextState = $state.current.data.nextState;
      var categoryName = category.productCategory;

      txnBuilder.setValue('category', category);

      if (category.productCategory.toLowerCase() === 'other'){
        nextState = '.other';
      }
      else {
        txnBuilder.setValue('source', categoryName);
        trackSource(categoryName);
      }

      $state.go(nextState);
    };

    this.setSource = function(){
      txnBuilder.setValue('source', this.source);
      trackSource(this.source);
      $state.go($state.current.data.nextState);
    };

    function trackSource(source){
      trackingService.mixpanelEvent(financeConfig.tracking.names.selectSource, {
        'Transaction Source': source,
        'Transaction Type': financeConfig.tracking.types[expenseStr]
      });
    }
  }
  Ctrl.$inject = ['$state', '$filter', 'financeTracker.config', 'services.tracking', 'financeTracker.txnBuilder', 'categories'];

  angular.module('financeTracker')
    .controller('financeTracker.expense.sourceCtrl', Ctrl);
}());
(function(){

  /**
   * @namespace financeTracker.income
   */

  /**
   * @name financeTracker.income.sourceCtrl
   * @param {ui.router.state.$state} $state
   * @param {$filter} $filter
   * @param {financeTracker.config} financeConfig
   * @param {services.tracking} trackingService
   * @param {financeTracker.txnBuilder} txnBuilder
   * @param {TransactionCategory[]} categories
   * @constructor
   */
  function Ctrl($state, $filter, financeConfig, trackingService, txnBuilder, categories){
    var incomeStr = 'income';

    if (txnBuilder.getValue('started') !== true){
      txnBuilder.start(incomeStr);
    }

    this.week = txnBuilder.getValue('week');
    this.source = '';
    this.sources = [
      'Uber',
      'Lyft',
      'Postmates',
      'Taskrabbit'
    ];

    this.tokens = {
      weekStart: $filter('date')(this.week[0], 'EEEE M/d')
    };

    // only one income transaction type for now
    txnBuilder.setValue('category', _.findWhere(categories, { transactionType: incomeStr }));

    this.setSource = function(source){
      txnBuilder.setValues({
        source: source,
        payeeName: source
      });

      trackingService.mixpanelEvent(financeConfig.tracking.names.selectSource, {
        'Transaction Source': source,
        'Transaction Type': financeConfig.tracking.types[incomeStr]
      });

      this.done();
    };

    this.done = function(){
      $state.go($state.current.data.nextState);
    };
  }
  Ctrl.$inject = ['$state', '$filter', 'financeTracker.config', 'services.tracking', 'financeTracker.txnBuilder', 'categories'];

  angular.module('financeTracker')
    .controller('financeTracker.income.sourceCtrl', Ctrl);
}());
(function(){

  /**
   * @name plan.dropdownCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {ui.router.state.$state} $state
   * @param {plan.compare.service} planCompareService
   * @constructor
   */
  function Ctrl($scope, $state, planCompareService){

    $scope.plans = planCompareService.getPlans();

    $scope.cancelCompare = function() {
      // Hide the dropdown
      this.show.showCompareDropdown = false;

      // Remove all plans from being compared and being checked
      planCompareService.removeAllComparePlans();
      this.plans.forEach(function(plan) {
        plan.selected = false;
      });

      // Go to view all state
      $state.go('^');
    };

    $scope.togglePlan = function(plan) {
      plan.selected = !plan.selected;
    };

    $scope.comparePlans = function () {
      if (this.isAllSelected()) {
        $state.go('.h2h', planCompareService.getCompareParams());
      }
    };

    $scope.getNumSelectedPlans = function() {
      return planCompareService.getNumSelectedPlans();
    };

    $scope.isAllSelected = function () {
      var plans = $scope.plans;
      return plans[0] && plans[1] && plans[0].selected && plans[1].selected;
    };
  }

  Ctrl.$inject = ['$scope', '$state', 'plan.compare.service'];

  angular.module('plan')
    .controller('dropdownCtrl', Ctrl);
}());
angular.module('plan')
  .directive('shPlanCompareDropdown', [
    '$http',
    'config.paths',
    function ($http, paths) {
      return {
        scope: {
          show: '='
        },
        replace: true,
        templateUrl: paths.partials + '/components/plan/compare/dropdown/dropdown.html',
        controller: 'dropdownCtrl as dropdownCtrl'
      };
    }
  ]);
(function(){

  /**
   * @name plan.list.compare.h2hCtrl
   * @param {ui.router.state.$state} $state
   * @param {ui.router.$stateParams} $stateParams
   * @param {Object} $scope
   * @param {plan.card} PlanInfo
   * @param {application.model} currentHealthApp
   * @param {services.tracking} trackingService
   */
  function Ctrl($state, $stateParams, $scope, PlanCard, currentHealthApp, trackingService){

    var id1 = parseInt($stateParams.pid1);
    var id2 = parseInt($stateParams.pid2);

    /** @type {HealthPlan} **/
    var plan1 = _.findWhere($scope.allPlans, { id: id1 });
    /** @type {HealthPlan} **/
    var plan2 = _.findWhere($scope.allPlans, { id: id2 });

    if (!plan1 || !plan2){
      return $state.replace('^');
    }

    trackingService.mixpanelEvent('Plan Compare: Head-to-head view', {
      'Plan 1 Name': plan1.carrier + ' ' + plan1.name,
      'Plan 1 Flag': plan1.special || '',
      'Plan 1 Stride Rank': plan1.mods.ranks.strideRank,
      'Plan 1 Stride Plan ID': plan1.id,
      'Plan 1 HIOS ID': plan1.planId,
      'Plan 2 Name': plan2.carrier + ' ' + plan2.name,
      'Plan 2 Flag': plan2.special || '',
      'Plan 2 Stride Rank': plan2.mods.ranks.strideRank,
      'Plan 2 Stride Plan ID': plan2.id,
      'Plan 2 HIOS ID': plan2.planId
    });
    trackingService.setPeopleProp('Head-to-head comparison viewed', true);

    this.plan1 = new PlanCard(plan1, currentHealthApp);
    this.plan2 = new PlanCard(plan2, currentHealthApp);

    this.plan1.setFullBenefits();
    this.plan2.setFullBenefits();

    this.plans = [this.plan1, this.plan2];


  }
  Ctrl.$inject = ['$state', '$stateParams', '$scope', 'plan.card', 'baseHealthApp', 'services.tracking'];

  angular.module('plan')
    .controller('plan.list.compare.h2hCtrl', Ctrl);
}());
(function(){

  function Config(paths, applicationModel){
    return {
      templateUrl: paths.partials + '/components/plan/detail/basics/directive.html',
      scope: {
        plan: '=?planBasics',
        applicantCount: '=?'
      },
      link: function($scope){
        if (!$scope.plan){
          $scope.plan = applicationModel.getPlan();
        }
        if (!_.isNumber($scope.applicantCount)){
          $scope.applicantCount = applicationModel.getMembers().length;
        }

        var indSuffix = "Ind";
        var famSuffix = 'Fam';
        var isFamilyPlan = $scope.applicantCount > 1 ;
        var deductibleKey = 'deductible' + (isFamilyPlan && famSuffix || indSuffix);
        var oopMaxKey = 'oopmax' + (isFamilyPlan && famSuffix || indSuffix);
        var deductibleRxKey = 'deductiblerx' + (isFamilyPlan && famSuffix || indSuffix);


        //// plan search is no longer extending the base plan object with limit information
        //// it is instead added as a limits property
        //// still have to assume older plan objects have the limit info on the base plan
        //// don't modify the scope plan
        var plan = $scope.plan;
        //if (plan.limits){
        //  _.extend(plan, _.omit(plan.limits, ['id', 'planId']));
        //}

        $scope.deductible = plan[deductibleKey];
        $scope.deductibleRx = plan[deductibleRxKey];
        $scope.oopMax = plan[oopMaxKey];
      }
    };
  }
  Config.$inject = ['config.paths', 'application.model'];


  angular.module('plan')
    .directive('planBasics', Config);

}());
(function(){

  function Factory($state, $filter, utils, subsidyService, translateService, planUtils, planSearch, planFilterService, PlanCard){

    /**
     * @name plan.detail.setup
     * @constructor
     */
    function Class(){}

    /**
     * @param {object} $scope
     * @param {health.app} applicationModel
     * @param {HealthPlan} planModel
     * @param {HealthPlan[]} plans
     * @param {boolean} [isRecommended=false]
     */
    Class.prototype.setup = function($scope, applicationModel, planModel, plans, isRecommended){

      var plan = angular.copy(planModel);
      var appData = applicationModel.get();
      var members = applicationModel.members;
      var visitsCosts = plan.benefits.visits || {};
      var isPersonal = true; //!!plan.mods;
      var isFamilyPlan = isPersonal && members.length > 1;
      var numberFilter = $filter('number');
      var indSuffix = 'Ind';
      var famSuffix = 'Fam';
      var deductibleKey = 'deductible' + (isFamilyPlan && famSuffix || indSuffix);
      var deductibleRxKey = 'deductiblerx' + (isFamilyPlan && famSuffix || indSuffix);
      var oopMaxKey = 'oopmax' + (isFamilyPlan && famSuffix || indSuffix);
      var networkQuality = Number(plan.networkQuality);
      var viewModel = {};
      var planListState = 'personalPlans.list';

      var planInfo = new PlanCard(plan, applicationModel);
      planInfo.setFullBenefits();
      // copy plan info into scope for now
      ['detailParams', 'userDocs', 'userDrugs', 'allAccepted', 'inNetCount',
      'visits', 'drugs', 'surgeries', 'pregnancies', 'oon', 'allDrugData']
        .forEach(function(key){
          $scope[key] = planInfo[key];
        });

      $scope.plan = plan;
      $scope.planCount = _.isArray(plans) && plans.length || 0;
      $scope.detailParams = planUtils.getDetailParams(plan);
      $scope.personal = isPersonal;
      $scope.recommended = !!isRecommended;
      $scope.isFamilyPlan = isFamilyPlan;
      $scope.networkQuality = isNaN(networkQuality) ? false : networkQuality;
      $scope.deductible = numberFilter(_.get(plan, deductibleKey) || _.get(plan, ['limits', deductibleKey]), 0);
      $scope.deductibleRx = numberFilter(_.get(plan, deductibleRxKey), 0);
      $scope.oopMax = numberFilter(_.get(plan, oopMaxKey), 0);

      $scope.hsaStatus = plan.hsaStatus;// && application.hsa.savings ? Math.min(plan.mods.totalCost, application.hsa.savings) : 0;
      $scope.viewModel = viewModel;
      $scope.costExpTokens = {
        deductibleAmount: $scope.deductible,
        oopAmount: $scope.oopMax,
        carrier: plan.carrier
      };

      $scope.healthApp = applicationModel;

      translateService.translate('planDetail')
        .then(function(){
          $state.current.data.pageTitle = plan.carrier + ' ' + plan.name;
          $state.current.data.pageDescription = plan.carrier + ' ' + plan.name + '; $' + $scope.deductible + ' Deductible; $' + $scope.oopMax + ' Max Out-of-Pocket';
        });


      $scope.filterOnAllDoctors = function(){
        planFilterService.activateFilters('doctors', _.pluck(plan.mods.providers.providersAccepted, 'id'));
        $state.go(planListState);
      };

      $scope.resetFilters = function(){
        planFilterService.reset();
        $state.go(planListState);
      };

      $scope.sortOnMyDocs = function(){
        planFilterService.reset();
        $state.go(planListState, { sort: 'mydocs' });
      };

      $scope.sortOnOopMax = function(){
        planFilterService.reset();
        $state.go(planListState, { sort: 'oopmax' });
      };

      $scope.goToDetails = function(){
        utils.toggleBool(viewModel, 'showDetails');
      };

      var visitDetailsKey = 'preventive';
      if (visitsCosts.ben_primary){
        if (visitsCosts.ben_primary.deductible === 'none'){
          visitDetailsKey = visitsCosts.ben_specialist.deductible === 'none' ? 'specialist' : 'primary';
        }
        else if (visitsCosts.ben_primary.preQty){
          visitDetailsKey = visitsCosts.ben_specialist.preQty ? 'specialistPre': 'primaryPre';
        }
      }


      $scope.visitDetailsKey = 'planDetail.visitDetails.' + visitDetailsKey;


      if (plan.mods){
        //$scope.providers = resourceHelper.getByType(appData, 'providers');
        $scope.coveredDocs = $filter('number')(plan.mods.providers.qtyNearby, 0) || 0;
        $scope.allAcceptedCount = _.filter(plans, planUtils.allDocsAccepted).length;
        $scope.oopMaxStats = planUtils.getMaxOopStats(plan, plans);

        var networkRank = planUtils.getNetworkCountRank(plan, plans);
        $scope.whyTokens = {
          premium: numberFilter(plan.mods.premiumYear, 0),
          oop: numberFilter(plan.mods.oop.totalOop, 0),
          forecast: numberFilter(plan.mods.allInForecast, 0),
          ordinalRank: $filter('shOrdinal')(plan.mods.ranks.strideRank + 1, 'en-US'),
          compareUrl: $state.href(planListState),
          planCount: plans.length,
          otherPlanCount: plans.length - 1,
          allAcceptedOtherPlanCount: $scope.allAcceptedCount - ($scope.allAccepted ? 1 : 0),
          acceptedCount: plan.mods.providers.totalAccepted,
          totalCount: plan.mods.providers.providersAccepted.length,
          networkRank: networkRank,
          ordinalNetworkRank: $filter('shOrdinal')(networkRank),
          networkCount: $filter('number')(plan.mods.providers.qtyNearby)
        };


        var services = plan.mods.forecasts.family.services;
        var runningTotal = 0;
        var forecastLineItems = {
          primary: ['primary'],
          specialist: ['specialist'],
          inpatient: ['inpatient'],
          outpatient: ['outpatient'],
          labs: ['labs', 'imaging']
          //other: ['other', 'er', 'mental', 'homehealth']
        };
        $scope.forecasts = _.map(forecastLineItems, function(valueArray, key){
          return {
            key: key,
            amount: _.reduce(valueArray, function (memo, value) {
              var amount = (services['ben_' + value] && services['ben_' + value].amount || 0);
              runningTotal += amount;
              return memo + amount;
            }, 0)
          };
        });
        $scope.forecasts.push({key: 'other', amount: plan.mods.oop.neighborsOop - runningTotal });

        subsidyService.getPenalty(appData.taxInfo && appData.taxInfo.income || 0, planUtils.getApplicantParams(members))
          .then(function(result){
            $scope.penalty = result;
          });

        $scope.jumpToCare = function(){
          var key = plan.mods.userDrugs.length ? 'scrollToDrugCosts' : 'scrollToCareCosts';
          utils.toggleBool(viewModel, key);
        };

        // queue up scenarios
        planSearch.getScenarios(plan, applicationModel);
      }


      $scope.render = true;
    };

    return Class;
  }
  Factory.$inject = [
    '$state',
    '$filter',
    'utils',
    'services.subsidy',
    'translate.service',
    'plan.utils',
    'plan.search',
    'plan.filter.service',
    'plan.card'];

  angular.module('plan')
    .factory('plan.detail.setup', Factory);
}());
(function () {

  /**
   * @name plan.detail.byIdCtrl
   * @param $state
   * @param $stateParams
   * @param {ng.$rootScope.Scope} $scope
   * @param {plan.detail.setup} DetailSetup
   * @param {health.app} HealthApp
   * @param {application.service} applicationService
   * @constructor
   */
  function Ctrl($state, $stateParams, $scope, DetailSetup, HealthApp, applicationService, userModel) {
    var self = this;
    var detailSetup = new DetailSetup();

    applicationService.get(userModel, $stateParams.appId)
      .then(function (ifp_app) {
        self.ifp_app = ifp_app;
        var app = new HealthApp();
        app.setFromDb(ifp_app);
        var plan = app.getPlan();
        detailSetup.setup($scope, app, plan, [plan], false);
      })
      .catch(function () {
        $state.replace('404');
      });
  }

  Ctrl.$inject = ['$state', '$stateParams', '$scope', 'plan.detail.setup', 'health.app', 'application.service', 'baseUser'];

  angular.module('plan')
    .controller('plan.detail.byIdCtrl', Ctrl);
}());
angular.module('plan')
  .directive('shPlanCopay', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        templateUrl: paths.partials + '/components/plan/plan-card/copay/copay.html'
      };
    }
  ]);
angular.module('plan')
  .directive('shPlanDoctors', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          planCard: '='
        },
        templateUrl: paths.partials + '/components/plan/plan-card/doctors/doctors.html'
      };
    }
  ]);
angular.module('plan')
  .directive('shPlanDrugs', [
    '$http',
    'config.paths',
    function($http, paths){
      return {
        scope: {
          planCard: '='
        },
        templateUrl: paths.partials + '/components/plan/plan-card/drugs/drugs.html'
      };
    }
  ]);
(function(){

  /**
   * @name visit.plan.benefitCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.Scope} $scope
   * @param {visit.service} visitService
   * @param {visit.plan.builder} planBuilder
   * @param {visit.plan.detail.service} detailService
   * @param {member.service} memberService
   * @param {services.tracking} trackingService
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($q, $state, $scope, visitService, planBuilder, detailService, memberService, trackingService, userModel){

    var self = this;
    var requestedKey = 'requested_benefits';
    var additionalKey = 'additional_services';
    var trackingPrefix = 'Visit Plans: Recommended services: Select ';
    var payload = planBuilder.getPayload();
    var isSelectedExpression = { selected: true };
    if (payload === null) {
      return;
    }

    this.benefits = [];
    this.services = [];

    // watch for user selection changes
    $scope.$watch(function(){ return planBuilder.getValue(requestedKey); }, setSelected);
    $scope.$watch(function(){ return planBuilder.getValue(additionalKey); }, setSelected);

    $q
      .all([
        visitService.getRecommendations(payload),
        visitService.getServices(payload.age, payload.gender, payload.visitType, payload.pregnant)
      ])
      .then(function(responses){
        self.benefits = responses[0];
        self.services = responses[1];

        planBuilder.setValue('recommended_benefits', getIdsWithStrength('recommended'));
        planBuilder.setValue('suggested_benefits', getIdsWithStrength('suggested'));

        setSelected();

        // persist the risk factors for the member
        var member = planBuilder.getValue('member');
        if (member){
          var riskFactors = payload.attributes;
          member.illnesses = payload.illnesses;
          member.tobacco = riskFactors.tobacco;
          memberService.saveMember(userModel, member);
        }
      });

    this.next = function(){
      trackingService.mixpanelEvent(trackingPrefix + 'Recommendations', {
        'Visit Type': planBuilder.getValue('type'),
        'Recommendations Available': planBuilder.getValue('recommended_benefits'),
        'Recommendations Selected': _.pluck(self.getSelected('recommended'), 'id')
      });
      $state.go($state.current.data.next);
    };

    this.save = function(state){
      planBuilder.setValue(requestedKey, _.pluck(_.where(self.benefits, isSelectedExpression), 'id'));
      planBuilder.setValue(additionalKey, _.pluck(_.where(self.services, isSelectedExpression), 'id'));

      trackingService.mixpanelEvent(trackingPrefix + 'Suggestions', {
        'Visit Type': planBuilder.getValue('type'),
        'Suggestions Available': planBuilder.getValue('suggested_benefits'),
        'Suggestions Selected': _.pluck(self.getSelected('suggested'), 'id')
      });

      $state.go(state || $state.current.data.next);
    };

    /**
     * @param {string} strength
     * @returns {number[]}
     */
    function getIdsWithStrength(strength){
      return _.pluck(_.where(self.benefits, { strength: strength }), 'id');
    }

    function setSelected(){
      var savedBenefits = planBuilder.getValue(requestedKey);
      //var savedServices = planBuilder.getValue(additionalKey);

      if (_.isArray(savedBenefits)){
        detailService.setSelectedBenefits(planBuilder.data, self.benefits);

        //_.each(self.benefits, function(benefit){
        //  benefit.selected = _.contains(savedBenefits, benefit.recommendation.id);
        //});
      }
      else {
        _.each(self.benefits, function(benefit){
          benefit.selected = true;
        });
      }

      detailService.setSelectedServices(planBuilder.data, self.services, self.benefits);
      //var savedBenefitServiceIds = _.chain(self.benefits)
      //  .where(isSelectedExpression)
      //  .map(mapServiceId)
      //  .value();
      //
      //_.each(self.services, function(service){
      //  service.selected = _.contains(savedServices, service.id) && !_.contains(savedBenefitServiceIds, service.id);
      //});

      self.selectedServices = _.where(self.services, isSelectedExpression);
    }

    this.getSelected = function(type){
      var selected = [];

      if (type === 'recommended' || type === 'suggested'){
        selected = _.where(self.benefits, { strength: type, selected: true });
      }
      else if (type === 'services'){
        selected = _.where(self.selectedServices, isSelectedExpression);
      }
      else {
        selected = _.where(self.benefits.concat(self.services), isSelectedExpression);
      }

      return selected;
    };
  }
  Ctrl.$inject = ['$q', '$state', '$scope', 'visit.service', 'visit.plan.builder', 'visit.plan.detail.service', 'member.service', 'services.tracking', 'baseUser'];

  angular.module('visit')
    .controller('visit.plan.benefitCtrl', Ctrl);
}());
(function(){

  function Config(paths){
    return {
      templateUrl: function($element, $attr){
        return paths.partials + ($attr.templateUrl || '/components/visit/plan/benefit/select.html');
      },
      scope: {
        benefit: '=benefitSelect',
        expandable: '=?'
      },
      link: function($scope){
        $scope.model =  {
          open: false
        };

        if (!_.isBoolean($scope.expandable)){
          $scope.expandable = true;
        }
      }
    };
  }
  Config.$inject = ['config.paths'];

  angular.module('visit')
    .directive('benefitSelect', Config);
}());
(function(){

  /**
   * @param {ui.router.state.$state} $state
   * @param {visit.plan.detail.service} detailService
   * @param {VisitPlanDetails} Details
   * @param {ifp_app} HealthContext
   * @constructor
   */
  function Ctrl($state, detailService, Details, HealthContext){
    var self = this;
    if (!Details){
      return $state.go('404');
    }

    self.details = detailService.details;

    // prefer health plan that is attached to the visit plan through ifp app
    // fall back to plan attached to the active app
    // there could be no active app as well if user has come through FTUX
    // so the UI should handle this case by not showing plan specific information
    self.health_plan = _.get(HealthContext, 'app_json.plan');

    self.getSelectedCount = function(type){
      return _.where(detailService.getBenefitType(type, self.details.benefits), { selected: true }).length;
    };

    self.getSelectedServices = function(){
      return _.where(self.details.services, { selected: true });
    };
  }
  Ctrl.$inject = ['$state', 'visit.plan.detail.service', 'Details', 'HealthContext'];

  angular.module('visit')
    .controller('visit.plan.detailCtrl', Ctrl);
}());
(function(){

  /**
   * @typedef {Object} VisitPlanDetails
   * @property {VisitPlan} plan
   * @property {Member} member
   * @property {doctor.model} doctor
   * @property {VisitBenefitRecommendation[]} benefits
   * @property {VisitBenefitService[]} services
   */


  /**
   * @name visit.plan.detail.service
   * @param {ng.$q} $q
   * @param {visit.service} visitService
   * @param {member.service} memberService
   * @param {doctor.service} doctorService
   * @param {date.service} dateService
   * @constructor
   */
  function Svc($q, visitService, memberService, doctorService, dateService){

    var self = this;
    var providerIdString = 'provider_id';
    /**
     * @name visit.plan.detail.service.details
     * @memberOf visit.plan.detail.service
     * @type {VisitPlanDetails}
     */
    this.details = {};

    /**
     * @name visit.plan.detail.service.getDetails Gets the fleshed out VisitPlan
     * @methodOf visit.plan.detail.service
     * @param {string} id
     * @returns {Promise<VisitPlanDetails>}
     */
    this.getDetails = function(id){

      return visitService.getPlan(id)
        .then(function(plan){
          self.details.plan = plan;
          self.details.member = plan.member;
          var providerRequest = plan[providerIdString] ? doctorService.getDetails(plan[providerIdString]) : null;

          return $q.all([
            providerRequest,
            visitService.getRecommendationsById(plan.recommended_benefits.concat(plan.suggested_benefits))
          ]);
        })
        .then(function(results){
          var member = self.details.member;
          self.details.doctor = results[0];

          var benefits = _.each(results[1], function(b){
            b.strength = _.contains(self.details.plan.recommended_benefits, b.id) ? 'recommended' : 'suggested';
          });

          self.setSelectedBenefits(self.details.plan, benefits);
          self.details.benefits = benefits;

          return visitService.getServices(member.age, member.gender, self.details.plan.type, member.risk_factors && member.risk_factors.pregnant);
        })
        .then(function(services){

          self.details.services = services;
          self.setSelectedServices(self.details.plan, services, self.details.benefits);
          //
          //console.log(_.where(services, { selected: true }));
          //
          //console.log(self.details);
          return self.details;
        });
    };

    /**
     * @param {number} [networkId]
     * @returns {Promise<VisitPlanDetails[]>}
     */
    this.getPlansWithDoctors = function(networkId){
      var details = [];

      return visitService.getPlans()
        .then(function(plans){
          details = _.map(plans, function(plan){
            return { plan: plan };
          });

          var providerIds = _.chain(plans)
            .filter(function(plan){ return _.isNumber(plan[providerIdString]); })
            .pluck(providerIdString)
            .uniq()
            .value();

          return doctorService.getDetails(providerIds, networkId);
        })
        .then(function(doctors){
          _.each(details, function(detail){
            if (detail.plan[providerIdString]){
              detail.doctor = _.findWhere(doctors, { id: detail.plan[providerIdString] });
            }
          });

          return details;
        });
    };

    /**
     *
     * @param {VisitPlan} visitPlan
     * @param {VisitBenefitRecommendation[]} benefits
     */
    this.setSelectedBenefits = function(visitPlan, benefits){
      _.each(benefits, function(benefit){
        benefit.selected = _.contains(visitPlan.requested_benefits, benefit.id);
      });
    };

    this.setSelectedServices = function(visitPlan, services, benefits){
      var savedBenefitServiceIds = _.chain(benefits)
        .where({ selected: true })
        .pluck('serviceId')
        .value();

      _.each(services, function(service){
        service.selected = _.contains(visitPlan.additional_services, service.id) && !_.contains(savedBenefitServiceIds, service.id);
      });
    };

    /**
     * @param {VisitPlan} visitPlan
     */
    this.setStatus = function(visitPlan){
      var status = 'incomplete';
      var appointmentDate = visitPlan.appointment_date;
      if (visitPlan[providerIdString] && appointmentDate){

        // ensure date strings are converted to date objects
        appointmentDate = dateService.getDate(appointmentDate);

        if (appointmentDate.getTime() < +new Date()){
          status = 'completed';
        }
        else {
          status = 'scheduled';
        }
      }

      visitPlan.status = status;
    };

    this.getStatus = function(visitPlan){
      if (!visitPlan){
        return 'notStarted';
      }

      if (!visitPlan[providerIdString] && visitPlan.ifp_app_id){
        return 'incomplete';
      }

      var appointmentDate = visitPlan.appointment_date;
      if (!appointmentDate){
        return 'notScheduled';
      }

      appointmentDate = dateService.getDate(appointmentDate);
      if (appointmentDate.getTime() > +new Date()){
        return 'scheduled';
      }

      return 'finished';
    };

    /**
     * @param {string} type
     * @param {VisitBenefit[]} [benefits]
     * @returns {VisitBenefitRecommendation[]}
     */
    this.getBenefitType = function(type, benefits){
      if (!_.isArray(benefits)){
        benefits = self.benefits;
      }

      return _.where(benefits, { strength: type });
    };
  }
  Svc.$inject = ['$q', 'visit.service', 'member.service', 'doctor.service', 'services.date'];

  angular.module('visit')
    .service('visit.plan.detail.service', Svc);
}());
(function(){

  function Ctrl($state, planBuilder, doctorService, trackingService){
    var self = this;
    var appointmentDateKey = 'appointment_date';
    var providerId = planBuilder.getValue('provider_id');
    var appointmentDate = planBuilder.getValue(appointmentDateKey);
    var now = new Date();
    var minDate = new Date();
    var maxDate = new Date();
    maxDate.setYear(now.getFullYear() + 1);

    // need to see if appointment date is in the past
    if (_.isDate(appointmentDate)){
      // if so, make sure min date allows for it to be valid
      if (now.getTime() > appointmentDate.getTime()){
        minDate = appointmentDate;
      }
    }
    // if it hasn't been scheduled yet, default to next week
    else {
      now.setDate(now.getDate() + 7);
      appointmentDate = now;
    }

    /** @type {Date} **/
    this.date = appointmentDate;
    self.doctor = planBuilder.getValue('doctor');
    self.dateRange = [minDate, maxDate];

    if (!self.doctor && providerId){
      doctorService.getDetails(providerId)
        .then(function(doctor){
          self.doctor = doctor;
        });
    }

    this.done = function(){
      planBuilder.setValue(appointmentDateKey, self.date);
      trackingService.mixpanelEvent('Visit Plans: Scheduling a date: Date Scheduled', {
        'Visit Type': planBuilder.getValue('type'),
        'Date Selected': self.date.toISOString()
      });

      trackingService.setPeopleProps({ 'Has Scheduled Visit Plan': true }, true);
      $state.go($state.current.data.next);
    };
  }
  Ctrl.$inject = ['$state', 'visit.plan.builder', 'doctor.service', 'services.tracking'];

  angular.module('visit')
    .controller('visit.plan.dateCtrl', Ctrl);
}());
(function(){

  /**
   * @name visit.plan.doctorCtrl
   * @param {doctor.service} doctorService
   * @param {visit.plan.builder} planBuilder
   * @param {user.model} userModel
   * @param {ifp_app} ActiveHealth
   */
  function Ctrl(doctorService, planBuilder, userModel, ActiveHealth){
    var self = this;
    var member = planBuilder.getValue('member');

    if (!member || !member.id){
      return;
    }

    this.visitType = planBuilder.getValue('type');
    this.ifp_app = planBuilder.getValue('ifp_app') || ActiveHealth;
    doctorService.getMergedForMember(userModel, member.id, _.get(ActiveHealth, 'app_json.plan.networkId'))
      .then(function(doctors){
        self.doctors = _.pluck(_.filter(doctors, function(doctor){
          return _.get(doctor, 'details.networkStatus.inNetwork');
        }), 'details');
      });
  }
  Ctrl.$inject = ['doctor.service', 'visit.plan.builder', 'baseUser', 'ActiveHealth'];

  angular.module('visit')
    .controller('visit.plan.doctorCtrl', Ctrl);
}());
(function(){

  /**
   * @name visit.plan.editCtrl
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.Scope} $scope
   * @param {visit.plan.builder} planBuilder
   * @param {visit.plan.detail.service} detailService}
   * @constructor
   */
  function Ctrl($state, $scope, planBuilder, detailService){
    if (!detailService.details){
      return;
    }

    planBuilder.fromDetails(detailService.details);
    var self = this;
    var id = planBuilder.getValue('id');
    var requestedKey = 'requested_benefits';
    var additionalKey = 'additional_services';
    var selectedExpression = { selected: true };


    this.getType = detailService.getBenefitType;
    // need to bind to this in the view
    this.getValue = planBuilder.getValue.bind(planBuilder);
    this.data = planBuilder.data;

    $scope.$watch(function(){ return self.data[requestedKey]; }, setSelected);
    $scope.$watch(function(){ return self.data[additionalKey]; }, setSelected);

    this.editServices = function(){
      self.saveAll();
      $state.go('.services');
    };

    this.done = function(){
      self.saveAll();
      var changed = planBuilder.changed();

      planBuilder.finish()
        .then(function(){
          if (changed){
            return detailService.getDetails(id);
          }
        })
        .then(function(){
          planBuilder.clear();
          $state.go('^');
        });
    };

    this.saveAll = function(){
      var selectedBenefits = _.where(detailService.details.benefits, selectedExpression);
      var selectedServices = _.where(detailService.details.services, selectedExpression);

      planBuilder.setValue(requestedKey, _.pluck(selectedBenefits, 'id'));
      planBuilder.setValue(additionalKey, _.pluck(selectedServices, 'id'));
    };

    function setSelected(){
      detailService.setSelectedBenefits(planBuilder.data, detailService.details.benefits);
      detailService.setSelectedServices(planBuilder.data, detailService.details.services, detailService.details.benefits);

      self.selectedServices = _.where(detailService.details.services, selectedExpression);
    }
  }
  Ctrl.$inject = ['$state', '$scope', 'visit.plan.builder', 'visit.plan.detail.service'];

  angular.module('visit')
    .controller('visit.plan.editCtrl', Ctrl);
}());
(function(){

  function Config(paths, detailService){
    return {
      templateUrl: paths.partials + '/components/visit/plan/status/directive.html',
      scope: {
        plan: '=visitPlanStatus'
      },
      link: function($scope){

        var status = detailService.getStatus($scope.plan);
        var color = 'alert';

        switch (status){
          case 'incomplete':
          case 'notScheduled':
            color = 'warn';
            break;
          case 'scheduled':
          case 'finished':
            color = 'success';
            break;
        }

        $scope.status = status;
        $scope.color = color;
      }
    };
  }
  Config.$inject = ['config.paths', 'visit.plan.detail.service'];

  angular.module('visit')
    .directive('visitPlanStatus', Config);
}());
(function(){

  /**
   * @param {Object} $stateParams
   * @param {routes.borPreFunnel.config} preFunnelConfig
   * @constructor
   */
  function Ctrl($stateParams, preFunnelConfig){
    this.source = preFunnelConfig.accountSource[$stateParams.type];
    console.log(this.source);
  }
  Ctrl.$inject = ['$stateParams', 'routes.borPreFunnel.config'];

  angular.module('routes.borPreFunnel')
    .controller('routes.borPreFunnel.detailsCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.borPreFunnel.questionsCtrl
   * @param {ui.router.state.$state} $state
   * @param {ui.router.state.$stateParams} $stateParams
   * @param borPreFunnelService
   * @param trackingService
   */
  function Ctrl($state, $stateParams, borPreFunnelService, trackingService) {
    var self = this;
    this.model = {};

    var translateKey = 'brokerOfRecord.' + $stateParams.type + '.questions';

    getQuestions(translateKey);

    this.goToQuestionList = function () {
      getQuestions(translateKey);
      this.showQuestionList = true;
    };

    this.goToQuestionPage = function () {
      // Save the selected questions to the service
      borPreFunnelService.saveSelectedQuestions(self.selectedQuestions);
      this.showQuestionList = false;
    };

    this.cancel = function () {
      this.selectedQuestions = borPreFunnelService.getSelectedQuestions();
      this.showQuestionList = false
    };

    this.next = function () {
      // Grab custom question from model if present
      borPreFunnelService.saveCustomQuestion(this.model.customQuestion);

      // Log selected questions
      var trackingQuestions = _.pluck(borPreFunnelService.getSelectedQuestions(), 'text');
      trackingService.mixpanelEvent(trackingService.propEnum.bor.questions.selected, {'Questions': trackingQuestions});

      // Log custom question
      if (this.model.customQuestion) {
        trackingService.mixpanelEvent(trackingService.propEnum.bor.questions.custom, {'Question': this.model.customQuestion});
      }

      $state.go('borPreFunnel.details');
    };

    // Get questions
    function getQuestions(translateKey) {
      borPreFunnelService.getQuestions(translateKey)
        .then(function (response) {
          if (!response) {
            $state.replace('home');
          }
          // Make a copy of all the questions
          self.allQuestions = angular.copy(response);

          // Create array of selected questions using the keys saved in the service
          var serviceSelected = borPreFunnelService.getSelectedQuestions();

          self.selectedQuestions = _.filter(self.allQuestions, function (q) {
            return !!_.findWhere(serviceSelected, {key: q.key});
          });

        });
    }

    this.toggleQuestion = function (item) {
      var index = self.selectedQuestions.indexOf(item);

      if (index > -1) {
        self.selectedQuestions.splice(index, 1);
      }
      else {
        self.selectedQuestions.push(item);
      }
    };

    this.removeQuestion = function (item) {
      var index = self.selectedQuestions.indexOf(item);
      if (index > -1) {
        self.selectedQuestions.splice(index, 1);
      }
      borPreFunnelService.saveSelectedQuestions(self.selectedQuestions);
    };
  }

  Ctrl.$inject = ['$state', '$stateParams', 'borPreFunnel.service', 'services.tracking'];

  angular.module('routes.getStarted')
    .controller('routes.borPreFunnel.questionsCtrl', Ctrl);
}());
(function(){

  /**
   * @typedef {Object} routes.bor.landing.marketingType
   * @property {string} heroImg
   * @property {string} heroTitle
   * @property {string} heroSub
   */

  /**
   * @type {Object<string, routes.bor.landing.marketingType>}
   */
  var typeConfig = {
    'insurance-coverage': {
      heroBg: 'https://images.contentful.com/heg7gyzix6dq/6IlCOfuOByaEUmEEW6KK6s/abe85996d365f394a6b38f99a11b6c94/bg-hero-stream.jpg?w=1600',
      heroBgPosition: 'top center',
      heroTitle: 'What does your health insurance <em>actually</em> cover?',
      heroSub: 'Find out if your plan covers procedures you need, like regular checkups and specialist care',
      heroCta: 'Find out now',
      footerTitle: 'Learn exactly what your plan covers. It\'s totally free.',
      footerCta: 'Find out now'
    },
    'medical-bill': {
      heroBg: 'https://images.contentful.com/heg7gyzix6dq/69ucmfCAw0AAmmIK02miwe/b7fdc25326c2c0a7eb2cd9c69a70e11b/bg-hero-paperwork.jpg?w=1600',
      heroBgPosition: 'top center',
      heroTitle: 'How much will your doctor visit cost?',
      heroSub: "Stride will help you determine how much you'll pay for doctors visits, medications, services, and more.",
      heroCta: 'Find out now (3 min)',
      footerTitle: 'Double check your bill, for free',
      footerCta: 'Get started'
    }
  };

  /**
   * @name routes.bor.landing.marketingCtrl
   * @param {ui.router.state.$state} $state
   * @param {Object} $stateParams
   */
  function Ctrl($state, $stateParams, trackingService){
    this.typeConfig = typeConfig[$stateParams.type];

    if (!this.typeConfig){
      return $state.replace('home');
    }

    var stateData = $state.getData();
    trackingService.trackLP(stateData.pageViewName);
  }
  Ctrl.$inject = ['$state', '$stateParams', 'services.tracking'];

  angular.module('routes.bor.landing')
    .controller('routes.bor.landing.marketingCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.borFunnel.accountCtrl
   * @memberOf routes.borFunnel
   * @param $state
   * @param $stateParams
   * @param $scope
   * @param userService
   * @param borFunnelService
   * @param currentApp
   * @param userModel
   * @param logger
   * @constructor
   */
  function Ctrl($state, $stateParams, $scope, userService, borFunnelService, currentApp, userModel, logger) {
    var self = this;
    var lock = false;

    var existingUser = $stateParams.user;

    var resetEmail = borFunnelService.get('resetSent');
    if (resetEmail) {
      existingUser = resetEmail;
      borFunnelService.set('resetSent', false);
    }

    this.error = {};
    this.model = {
      username: existingUser || ''
    };

    this.resetModel = {
      resetSent: resetEmail
    };

    self.error.key = borFunnelService.get('borFunnelError');
    borFunnelService.set('borFunnelError', null);

    /**
     * Login to account
     * @param form
     */
    this.login = function (form) {
      self.resetModel.resetSent = false;

      if (form.$valid && !lock) {
        lock = true;

        userModel.login(self.model.username, self.model.password)
          .then(function (response) {
            if (response) {
              onSuccess(response);
            } else {
              lock = false;
              self.error.key = 'user.errors.invalidLogin';
            }
          })
          .catch(onError);
      }
    };
    $scope.login = this.login;

    /**
     * Create account
     * @param form
     * @returns {*}
     */
    this.create = function (form) {
      if (!lock) {
        lock = true;
        return userService.createFromForm(self.model.username, self.model.password, userModel, currentApp, form)
          .then(function (response) {
            return onSuccess(response, true);
          })
          .catch(onError);
      }
    };
    $scope.create = this.create;

    /**
     * Password reset request
     * @name routes.borFunnel.esignCtrl.requestReset
     * @methodOf routes.borFunnel.esignCtrl
     * @param form
     */
    this.requestReset = function (form) {
      if (form.$valid) {
        userService.requestResetPassword(self.resetModel.email)
          .then(function (response) {
            //$scope.requestSent = true;
            if (response && response.data) {
              if (response.data.status === 'ERROR') {
                $scope.submitError = response.data.message;
              } else {
                borFunnelService.set('resetSent', self.resetModel.email);
                $state.go('borFunnel.account.login');
              }
            }
          });
      }
    };

    function onSuccess(userInfo, created) {
      lock = false;

      borFunnelService.save('memberId', userModel.primaryMemberId);

      // Post
      return borFunnelService.postInfo(userModel, created)
        .then(function (response) {
          if (response) {
            $state.go('borFunnelcomplete', {
              entry: $stateParams.borsource,
              carrierName: _.get(response, 'data.carrier_brand_name')
            });
          }
        })
        .catch(function (err) {
          //Log error
          logger.error({
            err: err && err.message || err
          });
        });
    }

    function onError(error) {
      lock = false;
      if (error.message === 'user already exists') {
        // Show login view and show error message
        borFunnelService.set('borFunnelError', 'user.existingUser');
        $state.go('borFunnel.account.login', {user: self.model.username});
      } else {
        self.error.key = 'user.errors.create';
      }
    }

  }

  Ctrl.$inject = ['$state', '$stateParams', '$scope', 'user.service', 'borFunnel.service', 'baseHealthApp', 'baseUser', 'logger'];

  angular.module('routes.borFunnel')
    .controller('routes.borFunnel.accountCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.borFunnel.identityCtrl
   * @memberOf routes.borFunnel
   * @param $state
   * @param $stateParams
   * @param borFunnelService
   * @param trackingService
   * @param alertService
   * @returns {*}
   * @constructor
   */
  function Ctrl($scope, $state, $stateParams, borFunnelService, trackingService, alertService) {
    var self = this;
    this.model = {};

    // If it's a different session, boot to the 1st step
    if (!borFunnelService.getBorInfo()) {
      return $state.replace('^.insuranceCompany');
    }

    var names = [
      'Anna',
      'Astrid',
      'Jenny',
      'Katie',
      'Megan',
      'Monika',
      'Sayre',
      'Subha'
    ];

    var data = borFunnelService.getBorInfo();
    alertService.setMessage({
      key: 'brokerOfRecord.source.' + $stateParams.borsource + '.identity.alert',
      model: {
        name: _.sample(names),
        carrier: data.carrierInfo.name,
        city: data.location.city
      }
    });
    $scope.$on('$destroy', alertService.clear);

    /**
     * Saves user input and goes to next step
     * @name routes.borFunnel.identityCtrl.track
     * @methodOf routes.borFunnel.identityCtrl
     */
    this.next = function () {
      var keys = _.keys(self.model);
      _.each(keys, function (key) {
        borFunnelService.save(key, self.model[key]);
      });
      $state.goNext();
    };

    /**
     * Mixpanel logging when user selects a radio button
     * @name routes.borFunnel.identityCtrl.track
     * @methodOf routes.borFunnel.identityCtrl
     * @param method
     */
    this.track = function (method) {
      var actionType = method === 'ssn' ? 'SSN' : 'Member ID';
      trackingService.mixpanelEvent(trackingService.propEnum.bor.funnel.action, {'Action': actionType + ' radio button selected'});
    };
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'borFunnel.service', 'services.tracking', 'services.alert'];

  angular.module('routes.borFunnel')
    .controller('routes.borFunnel.identityCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.borFunnel.esignCtrl
   * @memberOf routes.borFunnel
   * @param $state
   * @param $stateParams
   * @param borFunnelService
   * @param currentApp
   * @param userModel
   * @returns {*}
   * @constructor
   */
  function Ctrl($scope, $state, $stateParams, borFunnelService, currentApp, userModel, alertService) {
    var self = this;
    this.model = {};
    this.resetModel = {};
    this.error = {};
    var source = $stateParams.borsource;

    var primary = currentApp.getPrimary();
    if (primary && primary.name) {
      this.model.signature = {
        firstValue: primary.name.first,
        lastValue: primary.name.last
      };
    }

    // If it's a different session, boot to the 1st step
    if (!borFunnelService.getBorInfo()) {
      return $state.replace('^.insuranceCompany');
    }

    var age = borFunnelService.getBorInfo().age;
    alertService.setMessage({
      key: 'brokerOfRecord.source.' + $stateParams.borsource + '.signup.alert',
      model: {
        age: age,
        type: age < 35 ? 'Blood Pressure Screening' : 'Cholesterol Screening'
      }
    });
    $scope.$on('$destroy', alertService.clear);

    /**
     * On next, this function does account create if user is not logged in and then submits the esign
     * @name routes.borFunnel.esignCtrl.next
     * @methodOf routes.borFunnel.esignCtrl
     */
    this.next = function () {
      if (!borFunnelService.getBorInfo()) {
        return $state.replace('^.insuranceCompany');
      }

      // Save esign to service
      borFunnelService.save('signatureFirstName', self.model.signature.firstValue);
      borFunnelService.save('signatureLastName', self.model.signature.lastValue);
      borFunnelService.save('source', source);

      if (userModel.isLoggedIn) {
        borFunnelService.save('memberId', userModel.primaryMemberId);

        // Do the post
        borFunnelService.postInfo(userModel)
          .then(function (response) {
            $state.go('borFunnelcomplete', {entry: source, carrierName: _.get(response, 'data.carrier_brand_name')});
          })
      } else {
        if (source === 'drive') {
          $state.go('borFunnel.account.login');
        } else {
          $state.go('borFunnel.account.create');
        }
      }
    };
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'borFunnel.service', 'baseHealthApp', 'baseUser', 'services.alert'];

  angular.module('routes.borFunnel')
    .controller('routes.borFunnel.esignCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.borFunnel.insuranceCtrl
   * @memberOf routes.borFunnel
   * @param $state
   * @param $stateParams
   * @param trackingService
   * @param borFunnelService
   * @param geoSearch
   * @param carrierSearch
   * @param alertService
   * @constructor
   */
  function Ctrl($scope, $state, $stateParams, trackingService, borFunnelService, geoSearch, carrierSearch, alertService) {
    var self = this;
    this.model = {};

    alertService.setMessage({
      key: 'brokerOfRecord.source.' + $stateParams.borsource + '.insurance.alert'
    });
    $scope.$on('$destroy', alertService.clear);

    /**
     * Goes to next step and saves inputted information
     * @name routes.borFunnel.insuranceCtrl.next
     * @methodOf routes.borFunnel.insuranceCtrl
     */
    this.next = function () {
      borFunnelService.init();
      borFunnelService.save('location', self.model.location);
      borFunnelService.save('carrierInfo', self.model.carrier);
      $state.goNext()
    };

    /**
     * Gets carriers from zipcode
     * @name routes.borFunnel.insuranceCtrl.getCarriers
     * @methodOf routes.borFunnel.insuranceCtrl
     */
    this.getCarriers = function () {
      self.validZip = false;

      geoSearch.getByZip(self.zipcode)
        .then(function (list) {
          if (!list.length) {
            self.validZip = false;
            return;
          }

          self.validZip = true;
          self.locations = list;

          // Log when there's a valid zipcode entered
          trackingService.mixpanelEvent(trackingService.propEnum.bor.funnel.action, {'Action': self.zipcode});


          if (list.length === 1) {
            self.model.location = list[0];
            return carrierSearch.getBrands(list[0]);
          }
        })
        .then(function (response) {
          self.carriers = response;
        })
        .catch(function () {
          self.carriers = [];
        });
    };

    /**
     * Get carriers when county is selected
     * @name routes.borFunnel.insuranceCtrl.setGeo
     * @methodOf routes.borFunnel.insuranceCtrl
     * @param location
     */
    this.setGeo = function (location) {
      carrierSearch.getBrands(location)
        .then(function (response) {
          self.carriers = response;
        });
    };

    /**
     * Mixpanel logging of carrier selected
     * @name routes.borFunnel.insuranceCtrl.trackSelected
     * @methodOf routes.borFunnel.insuranceCtrl
     * @param carrier
     */
    this.trackSelected = function (carrier) {
      trackingService.mixpanelEvent(trackingService.propEnum.bor.funnel.action, {'Action': carrier.name});
    };
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'services.tracking', 'borFunnel.service', 'search.geo', 'search.carriers', 'services.alert'];

  angular.module('routes.borFunnel')
    .controller('routes.borFunnel.insuranceCtrl', Ctrl);
}());
(function(){
  function Ctrl($state, $scope, translateService){
    $scope.cards = [];
    translateService.translate('brokerOfRecord.introCards').then(function(res){
      $scope.cards = res;
      $scope.render = true;
    });
    $scope.cardIndex = 0;

    $scope.isLastCard = function(){
      return $scope.cardIndex === $scope.cards.length -1;
    }

    $scope.incrementCardIndex = function(e){
      e.stopPropagation();
      e.preventDefault();
      if($scope.isLastCard()){
        window.location.href = '/link-insurance/ad';
        //$state.go("borFunnel", { borsource: 'ad' });
        return;
      }
      $scope.cardIndex = ($scope.cardIndex + 1) % 4;
    }

    $scope.getProp = function(prop){
      return $scope.cards[$scope.cardIndex][prop];
    }

  }
  Ctrl.$inject = ['$state', '$scope', 'translate.service'];
  angular.module('routes.borFunnel')
         .controller('routes.borFunnel.infoCardsCtrl', Ctrl)
}());

(function(){

  /**
   * @name routes.dashboard.doctor.searchCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {user.model} userModel
   * @param {ifp_app} ActiveHealth
   * @constructor
   */
  function Ctrl($scope, DoctorSearchModel, userModel, ActiveHealth){
    var networkId = _.get(ActiveHealth, 'app_json.plan.networkId');

    this.model = new DoctorSearchModel({ inNetwork: _.isNumber(networkId), patientNetwork: networkId });
    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));
  }
  Ctrl.$inject = ['$scope', 'doctor.search.model', 'baseUser', 'ActiveHealth'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.doctor.searchCtrl', Ctrl);
}());
(function () {
  /**
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.scope} $scope
   * @param {doctor.results.model} DoctorResultsModel
   * @param {doctor.service} doctorService
   * @param {services.tracking} trackingService
   * @param {user.model} userModel
   * @param {Member} PrimaryMember
   * @param {doctor.response.merged[]} UserDoctors
   * @constructor
   */
  function Ctrl($state, $scope, DoctorResultsModel, doctorService, trackingService, userModel, PrimaryMember, UserDoctors) {
    var stateData = $state.current.data || {};
    var settings = _.extend({}, stateData.settings);
    settings.omitted = _.map(UserDoctors, function(doc){ return _.get(doc, 'provider.provider_id'); });

    settings.onClick = function (result) {
      return doctorService.addForMember(userModel, PrimaryMember.id, result.id)
        .then(function () {
          trackingService.incrementPeopleProp(trackingService.propEnum.doctorAdd);
          doctorService.searchTerm = '';
          $state.go('dashboard.care.doctors', {}, {reload: true});
        });
    };

    this.model = new DoctorResultsModel(settings);
    this.model.watchResults($scope);
  }

  Ctrl.$inject = ['$state', '$scope', 'doctor.results.model', 'doctor.service', 'services.tracking', 'baseUser', 'PrimaryMember', 'UserDoctors'];

  angular.module('routes.dashboard')
    .controller('routes.dashboard.doctor.resultsCtrl', Ctrl);
}());
(function(){
  /**
   * @name routes.dashboard.health.activateCtrl
   * @param {ui.router.state.$state} $state
   * @param {ifp_app} App
   * @param {application.service} applicationService
   * @param {user.model} userModel
   * @param {services.tracking} trackingService
   * @constructor
   */
  function ActivateCtrl($state, App, applicationService, userModel, trackingService){
    this.app = App;

    this.activate = function(){
      applicationService.setActive(userModel, App.app_id, 'health')
        .then(function(){
          userModel.setActiveHealth(App);
          trackingService.mixpanelEvent('Plan action', { Action: 'Make active' });
          $state.go('^');
        })
        .catch(function(err){
          $state.go('500');
        });
    };
  }
  ActivateCtrl.$inject = ['$state', 'App', 'application.service', 'baseUser', 'services.tracking'];


  angular.module('routes.dashboard.health')
    .controller('routes.dashboard.health.activateCtrl', ActivateCtrl);
}());
//(function(){
//  /**
//   * @name routes.dashboard.health.deleteCtrl
//   * @param {ui.router.state.$state} $state
//   * @param {ifp_app} App
//   * @param {Resource} appResource
//   * @param {user.model} userModel
//   * @param {dashboard.service} dashboardService
//   * @constructor
//   */
//  function Delete($state, App, appResource, userModel, dashboardService){
//    this.app = App;
//    this.isActiveHealth = _.get(userModel, 'activeHealth.app_id') === App.app_id;
//
//    this.delete = function(){
//      if (this.isActiveHealth){
//        return;
//      }
//
//      appResource.delete({ app_id: App.app_id }).$promise
//        .then(function(){
//          return appResource.query({ types: 'health,bor', is_complete: true }).$promise;
//        })
//        .then(function(apps){
//          dashboardService.completedHealthApps = apps;
//        })
//        .then(function(){
//          $state.go('^');
//        })
//        .catch(function(err){
//          $state.go('500');
//        });
//    };
//  }
//  Delete.$inject = ['$state', 'App', 'resources.application', 'baseUser', 'dashboard.service'];
//
//
//  angular.module('routes.dashboard.health')
//    .controller('routes.dashboard.health.deleteCtrl', Delete);
//}());
(function(){
  /**
   * @name routes.dashboard.health.listCtrl
   * @param {ng.$rootScope.Scope} $scope
   * @param {user.model} userModel
   * @param {dashboard.service} dashboardService
   * @constructor
   */
  function ListCtrl($scope, userModel, dashboardService){
    this.filterApps = function(){
      var activeId = _.get(userModel, 'activeHealth.app_id');
      this.oldApps = _.reject(this.apps, function(app){
        return activeId === app.app_id;
      }).sort(function(a,b){
        return +new Date(a.submitted_on) < +new Date(b.submitted_on);
      });
    };

    this.setApps = function(apps){
      this.apps = apps;
      this.filterApps();
      this.render = true;
    };

    //
    //this.getApps = function(){
    //  applicationResource.query({ types: 'health,bor', is_complete: true }).$promise
    //    .then(_.bind(this.setApps, this))
    //    .then(function(){
    //      self.render = true;
    //    });
    //};

    //this.getApps();
    $scope.$watch(function(){ return dashboardService.completedHealthApps; }, _.bind(this.setApps, this));
    $scope.$watch(function(){ return userModel.activeHealth; }, _.bind(this.filterApps, this));
  }
  ListCtrl.$inject = ['$scope', 'baseUser', 'dashboard.service'];


  angular.module('routes.dashboard.health')
    .controller('routes.dashboard.health.listCtrl', ListCtrl);
}());
(function () {

  /**
   */
  function Ctrl($state, $scope, $stateParams, DentalPlans, DentalApp, applicationService, dentalService,
                doctorService, trackingService, userModel) {
    var self = this;

    // Find dental plan selected
    this.selectedPlanId = $stateParams.id;

    var selectedPlan = _.find(DentalPlans, function (plan) {
      return plan.plan.id === self.selectedPlanId;
    });
    this.plan = selectedPlan;

    //dentalService.getDetailGroupValues(this.selectedPlanId)
    //  .then(function (response) {
    //    self.groupValueMap = response;
    //  });

    dentalService.getDetailGroups(this.selectedPlanId)
      .then(function (response) {
        self.benefitGroups = response;
      });

    // User has selected to purchase this plan and we need to add to the app
    this.pickPlan = function () {
      applicationService.postPlan(userModel, DentalApp.app_id, this.plan.plan)
        .then(function () {
          if (userModel.isLoggedIn) {
            return $state.go('cart');
          }

          return $state.go('planAccount.create', {source: 'dental-buy'});
        });
      //dentalPlanResource.save({
      //  appId: DentalAppId,
      //  planId: this.plan.plan.id,
      //  carrierId: this.plan.plan.carrierId,
      //  premium: this.plan.totalMonthlyPremium,
      //  plan: this.plan.plan
      //}).$promise
      //  .then(function (response) {
      //    $state.go('cart');
      //    //$state.go('dental.plans.overview');
      //  });
    };

    doctorService.getDetails(_.pluck(DentalApp.member_providers, 'provider_id'), this.plan.plan.networkId)
      .then(function (providers) {
        self.dentists = providers;

        var params = {};
        params.state = DentalApp.address.state;
        params.region = DentalApp.address.region;
        params.countyFips = DentalApp.address.county_fips;
        params.productType = 'dental';
        return doctorService.getNetworkStats(_.pluck(providers, 'id'), params);
      })
      .then(function (response) {
        self.inNetworkCount = _.where(response.providers, {networkCount: 3}).length;

        //Mixpanel
        trackingService.mixpanelEvent(trackingService.propEnum.dentalDetail, {
          'In Network': self.inNetworkCount > 0
        });
      });

    //Mixpanel
    trackingService.mixpanelEvent(trackingService.propEnum.dentalDetail, {
      'Plan Name': selectedPlan.plan.name,
      'Premium': selectedPlan.totalMonthlyPremium
    });

    $scope.render = true;
  }

  Ctrl.$inject = ['$state', '$scope', '$stateParams', 'DentalPlans', 'DentalApp',
    'application.service', 'dental.service', 'doctor.service', 'services.tracking', 'baseUser'];

  angular.module('routes.dental')
    .controller('routes.dental.plan.detail.controller', Ctrl);
}());

(function () {

    /**
     * @param {ui.router.state.$state} $state
     * @param {user.model} userModel
     * @param {*[]} DentalPlans
     * @param {ifp_app} DentalApp
     * @param {application.service} applicationService
     * @constructor
     */
    function Ctrl($state, userModel, DentalPlans, DentalApp, applicationService) {
      this.dentalPlans = DentalPlans || [];

      var wordNumbers = {
        1: 'one',
        2: 'two',
        3: 'three'
      };
      this.numPlans = wordNumbers[this.dentalPlans.length];

      this.pickPlan = function (plan) {
        $state.go('.detail', {id: plan.plan.id});
      };

      this.removeDental = function () {
        applicationService.deletePlan(userModel, DentalApp.app_id)
          .then(function() {
            $state.go('cart');
          });
      };
    }

    Ctrl.$inject = ['$state', 'baseUser', 'DentalPlans', 'DentalApp', 'application.service'];

    angular.module('routes.dental')
      .controller('routes.dental.plan.controller', Ctrl);
  }()
);
(function () {

  /**
   * @name profile.guided.controller
   * @param $q
   * @param $state
   * @param userModel
   * @param applicationModel
   * @param StartYear
   * @param memberService
   * @constructor
   */
  function Ctrl($q, $state, userModel, applicationModel, StartYear, memberService, financeService, utils) {

    var self = this;

    this.year = StartYear;
    this.appMembers = [];
    this.allMembers = [];

    financeService.getForAppAsync(applicationModel.getId());
    // financeService.saveMembersByType(null, null);

    // Household size
    self.householdSize = applicationModel.get().taxInfo.familySize;

    // Boot user to start of guided flow if member demos aren't valid
    if (!applicationModel.hasValidDemos()) {
      $state.replace('ob.savings.estimate');
    }

    memberService.getMemberSet(userModel, applicationModel.getId())
      .then(function (response) {
        self.allMembers = response.allMembers;

        // Add only the coverage members to appMembers array for now
        self.appMembers = _.filter(response.appMembers, function (appMember) {
          return _.get(appMember, 'member_application.type') === 'coverage';
        });

        if (self.allMembers.length < self.householdSize) {
          self.showAddMemberDetails = true;
          return $q.reject('Number of all members is less than household size');
        } else if (self.appMembers.length === self.householdSize) {
          addStatusToMembers(self.appMembers);
          return applicationModel.saveMembers(userModel, self.appMembers);
        } else if (self.allMembers.length > self.householdSize) {
          self.showSelectHouseholdMembers = true;
          return $q.reject('Household size is smaller than number of members');
        }
      })
      .then(function () {
        return $state.replace('ob.savings.guided.source', {sourceIndex: 0});
      });

    function addStatusToMembers(memberArray) {
      _.each(memberArray, function (member) {
        var existingStatus = _.get(member, 'member_application.type');
        if (existingStatus) {
          member.status = existingStatus;
        } else {
          member.status = 'household';
        }
      });
    }

    /**
     * Verifies the number of selected members matches household size
     * @name profile.guided.controller.checkNumSelected
     * @methodOf profile.guided.controller
     * @returns {boolean}
     */
    this.checkNumSelected = function () {
      return householdSize !== self.appMembers.length;
    };

    /**
     * Goes to the next step and saves the selected members as in the household
     * @name profile.guided.controller.selectMembers
     * @methodOf profile.guided.controller
     */
    this.selectMembers = function () {
      if (self.appMembers.length !== self.householdSize) {
        self.error = 'Please select ' + self.householdSize + ' household members';
        return;
      }

      addStatusToMembers(self.appMembers);
      applicationModel.saveMembers(userModel, self.appMembers)
        .then(function () {
          $state.replace('ob.savings.guided.source', {sourceIndex: 0});
        });
    };

    /**
     * Toggles the member to be in or out of household
     * @name profile.guided.controller.toggleMember
     * @methodOf profile.guided.controller
     * @param member
     */
    this.toggleMember = function (member) {
      self.error = null;
      var memberIndex = _.findIndex(self.appMembers, {id: member.id});

      // If the member is in app members
      if (memberIndex > -1) {
        self.appMembers.splice(memberIndex, 1);
      } else if (self.appMembers.length >= self.householdSize) {
        self.error = 'Please select only ' + self.householdSize + ' household members';
      } else {
        // If the member is not in app members, add to app members
        self.appMembers.push(member);
      }
    };

    /**
     * Checks if the member is added to the list of household members
     * In this case it's the appMembers array
     * @name profile.guided.controller.isAdded
     * @methodOf profile.guided.controller
     * @param member
     * @returns {boolean}
     */
    this.isAdded = function (member) {
      return !!_.findWhere(self.appMembers, {id: member.id});
    };

    /**
     * Checks if the member is of status 'coverage' on the app
     * @name profile.guided.controller.isCoverage
     * @methodOf profile.guided.controller
     * @param member
     * @returns {boolean}
     */
    this.isCoverage = function (member) {
      return _.get(member, 'member_application.type') === 'coverage';
    };

    this.hasSpouse = function () {
      // Check if there's a spouse in all members
      return !!_.findWhere(self.allMembers, {type: 'spouse'});
    };

    this.addSpouse = function () {
      var newSpouse = {
        id: utils.uuid(),
        status: 'household',
        type: 'spouse'
      };
      self.allMembers.push(newSpouse);
      self.appMembers.push(newSpouse);
    };

    this.addDependent = function () {
      var newDependent = {
        id: utils.uuid(),
        status: 'household',
        type: 'dependent'
      };
      self.allMembers.push(newDependent);
      self.appMembers.push(newDependent);
    };

    this.removeMember = function (member) {
      memberService.deleteMember(userModel, member.id)
        .then(function () {
          self.allMembers = _.reject(self.allMembers, {id: member.id});
          self.appMembers = _.reject(self.appMembers, {id: member.id});
        });
    };

    this.updateMembers = function () {
      if (self.appMembers.length !== self.householdSize) {
        return self.error = 'Please select ' + self.householdSize + ' household members';
      }

      addStatusToMembers(self.appMembers);
      return applicationModel.saveMembers(userModel, self.appMembers)
        .then(function (response) {
          $state.go('ob.savings.guided.source');
        });
    };
  }

  Ctrl.$inject = ['$q', '$state', 'baseUser', 'baseHealthApp', 'StartYear', 'member.service', 'finance.service', 'utils'];

  angular.module('routes.ob')
    .controller('profile.guided.controller', Ctrl);
}());

(function () {
  /**
   *
   * @param $scope
   * @constructor
   */
  function Ctrl($q, $scope, $state, $stateParams, userModel, applicationModel, utils, financeService, StartYear, memberService) {

    var self = this;
    this.year = StartYear;

    // Household size
    var householdSize = applicationModel.get().taxInfo.familySize;

    // Get current source index
    self.currentIndex = $stateParams.sourceIndex && parseInt($stateParams.sourceIndex) || 0;

    // Boot user to start of guided flow
    if (self.currentIndex >= householdSize) {
      $state.replace('ob.savings.estimate');
    }

    memberService.getMemberSet(userModel, applicationModel.getId())
      .then(function (response) {
        self.members = response;
        var allMembers = response.allMembers;
        var appMembers = response.appMembers;

        if (allMembers.length === householdSize) {
          // Mark any non app members as household and save to the app
          addStatusToMembers(allMembers);
          return applicationModel.saveMembers(userModel, allMembers);
        } else if (appMembers.length !== householdSize) {
          $state.replace('ob.savings.estimate');
          return $q.reject('Household size is smaller than number of members');
        }
        return appMembers;
      })
      .then(function (updatedMembers) {
        // Check if age is under 14 so income won't be added
        self.filteredMembers = _.filter(updatedMembers, function (member) {
          return member && member.age >= 14 || !member.age;
        });

        self.memberTypes = _.pluck(self.filteredMembers, 'type');
        self.currentMember = self.filteredMembers[self.currentIndex];

        // This happens if there are users under the age of 14
        if (!self.currentMember) {
          return null;
        }
        return financeService.getByMemberAsync(applicationModel.getId(), self.currentMember.id);
      })
      .then(function (finances) {
        if (!finances) {
          return $state.go('ob.savings.guided.summary');
        }

        self.source = {
          memberType: self.memberTypes[self.currentIndex],
          memberId: self.currentMember.id,
          member: self.currentMember,
          appId: applicationModel.getId(),
          finances: finances
        };
        $scope.render = true;
      });


    function addStatusToMembers(memberArray) {
      _.each(memberArray, function (member) {
        var existingStatus = _.get(member, 'member_application.type');
        if (existingStatus) {
          member.status = existingStatus;
        } else {
          member.status = 'household';
        }
      });
    }

    /**
     * @name profile.guided.controller.goToNextIncomeSource
     * @methodOf profile.guided.controller
     */
    this.goToNextIncomeSource = function () {
      var newIndex = self.currentIndex + 1;
      if (newIndex >= self.filteredMembers.length) {
        $state.go('ob.savings.guided.summary');
      } else {
        $state.go('ob.savings.guided.source', {sourceIndex: newIndex});
      }
    };
  }

  Ctrl.$inject = ['$q', '$scope', '$state', '$stateParams', 'baseUser', 'baseHealthApp', 'utils', 'finance.service', 'StartYear', 'member.service'];

  angular.module('routes.ob')
    .controller('profile.guided.source.controller', Ctrl);
}());

(function () {

  /**
   */
  function Ctrl($scope, $state, StartYear, applicationModel, financeService, trackingService) {
    var self = this;
    this.year = StartYear;

    //var incomeMembers = financeService.getIncomeMembers();
    this.financeType = $state.getData().financeType;
    var filteredMembers = applicationModel.getMembers() || [];
    // financeService.getMembersByType(this.financeType);
    $scope.render = false;
    // Get all finances
    financeService.getForAppAsync(applicationModel.getId())
      .then(function (finances) {
        setFinances(finances);
        $scope.render = true;
      });

    this.calcTotal = function (finances) {  // MEMOIZE THIS!
      if (!finances) {
        return 0;
      }

      return finances.reduce(function (sum, finance) {
        sum += finance.amount * finance.multiplier;
        return sum;
      }, 0)
    };

    function setFinances(finances) {
      var filteredFinances = _.filter(finances, function (finance) {
        return !!_.find(filteredMembers, {id: finance.member_id}) && finance.type === self.financeType;
      });
      self.finances = filteredFinances;
      self.financeGroups = aggregateFinances(filteredFinances);
      //console.log('SUMMARY--financeGroups:', self.financeGroups)
    }

    function aggregateFinances(finances) {
      var membersOnApp = _.pluck(applicationModel.getMembers(), 'id');

      // aggregates finances by member_id, pull out common info into separate keys
      return _.reduce(finances, function (acc, finance) {
        if (membersOnApp.indexOf(finance.member_id) < 0) {
          return acc;
        }
        var match = _.find(acc, function (accAgg) {
          return accAgg.member_id === finance.member_id;
        });
        // if member_id key already exists, append the finance to the finances key
        // and reevaluate whether or not it has the least client_created_on value
        if (match) {
          match.finances.push(finance);
          var new_created_on_val = finance.client_created_on.valueOf();
          if (match.min_client_created_on > new_created_on_val) {
            match.min_client_created_on = new_created_on_val
          }
        } else {
          // if no aggregate entry is found, make a new one
          var member = _.find(applicationModel.getMembers(), {id: finance.member_id});
          acc.push({
            member: member,
            member_id: finance.member_id,
            finances: [finance],
            min_client_created_on: finance.client_created_on.valueOf()
          })
        }
        return acc;
      }, [])
    }

    this.reGetFinances = function () {
      setFinances(financeService.get());
    };

    this.trackFinanceEntry = function(){
      var amount = self.calcTotal(self.finances);
      var source = $state.getData().isOnboarding ? applicationModel.get().taxInfo.guided ? 'onboarding: guided' : 'onboarding: simple' : 'application';
      var props = {
        'Calculated Yearly Estimate': amount,
        'Type': self.financeType,
        'Amount': amount,
        'Source': source,
        'Frequency': 'NA',
        'Members': self.financeGroups.length,
        'Sources': _.reduce(self.financeGroups, function(sum, group){
          sum += group.finances.length;
          return sum;
        },0)
      }
      if(self.financeType === 'deduction'){
        _.extend(props,{
          // sum business expenses
          'Amount: Business Expenses': _.reduce(self.finances, function(sum, deduction){
            if(deduction.source_key === 'deduction.businessExpenses'){
              sum += deduction.amount * deduction.multiplier;
            }
            return sum;
          },0)
        })
      }
      var eventName = trackingService.propEnum[self.financeType === 'income' ? 'obIncome' : 'deductionEntry'];
      trackingService.mixpanelEvent(eventName, props);
    }

    this.goNext = function () {
      self.trackFinanceEntry();
      $state.goNext();
    };
  }

  Ctrl.$inject = ['$scope', '$state', 'StartYear', 'baseHealthApp', 'finance.service', 'services.tracking'];

  angular.module('routes.ob')
    .controller('profile.guided.summary.controller', Ctrl);
}());
(function () {

  /**
   */
  function Ctrl($scope, $state, StartYear, applicationModel, financeService) {
    var self = this;
    this.render = false;
    this.app_id = applicationModel.getId();
    this.member_id = $state.params.member_id;
    this.finances = [];
    var stateData = $state.getData();
    this.isOnboarding = !!stateData.isOnboarding;
    this.financeType = stateData.financeType;

    // Get all incomes
    var financesFromParams = $state.params.finances;

    if(!financesFromParams){
      financeService.getByMemberAsync(this.app_id, this.member_id)
      .then(function(finances){
        self.finances = finances;
        self.render = true;
      })
    } else {
      self.finances = financesFromParams;
      self.render = true;
    }

    this.getUnitOfEntry = function(isOnboarding, financeType){
      if(isOnboarding){
        return financeType === 'income' ? 'Job' : 'Deduction';
      }
      return financeType === 'income' ? 'Income' : 'Deduction';
    }

    this.save = function () {
      financeService.update(self.finances)
      financeService.saveForApp(this.app_id, {deep:true})
                    .then(function(result){
                      console.log('save finance success');
                      var ctrl = self.financeType === 'income' ? 'incomeSummaryCtrl' : 'deductionsSummaryCtrl'
                      $scope.$parent[ctrl].reGetFinances();
                      $state.replace('^');
                    });
    };
  }

  Ctrl.$inject = ['$scope', '$state', 'StartYear', 'baseHealthApp', 'finance.service'];

  angular.module('routes.ob')
    .controller('profile.guided.summary.edit.controller', Ctrl);
}());
angular.module('routes.subsidy')
  .controller('routes.subsidy.ffm.amount.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'baseUser',
    'cart.service',
    function($scope, $state, applicationModel, userModel, cartService){
      var app = applicationModel.get();
      if (!app.plan || !app.plan.qhpStatus){
        return $state.replace('recommended');
      }

      var nextState = $state.getData().next;
      // user no longer needs a subsidy to purchase on exchange plans
      if (!app.subsidy || !app.subsidy.amount){
        app.aptc = {
          total: 0,
          applied: 0
        };

        return $state.replace(nextState);
      }

      var aptc = app.aptc;
      cartService.updateDisplayPrice(_.get(app, 'plan.mods.premiumMonth'), 'health');
      $scope.aptcTotal = aptc.total;
      $scope.amounts = _.times(5, function(n){
        var percent = 100 - 25 * n;
        var monthly = aptc.total * (percent / 100);

        return {
          percent: percent,
          monthly: monthly
        };
      });

      $scope.partialAmounts = $scope.amounts;//.slice(1);

      $scope.setAmount = function(amount){
        aptc.applied = amount.monthly;
        applicationModel.save(userModel)
          .then(function(){
            $state.go(nextState);
          });

      };
    }
  ]);
angular.module('routes.subsidy')
  .controller('routes.subsidy.ffm.eSignCtrl', [
    '$q',
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'services.date',
    'services.tracking',
    'partner.service',
    'routes.ffm.service',
    'logger',
    'application.service',
    /**
     * @name profile.eSign.controller
     * @param {object} $q
     * @param {object} $scope
     * @param {ui.router.state.$state} $state
     * @param {user.model} userModel
     * @param {application.model} applicationModel
     * @param {services.date} dateService
     * @param {services.tracking} trackingService
     * @param {partner.service} partnerService
     * @param {routes.ffm.service} ffmService
     * @param {logger} logger
     * @param {application.service} applicationService
     **/
    function($q, $scope, $state, userModel, applicationModel, dateService, trackingService, partnerService, ffmService, logger, applicationService){
      var carrier = applicationModel.getPlan().carrier;
      $scope.model = {
        errorCount: 0
      };

      $q.all([
        dateService.getEffectiveDate({
          state: applicationModel.getState(),
          onExchange: true
        })
        .then(function(effectiveDate){
          $scope.effectiveDate = effectiveDate;
        }),

        partnerService.requiresNotifyOptIn()
          .then(function(result){
            $scope.model.showPartnerOptIn = result;
            $scope.model.partnerOptIn = result;
          })
        ])
        .then(function(){
          $scope.render = true;
        });

      $scope.applicants = _.filter(applicationModel.getMembers(), function(applicant){
        return applicant.age > 17;
      });

      $scope.tokens = {
        carrierName: carrier
      };

      $scope.signatures = _.map($scope.applicants, function(applicant){
        return {
          first: applicant.first_name,
          last: applicant.last_name,
          firstValue: '',
          lastValue: ''
        };
      });

      $scope.submit = function(){
        if ($scope.model.signForm.$valid) {
          $q.when(true)
            .then(function(){
              if ($scope.model.showPartnerOptIn){
                return partnerService.notifyOptIn($scope.model.partnerOptIn);
              }
            })
            .then(function(){
              var memberIds = _.chain(applicationModel.getMembers())
                // all member ids for the app
                .pluck(['id'])
                // find all members that esigned
                .filter(function(memberId){
                  return !!_.findWhere($scope.applicants, { id: memberId });
                })
                .value();

              return applicationService.eSign(applicationModel.getId(), memberIds);
            })
            .then(function(){ return ffmService.enroll(applicationModel, $scope.effectiveDate); })
            .then(function(){ return applicationService.setActive(userModel, applicationModel.getId(), 'health'); })
            .then(function(){ return applicationModel.setFromWorking(userModel); })
            .then(function(){
              var plan = applicationModel.getPlan();
              var premium = applicationModel.getPremium();

              trackingService.setPeopleProp(trackingService.propEnum.purchasedRank, plan.mods.ranks.strideRank);
              trackingService.mixpanelEvent(trackingService.propEnum.purchaseComplete, {
                'Health': true,
                'Dental': false,
                'Health Premium': premium,
                'Dental Premium': null,
                'Subsidy Amount': plan.mods.savings.subsidy || 0,
                'Total Cart Value': premium,
                'Stride Plan ID': plan.id,
                'HIOS ID': plan.planId
              });

              $state.go('^.submitted');
            })
            .catch(function (err) {
              logger.error({
                message: 'Error submitting FFM application',
                stack: err && err.message || err,
                userOid: applicationModel.getUserId(),
                path: $state.href($state.current)
              });

              throwError(err);
            });
        }
      };

      function throwError(error){
        $scope.validError = error && error.reason || error || '500';
        $scope.model.errorCount++;
      }
    }
  ]);
angular.module('routes.subsidy')
  .controller('routes.subsidy.ffm.ineligible.controller', [
    '$scope',
    'baseHealthApp',
    'plan.search',
    'baseUser',
    function($scope, applicationModel, planSearch, userModel){
      var application = applicationModel.get();
      var plan = application.plan;

      $scope.$watch(function(){
        var plan = applicationModel.getPlan();
        return plan && plan.premiumMonth;
      }, function(premium){
        if (premium){
          $scope.tokens = {
            planName: plan.carrier + ' ' + plan.name,
            premium: premium.toFixed(2)
          };
        }
      });

      // wipe out subsidy if they are ineligible
      // persist the wiped subsidy
      applicationModel.killSubsidy().save(userModel);

      // prime the cache for reco page
      planSearch.getMerged(applicationModel);
    }
  ]);
angular.module('routes.subsidy')
  .controller('routes.subsidy.ffm.sync.controller', [
    '$q',
    '$scope',
    '$state',
    'baseUser',
    'baseHealthApp',
    'ffmApplication',
    'config.ages',
    'services.date',
    'search.geo',
    'member.service',
    'Members',
    'logger',
    function ($q, $scope, $state, userModel, applicationModel, ffmApplication, ages, dateService, geoSearch, memberService, members, logger) {

      if (_.isEmpty(ffmApplication) || _.isEmpty(ffmApplication.applicants)) {
        return $state.replace('ffm');
      }

      $scope.members = members;
      var primaryAddress = ffmApplication.primaryAddress;
      if (!isSameAddress()){
        geoSearch.getByZip(primaryAddress.zipcode)
          .then(function(addresses){
            var appCounty = (primaryAddress.county || '').toLowerCase();
            var match = _.find(addresses, function(address){
              return _.isString(address.county) && address.county.toLowerCase() === appCounty;
            });

            if (!match){
              logger.error({
                message: 'FFM: No county match found for ' + applicationModel.getId(),
                ffmAddress: primaryAddress,
                geoList: addresses
              });
            }

            else {
              applicationModel.saveAddress(userModel, _.defaults(match, primaryAddress, applicationModel.getAddress()));
            }
          });
      }

      var mergedApplicants;
      var skippedApplicants;

      $scope.noMatch = false;
      $scope.startOver = start;
      $scope.select = function (applicant) {
        // get the current ffm applicant from the copied array
        merge(applicant, $scope.ffmApplicants.shift());

        // remove this applicant from future choices
        $scope.applicants = _.without($scope.applicants, applicant);

        // if both arrays only have 1 person left,
        // can safely match them up and finish?
//        if ($scope.applicants.length == 1 && $scope.ffmApplicants.length == 1){
//          merge($scope.applicants.pop(), $scope.ffmApplicants.pop());
//        }


        // if an array is empty, we're done
        if (!$scope.applicants.length || !$scope.ffmApplicants.length) {
          complete();
        }

        // otherwise the ffmApplicant array shift will take care of going to next applicant
      };

      $scope.skip = function () {
        var ffmApplicant = $scope.ffmApplicants.shift();

        // If no one was selected for every matching attempt
        if ($scope.ffmApplicants.length === 0 && mergedApplicants.length === 0) {
          $scope.noMatch = true;
        } else {
          skippedApplicants.push(ffmApplicant);
        }

        // if an array is empty, we're done
        if (!$scope.applicants.length || !$scope.ffmApplicants.length) {
          complete();
        }
      };

      $scope.done = function () {
        var applicants = $scope.completedApplicants;
        var aptcIneligible = _.where(applicants, {aptcEligible: false});
        var exchangeEligible = _.where(applicants, { exchangeEligible: true });
        var allIneligible = aptcIneligible.length === applicants.length;
        var nextState;

        // for all eligible, all are covered
        // for all ineligible, keep all covered and remove subsidy
        var appMembers = _.map(applicants, function(applicant){
          return _.extend({ status: 'coverage' }, applicant);
        });

        // if everyone is exchange eligible, they may not be getting a subsidy
        // so let them though to the check state
        // they will skip the amount selection in that case
        if (!aptcIneligible.length || (allIneligible && exchangeEligible.length === applicants.length)) {
          nextState = 'ffm.check';
        }
        else if (allIneligible) {
          nextState = '.ineligible';
        }
        else {
          nextState = '.partial';
          appMembers = _.map(applicants, function(applicant){
            return _.extend({ status: applicant.aptcEligible ? 'coverage' : 'household' }, applicant);
          });
        }
        // save any new members and update any existing
        return applicationModel.saveMembers(userModel, appMembers)
          .then(function(){
            var application = applicationModel.get();

            // rec-fetch takes care of the saving
            if (application.subsidy){
              application.subsidy.amount = parseFloat(ffmApplication.total);
              application.aptc = {
                total: parseFloat(ffmApplication.total)
              };
            }

            return $state.go(nextState);
          });
      };

      function isSameAddress(){
        var appAddress = applicationModel.getAddress();
        return primaryAddress && appAddress && _.every(['zipcode', 'county'], function(prop){ return primaryAddress[prop] === appAddress[prop]; });
      }

      function start() {
        mergedApplicants = [];
        skippedApplicants = [];
        var applicants = angular.copy(applicationModel.getMembers());

        // don't include any members that don't have a name set already
        var remainingMembers = _.reject(members, function(member){
          return !!_.findWhere(applicants, { id: member.id }) || !member.first_name || !member.last_name;
        });

        $scope.applicants = applicants.concat(remainingMembers);
        $scope.ffmApplicants = angular.copy(ffmApplication.applicants);
        $scope.completedApplicants = [];
        $scope.noMatch = false;
      }

      function merge(strideApplicant, ffmApplicant) {
        // pull over any relevant info from stride applicant
        strideApplicant.first_name = ffmApplicant.first_name;
        strideApplicant.last_name = ffmApplicant.last_name;
        strideApplicant.dob = ffmApplicant.dob;
        strideApplicant.gender = ffmApplicant.gender;
        strideApplicant.aptcEligible = ffmApplicant.aptcEligible;
        strideApplicant.exchangeEligible = ffmApplicant.exchangeEligible;
        strideApplicant.ffmId = ffmApplicant.ffmId;
        mergedApplicants.push(strideApplicant);
      }

      function complete() {
        // cycle through ffm applicants and create applicant models from them

        return dateService.getEffectiveDate({ onExchange: true, state: applicationModel.getState() })
          .then(function(effectiveDate){
            $scope.completedApplicants = _.map(mergedApplicants.concat($scope.ffmApplicants, skippedApplicants), function (applicant) {
              return {
                id: applicant.id,
                first_name: applicant.first_name,
                middle_name: applicant.middle_name,
                last_name: applicant.last_name,
                type: applicant.type,
                dob: applicant.dob,
                relation: applicant.relation,
                age: dateService.getStartDateAgeSync(applicant.dob, effectiveDate),
                gender: applicant.gender,
                tobacco: applicant.tobacco,
                ffmId: applicant.ffmId,
                aptcEligible: applicant.aptcEligible,
                exchangeEligible: applicant.exchangeEligible,
                illnesses: applicant.illnesses || []
              };
            });
          });

      }

      start();
    }
  ])

  .controller('routes.subsidy.ffm.sync.partial.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    function ($scope, $state, applicationModel) {
      var members = $scope.completedApplicants;

      $scope.eligible = _.where(members, {aptcEligible: true});
      $scope.ineligible = _.where(members, {aptcEligible: false});

      $scope.next = function () {
        // this save is already happening on the sync done method
        //var appMembers = _.map(members, function(member){
        //  return _.extend({ status: member.aptcEligible ? 'coverage' : 'household'}, member);
        //});
        //
        //return applicationModel.saveMembers(appMembers)
        //  .then(function () {
            return $state.go('ffm.check');
          //});
      };
    }
  ]);
angular.module('routes.subsidy')
  .controller('routes.subsidy.exchange.address.controller', [
    '$scope',
    '$state',
    'baseHealthApp',
    'application.service',
    'logger',
    'cart.service',
    function($scope, $state, applicationModel, applicationService, logger, cartService){
      $scope.application = applicationModel.get();

      $scope.continue = goNext;
      $scope.onNoChange = goNext;
      $scope.onChange = function(){
        $scope.changed = true;
      };

      function goNext(){
        cartService.updateDisplayPrice(applicationModel.getPlan().mods.premiumMonth);
        cartService.saveAddress(applicationModel.getAddress())
          .then(function(address){
            applicationModel.address = address;
            //application.stateExchange.homeAddress = address;
            $state.go('exchange.applicants');
          });
      }
    }
  ]);


//(function(){
//
//  var mod = angular.module('routes.subsidy');
//  var scopeDep = '$scope';
//  var stateDep = '$state';
//  var userModelDep = 'user.model';
//  var appModelDep = 'application.model';
//
//  function initCtrl(name, func){
//    mod.controller('routes.subsidy.exchange.' + name, [
//      scopeDep,
//      stateDep,
//      userModelDep,
//      appModelDep,
//      func
//    ])
//  }
//
//  initCtrl('address.controller', function($scope, $state, userModel, applicationModel){
//    var application = applicationModel.get();
//
//    $scope.application = application;
//    $scope.onNoChange = goNext;
//    $scope.onChange = function(){
//      $scope.changed = true;
//    };
//
//    $scope.continue = goNext;
//
//    function goNext(){
//      application.stateExchange.homeAddress = application.address;
//      userModel.save(true)
//        .then(function(){
//          $state.go('exchange.applicants');
//        });
//    }
//  });
//
////  initCtrl('mailing.controller', function($scope, $state, userModel, applicationModel){
////    var application = applicationModel.get();
////    var stateExchange = application.stateExchange;
////    stateExchange.mailingAddress = stateExchange.mailingAddress || {};
////    $scope.stateExchange = stateExchange;
////
////    $scope.onNoChange = $scope.onChange = goNext;
////
////    $scope.mailingSame = function(){
////      angular.extend(stateExchange.mailingAddress, stateExchange.homeAddress);
////      goNext();
////    };
////
////    $scope.mailingDifferent = function(){
////      $state.go('.form');
////    };
////
////    $scope.continue = goNext;
////
////    function goNext(){
////      userModel.save(true)
////        .then(function(){
////          $state.go('exchange.familyAddress');
////        });
////
////    }
////  });
////
////
////  initCtrl('familyAddress.controller', function($scope, $state, userModel, applicationModel){
////    var application = applicationModel.get();
////    var stateExchange = application.stateExchange;
////    var key = 'familyAddressDifferent';
////    $scope.stateExchange = stateExchange;
////
////    $scope.familySame = function(){
////      stateExchange[key] = { value: false };
////      saveAndGo('exchange.taxes')
////    };
////
////    $scope.familyDifferent = function(){
////      stateExchange[key] = {
////        value: true,
////        applicants: _.map(applicationModel.getApplicants(), function(applicant){
////          var app = {
////            uuid: applicant.uuid,
////            value: applicant.name.first + ' ' + applicant.name.last,
////            dob: applicant.dob
////          };
////          app[key] = false;
////
////          return app;
////        })
////      };
////
////      saveAndGo('.applicants');
////    };
////
////    $scope.$on('$stateChangeSuccess', function($event, toState, toParams){
////      console.log(toState, toParams);
////    });
////
////    function saveAndGo(state, params){
////      userModel.save(true)
////        .then(function(){
////          $state.go(state, params);
////        });
////    }
////  });
//
//}());
(function () {

  var mod = angular.module('routes.subsidy');
  var qDep = '$q';
  var scopeDep = '$scope';
  var stateDep = '$state';
  var stateParamsDep = '$stateParams';
  var utilsDep = 'utils';
  var appModelDep = 'application.model';
  var memberServiceDep = 'member.service';
  var baseUserDep = 'baseUser';
  var ctrlBase = 'routes.subsidy.exchange.';

  mod.controller(ctrlBase + 'applicants.controller', [
    qDep,
    scopeDep,
    stateDep,
    utilsDep,
    appModelDep,
    memberServiceDep,
    baseUserDep,
    'cart.service',
    'services.date',
    function ($q, $scope, $state, utils, applicationModel, memberService, userModel, cartService, dateService) {
      var self = this;
      $scope.render = false;
      self.householdSize = _.get(applicationModel.get(), 'taxInfo.familySize', applicationModel.getCoveredMembers().length);
      self.planYear = applicationModel.getPlan().planYear;

      // Member arrays
      self.allMembers = [];
      self.appMembers = [];
      self.newMembers = [];
      self.incompleteMembers = [];
      self.householdMembers = [];

      // Get members
      memberService.getMemberSet(userModel, applicationModel.getId())
        .then(function (response) {
          // All members and app members
          self.allMembers = response.allMembers;
          self.appMembers = response.appMembers;

          // Get app members that aren't medicaid
          self.householdMembers = memberService.filterNonMedicaidAppMembers(response.appMembers);

          // Show different text depending on if all member info is added
          self.isComplete = _.every(self.allMembers, memberService.isComplete) && self.householdMembers.length === self.householdSize;

          // Remember incomplete members
          self.incompleteMembers = _.filter(self.allMembers, function (member) {
            return !memberService.isComplete(member);
          });

          $scope.render = true;
        });

      /**
       * Checks if toggling and removing should be disabled for member as they are included in the app
       * @param member
       * @returns {boolean|*}
       */
      this.shouldDisable = function (member) {
        return member.type === 'primary' || (isInMembersArray(self.appMembers, member) && member.member_application.type === 'coverage');
      };

      /**
       * Checks if remove option should be disabled
       * @param member
       * @returns {*}
       */
      this.disableRemove = function (member) {
        return isInMembersArray(self.allMembers, member);
      };

      /**
       * Checks if member is in the household
       * @param member
       * @returns {*}
       */
      this.isInHousehold = function (member) {
        return isInMembersArray(self.householdMembers, member);
      };

      /**
       * Toggles the member to be a part of the household or not
       * @param member
       */
      this.toggleMember = function (member) {
        $scope.memberError = false;

        var memberIndex = _.findIndex(self.householdMembers, function (arrayMember) {
          return arrayMember.id === member.id;
        });
        if (memberIndex > -1) {
          // Remove from app members array if present
          self.householdMembers.splice(memberIndex, 1);
        } else {
          // Otherwise add member to app members array
          self.householdMembers.push(member);
        }
      };

      /**
       * If the number of household members is less than household size, allow user to add a member
       * @returns {boolean}
       */
      this.showAddMember = function () {
        return self.householdMembers.length < self.householdSize;
      };

      this.greaterThanHouseholdSize = function () {
        return self.householdMembers.length > self.householdSize;
      };

      /**
       * Add spouse
       */
      this.addSpouse = function () {
        var newSpouse = {type: 'spouse', id: utils.uuid(), editMode: true, first_name: '', last_name: ''};
        if (!_.findWhere(self.allMembers, {type: 'spouse'})) {
          self.allMembers.push(newSpouse);
        }
        self.allMembers = memberService.sortAllMembers(self.allMembers);
      };

      /**
       * Add dependent
       */
      this.addDependent = function () {
        self.addMember('dependent');
      };

      /**
       * Add member
       */
      this.addMember = function (type) {
        $scope.memberError = false;

        var newDependent = {
          type: type || '',
          id: utils.uuid(),
          editMode: true,
          first_name: '',
          last_name: '',
          user_id: userModel.getId()
        };
        self.allMembers.push(newDependent);
        self.householdMembers.push(newDependent);
        self.newMembers.push(newDependent);
        self.allMembers = memberService.sortAllMembers(self.allMembers);
      };

      /**
       * Remove member
       * @param member
       */
      this.removeMember = function (member) {
        $scope.memberError = false;

        self.householdMembers = _.reject(self.householdMembers, {id: member.id});
        self.allMembers = _.reject(self.allMembers, {id: member.id});
        self.newMembers = _.reject(self.newMembers, {id: member.id});
      };

      /**
       * Go to edit the specific member
       * @param member
       */
      this.editMember = function (member) {
        $state.go('.member', {memberId: member.id});
      };

      /**
       * Checks if member should be in edit mode
       * @param member
       * @returns {boolean|*}
       */
      this.isEditMode = function (member) {
        return !memberService.isComplete(member) || !member.created_on || _.findWhere(self.newMembers, {id: member.id}) || _.findWhere(self.incompleteMembers, {id: member.id});
      };

      function isInMembersArray(array, member) {
        return !!_.findWhere(array, {id: member.id});
      }

      $scope.continue = goNext;


      /**
       * When the user edits the member detail and saves, the member is saved to the server but the client needs to be
       * updated until the server does a get on members again
       */
      $scope.$on('member-updated', function (event, member) {
        updateMemberIfInArray(self.allMembers, member);
        updateMemberIfInArray(self.appMembers, member);
        updateMemberIfInArray(self.newMembers, member);
        updateMemberIfInArray(self.incompleteMembers, member);
        updateMemberIfInArray(self.householdMembers, member);
      });

      function updateMemberIfInArray(array, member) {
        var index = _.findIndex(array, {id: member.id});
        if (index > -1) {
          array[index] = _.extend(array[index], member);
        }
      }

      /**
       * Go to next state
       * @param form
       */
      this.next = function (form) {
        self.invalidMember = false;

        // All checked members on this page are household members
        var updatedMembers = _.map(self.allMembers, function (member) {
          var status;

          if (isInMembersArray(self.appMembers, member)) {
            status = _.get(member, 'member_application.type', memberService.isMedicaid(member) ? 'medicaid' : 'coverage');
          }
          else if (isInMembersArray(self.householdMembers, member)) {
            status = 'household';
          }

          // status remains undefined for unassociated members
          _.extend(member, {status: status});

          return member;
        });

        self.allMembers = updatedMembers;

        // Save a copy of unchanged app members
        var savedMembers = memberService.sortAllMembers(applicationModel.getMembers());

        // Error check members on the app's ages
        var inHHMembers = _.filter(updatedMembers, function (member) {
          return _.get(member, 'member_application.type');
        });

        var dobs = _.pluck(inHHMembers, 'dob');

        dateService.getStartDateAges(dobs, applicationModel)
          .then(function (response) {
            var invalidAge = false;

            _.each(inHHMembers, function (member, index) {
              member.age = response[index];

              if (!memberService.isValid(member)) {
                member.invalid = true;
                invalidAge = true;
              }
            });

            if (invalidAge) {
              return;
            }

            // Filter out any members not on app or in household
            var appMembers = _.filter(updatedMembers, function (member) {
              return member.status;
            });
            return applicationModel.saveMembers(userModel, appMembers);
          })
          .then(function (updatedAppMembers) {
            // If all ages are valid and save is successful
            if (updatedAppMembers) {
              // Filter out any non coverage members
              var coverageMembers = _.filter(updatedAppMembers, function (member) {
                return member.member_application.type === 'coverage';
              });
              var savedCoverageMembers = _.filter(savedMembers, function (member) {
                return member.member_application.type === 'coverage';
              });

              // Update cart member names
              cartService.updateAppMembers(applicationModel.getId(), coverageMembers);

              // Check if number of app members (covered and medicaid) changed or if gender or age changed
              if (savedCoverageMembers.length !== coverageMembers.length) {
                $scope.changed = true;
              } else if (genderOrAgeChanged(savedCoverageMembers, coverageMembers)) {
                $scope.changed = true;
              } else {
                goNext();
              }
            }
          });
      };

      this.checkForErrors = function () {
        if (self.householdMembers.length < self.householdSize) {
          $scope.memberError = true;
        }
      };

      function genderOrAgeChanged(savedMembers, updatedMembers) {
        var changed = false;

        _.each(updatedMembers, function (updatedMember) {
          var matchingMember = _.findWhere(savedMembers, {id: updatedMember.id});
          if (!matchingMember || matchingMember.gender !== updatedMember.gender || matchingMember.age !== updatedMember.age) {
            changed = true;
            return;
          }
        });
        return changed;
      }

      function goNext() {
        var application = applicationModel.get();
        var state = 'exchange.';

        //if (application.taxInfo && application.taxInfo.familySize > $scope.applicants.length) {
        //  state += 'additional';
        //}
        if (_.findWhere(self.allMembers, {gender: 'F'})) {
          state += 'pregnant';
        }
        else {
          application.stateExchange.pregnant = {value: false};
          state += applicationModel.hasSubsidy() ? 'taxes' : 'questions';
        }

        cartService.updateDisplayPrice(applicationModel.getPlan().mods.premiumMonth);
        $state.go(state);
        return true;
      }
    }
  ]);

  mod.controller(ctrlBase + 'pregnant.controller', [
    scopeDep,
    stateDep,
    appModelDep,
    baseUserDep,
    'member.service',
    function ($scope, $state, applicationModel, userModel, memberService) {
      var stateExchange = applicationModel.getStateExchange();
      var members = applicationModel.getMembers();

      $scope.stateExchange = stateExchange;

      $scope.noPregnant = function () {
        stateExchange.pregnant = {value: false};
        $scope.done();
      };

      $scope.done = function () {
        applicationModel.save(userModel)
          .then(function () {
            $state.go(applicationModel.hasSubsidy() ? 'exchange.taxes' : 'exchange.questions');
          });
      };

      $scope.selfPregnant = function () {
        $scope.setApplicants();
        $scope.applicant = stateExchange.pregnant.applicants[0];
        $scope.applicant.pregnant = true;
        $state.go('exchange.pregnant.applicants.applicant', {index: 0});
      };

      $scope.setApplicants = function () {
        if (!_.isObject(stateExchange.pregnant) || !_.isArray(stateExchange.pregnant.applicants)) {
          stateExchange.pregnant = {
            value: true,
            applicants: _.map(members, function (member) {
              return memberService.asExtrasFormat(member, 'pregnant');
            })
          };
        }
      };
    }
  ]);

  mod.controller(ctrlBase + 'pregnant.applicants.controller', [
    scopeDep,
    stateDep,
    appModelDep,
    function ($scope, $state, applicationModel) {
      var getStateExchange = _.bind(applicationModel.getStateExchange, applicationModel);
      $scope.setApplicants();

      $scope.attach = function () {
        var selected = $scope.getSelected();

        if (!selected.length) {
          getStateExchange().pregnant = {value: false};
          $scope.done();
        }
        else {
          $state.go('.applicant', {index: 0});
        }
      };

      $scope.getSelected = function () {
        return getStateExchange().pregnant && _.where(getStateExchange().pregnant.applicants, {pregnant: true}) || [];
      };
    }
  ]);

  mod.controller(ctrlBase + 'pregnant.applicant.controller', [
    scopeDep,
    stateDep,
    stateParamsDep,
    function ($scope, $state, $stateParams) {
      var index = parseInt($stateParams.index);
      var selected = $scope.getSelected();
      $scope.applicant = selected[index];

      if (!$scope.applicant) {
        return $state.go('^');
      }

      var today = new Date();
      // setting a limit of 10 months on this
      var dueDateMax = new Date(today.getFullYear(), today.getMonth() + 10, today.getDate());
      $scope.dueDateRange = [today, dueDateMax];
      $scope.counts = [1, 2, 3, 4, 5, 6];

      $scope.setBabyCount = function (count) {
        $scope.applicant.expecting = count;
        next();
      };

      function next() {
        if (selected.length <= index + 1) {
          $scope.done();
        }
        else {
          $state.go('^', {index: index + 1});
        }
      }

    }
  ]);

}());

(function () {
  /**
   *
   * @param $scope
   * @param $state
   * @param $stateParams
   * @param userModel
   * @param memberService
   * @param applicationModel
   * @param dateService
   * @constructor
   */
  function Ctrl($scope, $state, $stateParams, userModel, memberService, applicationModel, dateService) {
    var self = this;
    this.render = false;

    // Get member and make a copy so user can cancel changes
    memberService.getById($stateParams.memberId)
      .then(function (member) {
        self.savedMember = member;
        $scope.member = angular.copy(member);
        self.render = true;
      });

    /**
     * Save member
     */
    this.save = function () {
      // Calculate age on start date
      dateService.getStartDateAge($scope.member.dob, applicationModel)
        .then(function (age) {
          $scope.member.age = age;

          if (!memberService.isValid($scope.member)) {
            $scope.member.invalid = true;
            return;
          }
          return memberService.saveMember(userModel, $scope.member);
        })
        .then(function (response) {
          if (response) {
            $scope.$emit('member-updated', response);
            $state.replace('^');
          }
        });
    };
  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'baseUser', 'member.service', 'baseHealthApp', 'services.date'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.applicants.member.controller', Ctrl);
}());

(function () {

  function Ctrl($q, $state, $scope, subsidyService, planStats, planUtils, utils, applicationModel, trackingService, userModel, financeService) {
    var self = this;
    var application = applicationModel.get();

    if (!application.subsidy) {
      return $state.go('recommended');
    }

    var stateExchange = application.stateExchange;
    var initialSubsidyAmount = application.subsidy.amount;
    var frequencyMultipliers = {
      once: 1,
      hourly: 2080, //40 * 52 assuming 40 hours per week?
      weekly: 52,
      monthly: 12,
      twiceMonthly: 24,
      yearly: 1
    };
    var viewModel = $scope.viewModel = {};

    var coveredAndMedicaidMembers = applicationModel.getCoveredAndMedicaidMembers() || [];

    // Previous statuses: example: ['coverage', 'coverage', 'medicaid', 'household']
    var oldStatuses = _.chain(coveredAndMedicaidMembers)
      .pluck('member_application')
      .pluck('type')
      .filter(function (eligibility) {
        return eligibility !== 'household';
      })
      .value();

    $scope.medicaidIneligible = [];
    var statusChanged = false;

    financeService.getForAppAsync(applicationModel.getId())
      .then(function (finances) {
        var allIncome = _.filter(finances, {type: 'income'});
        var allDeductions = _.filter(finances, {type: 'deduction'});

        var incomeTotal = _.reduce(allIncome, function (sum, income) {
          return sum += income.amount * income.multiplier;
        }, 0);
        var deductionTotal = _.reduce(allDeductions, function (sum, deduction) {
          return sum += deduction.amount * deduction.multiplier;
        }, 0);

        self.netIncome = incomeTotal - deductionTotal;


        // Application flow income and family size
        var familySize = getFamilySize();

        // Onboarding income info
        application.taxInfo = application.taxInfo || {};

        // Discrepancy between annualized income they add: (new income estimate) - (old income estimate)
        var incomeDelta = self.netIncome - application.taxInfo.income;
        trackingService.mixpanelEvent(trackingService.propEnum.incomeDelta, {'Income Delta': incomeDelta});

        // Set app income and family size to updated data from application flow
        application.taxInfo.income = self.netIncome;
        application.taxInfo.familySize = familySize;

        return applicationModel.save(userModel)
      })
      .then(function(){
        // Calculates new subsidy and save to app model
        return planStats.getCoveredMembersEstimate(self.netIncome, application.taxInfo.familySize, applicationModel, coveredAndMedicaidMembers);
      })
      .then(function (subsidyInfo) {
        var latestEligibilities = subsidyService.getLatestEligibilities(subsidyInfo.oldMemberStatuses, subsidyInfo.newMemberStatuses);
        var estimate = subsidyInfo.newEstimate;
        var latestArrays = subsidyService.checkApplicants(latestEligibilities, estimate, coveredAndMedicaidMembers);
        var medicaidIds = _.pluck(latestArrays.medicaidMembers, 'id');

        $scope.coverageMembers = _.reject(coveredAndMedicaidMembers, function (member) {
          return _.contains(medicaidIds, member.id);
        });
        $scope.monthlyAmount = subsidyInfo.newEstimate.aptc;

        // Compare old statuses to latest eligibilities
        _.each(oldStatuses, function (status, index) {
          if (status === 'medicaid' && latestEligibilities[index] !== 'medicaid') {
            statusChanged = true;
            $scope.medicaidIneligible.push(coveredAndMedicaidMembers[index]);
          } else if (status !== 'medicaid' && latestEligibilities[index] === 'medicaid') {
            statusChanged = true;
          }
        });
        $scope.render = true;

        if (!statusChanged && !$scope.medicaidIneligible.length) {
          goNext();
          // $scope.render = false;
        } else {
          _.extend($scope, latestArrays);
          // $scope.render = true;
        }
      });


    //// Application flow income and family size
    //var netIncome = getNetIncome();
    //var familySize = getFamilySize();
    //
    //// Onboarding income info
    //application.taxInfo = application.taxInfo || {};
    //
    //// Discrepancy between annualized income they add: (new income estimate) - (old income estimate)
    //var incomeDelta = netIncome - application.taxInfo.income;
    //trackingService.mixpanelEvent(trackingService.propEnum.incomeDelta, {'Income Delta': incomeDelta});
    //
    //// Set app income and family size to updated data from application flow
    //application.taxInfo.income = netIncome;
    //application.taxInfo.familySize = familySize;
    //
    //// Calculate estimate and get medicaid / subsidy eligibilities of covered and medicaid members on the app
    //var coveredAndMedicaidMembers = applicationModel.getCoveredAndMedicaidMembers() || [];
    //
    //// Previous statuses: example: ['coverage', 'coverage', 'medicaid', 'household']
    //var oldStatuses = _.chain(coveredAndMedicaidMembers)
    //  .pluck('member_application')
    //  .pluck('type')
    //  .filter(function (eligibility) {
    //    return eligibility !== 'household';
    //  })
    //  .value();
    //
    //$scope.medicaidIneligible = [];
    //var statusChanged = false;
    //
    //// Calculates new subsidy and save to app model
    //planStats.getCoveredMembersEstimate(netIncome, familySize, applicationModel, coveredAndMedicaidMembers)
    //  .then(function (subsidyInfo) {
    //    // Copy the old eligibility arrays
    //    //
    //    //var copyOldMemberStatuses = angular.copy(subsidyInfo.oldMemberStatuses);
    //    //
    //    //_.each(subsidyInfo.newMemberStatuses, function (newMemberStatus) {
    //    //  var match = _.findWhere(copyOldMemberStatuses, function (oldMemberStatus) {
    //    //    return oldMemberStatus.member.id === newMemberStatus.member.id;
    //    //  });
    //    //
    //    //  if (match) {
    //    //    match.eligibility = newMemberStatus.eligibility;
    //    //  }
    //    //});
    //
    //    var latestEligibilities = subsidyService.getLatestEligibilities(subsidyInfo.oldMemberStatuses, subsidyInfo.newMemberStatuses);
    //    var estimate = subsidyInfo.newEstimate;
    //    var latestArrays = subsidyService.checkApplicants(latestEligibilities, estimate, coveredAndMedicaidMembers);
    //    var medicaidIds = _.pluck(latestArrays.medicaidMembers, 'id');
    //
    //    $scope.coverageMembers = _.reject(coveredAndMedicaidMembers, function (member) {
    //      return _.contains(medicaidIds, member.id);
    //    });
    //    $scope.monthlyAmount = subsidyInfo.newEstimate.aptc;
    //
    //    // Compare old statuses to latest eligibilities
    //    _.each(oldStatuses, function (status, index) {
    //      if (status === 'medicaid' && latestEligibilities[index] !== 'medicaid') {
    //        statusChanged = true;
    //        $scope.medicaidIneligible.push(coveredAndMedicaidMembers[index]);
    //      } else if (status !== 'medicaid' && latestEligibilities[index] === 'medicaid') {
    //        statusChanged = true;
    //      }
    //    });
    //
    //    if (!statusChanged && !$scope.medicaidIneligible.length) {
    //      goNext();
    //      $scope.render = false;
    //    } else {
    //      _.extend($scope, latestArrays);
    //      $scope.render = true;
    //    }
    //  });

    /**
     * Show medicaid description
     */
    $scope.showMedicaidDesc = function () {
      utils.toggleBool(viewModel, 'scrollMedicaidHelp');
      viewModel.showMedicaidMore = true;
    };

    /**
     * Get latest recommendation
     */
    $scope.getRecommendation = function () {
      application.plan = null;
      removeMedicaidMembers()
        .then(function () {
          return planStats.getCoveredMembersEstimate(self.netIncome, getFamilySize(), applicationModel, applicationModel.getCoveredMembers());
        })
        .then(function () {
          return applicationModel.save(userModel);
        })
        .then(function () {
          $state.go('recommended');
        });
    };

    /**
     * Remove any subsidy
     * @returns {*}
     */
    $scope.declineSubsidy = function () {
      return applicationModel.setPlan(userModel, null)
        .then(function () {
          return $state.go('recommended');
        });
    };

    /**
     * Calculate subsidy
     * @returns {*}
     */
    $scope.doSubsidyCalc = function () {
      var netIncome = self.netIncome;
      var familySize = getFamilySize();

      var coveredAndMedicaidMembers = applicationModel.getCoveredAndMedicaidMembers() || [];
      return planStats.getCoveredMembersEstimate(netIncome, familySize, applicationModel, coveredAndMedicaidMembers)
        .then(goNext);
      //return getEstimate(netIncome, familySize)
      //  .then(goNext);
    };

    function goNext() {
      if (!application.subsidy || application.subsidy.amount !== initialSubsidyAmount) {
        // $scope.showPlanCheck();
        $scope.conflict = true
      }
      else {
        $state.replace('exchange.questions');
      }
    }

    /**
     * Updates statuses if member becomes medicaid eligible or ineligible
     * @returns {HttpPromise.<Address>|Promise.<Member[]>}
     */
    function removeMedicaidMembers() {
      var updatedAppMembers = [];
      var appMembers = applicationModel.getMembers();

      // $scope.medicaidMembers are members who became medicaid eligible
      // $scope.medicaidIneligible are members who became medicaid ineligible and should be covered
      _.each(appMembers, function (appMember) {
        if (_.findWhere($scope.medicaidMembers, {id: appMember.id})) {
          _.extend(appMember, {status: 'medicaid'});
        }
        else if (_.findWhere($scope.medicaidIneligible, {id: appMember.id})) {
          _.extend(appMember, {status: 'coverage'});
        }
        else {
          // Keep the status they had
          appMember.status = appMember.member_application.type;
        }
        updatedAppMembers.push(appMember);
      });
      return applicationModel.saveMembers(userModel, updatedAppMembers);
    }

    //function getNetIncome() {
    //  // income - deductions
    //  return _.reduce(['income', 'deductions'], function (memo, key) {
    //    var multiplier = key === 'income' ? 1 : -1;
    //
    //    var applicants = stateExchange[key].applicants;
    //    if (!applicants || !applicants.length) {
    //      return memo;
    //    }
    //
    //    return memo + multiplier * _.reduce(applicants, function (sum1, applicant) {
    //
    //        if (applicant[key] && applicant.sources) {
    //          return sum1 + _.reduce(applicant.sources, function (sum2, source) {
    //              return sum2 + source.amount * frequencyMultipliers[source.frequency];
    //            }, 0);
    //        }
    //
    //        return sum1;
    //      }, 0);
    //  }, 0);
    //}

    function getFamilySize() {
      var pregnancies = stateExchange.pregnant && stateExchange.pregnant.applicants || [];
      var babyCount = _.reduce(pregnancies, function (memo, applicant) {
        return applicant.pregnant && applicant.expecting || 0;
      }, 0);

      return applicationModel.getMembers().length + babyCount;
    }


    //function getEstimate(netIncome, familySize, members) {
    //  var appMembers = members || applicationModel.getCoveredMembers();
    //  return planStats.getBenchmark(applicationModel, appMembers)
    //    .then(function (premium) {
    //      return subsidyService.getEstimate(applicationModel.getState(), netIncome, familySize, planUtils.getApplicantParams(appMembers), premium * 12);
    //    });
    //}

  }

  Ctrl.$inject = ['$q', '$state', '$scope', 'services.subsidy', 'plan.stats', 'plan.utils', 'utils', 'baseHealthApp', 'services.tracking', 'baseUser', 'finance.service'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.taxes.eligibilityCtrl', Ctrl);
}());
(function () {

  /**
   * @name routes.subsidy.exchange.taxes.invalidStatusController
   * @param {ui.router.state.$state} $state
   * @constructor
   */
  function Ctrl($state, $stateParams, applicationModel) {
    this.invalidStatus = $stateParams.invalidStatus;

    this.addHouseholdMember = function () {
      applicationModel.data.taxInfo.familySize++;
      $state.go('exchange.applicants');
    };
  }

  Ctrl.$inject = ['$state', '$stateParams', 'baseHealthApp'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.taxes.primary.controller.invalidStatus', Ctrl);
}());
(function () {

  var mod = angular.module('routes.subsidy');
  var scopeDep = '$scope';
  var stateDep = '$state';
  var stateParamsDep = '$stateParams';
  var appModelDep = 'baseHealthApp';
  var ctrlBase = 'routes.subsidy.exchange.taxes.';

  /**
   * @name routes.subsidy.exchange.taxes.controller
   */
  mod.controller(ctrlBase + 'controller', [
    scopeDep,
    stateDep,
    appModelDep,
    'baseUser',
    'stateConfig',
    'cart.service',
    function ($scope, $state, applicationModel, userModel, stateConfig, cartService) {

      var plan = applicationModel.getPlan();

      if (!plan) return;

      $scope.lock = false;
      $scope.stateConfig = stateConfig;
      $scope.application = applicationModel.get();
      $scope.planName = plan.name;
      $scope.premium = plan.mods.premiumMonth.toFixed(2);


      $scope.$on('source-complete', function ($event, data) {

        if ($scope.lock) {
          return;
        }

        applicationModel.save(userModel)
          .then(function () {
            $state.go($state.getData().completedState);
          });
      });

      $scope.showPlanCheck = function () {
        $scope.checkPlan = true;
      };

      $scope.complete = function () {
        cartService.updateDisplayPrice(applicationModel.getPlan().mods.premiumMonth);
        $state.go('exchange.questions');
      };
    }
  ]);

  /**
   * @name routes.subsidy.exchange.taxes.primary.controller
   */
  mod.controller(ctrlBase + 'primary.controller', [
    scopeDep,
    stateDep,
    appModelDep,
    'member.service',
    'baseUser',
    function ($scope, $state, applicationModel, memberService, userModel) {
      var self = this;
      var stateExchange = applicationModel.getStateExchange();
      var baseState = 'exchange.taxes.primary';
      var property = 'primaryTaxFiler';
      self.members = [];

      function getAppMembers() {
        // Get app members to show list to choose primary
        memberService.getAppMembers(userModel, applicationModel.getId())
          .then(function (response) {
            self.members = response;
            stateExchange[property] = {
              value: true,
              applicants: _.map(self.members, function (member) {
                return memberService.asExtrasFormat(member, property);
              })
            };
            $scope.stateExchange = stateExchange;
            ensurePrimary();
            $scope.render = true;
          });
      }

      $scope.$on('$stateChangeSuccess', getAppMembers());

      $scope.primary = getPrimary();

      $scope.setPrimary = function (applicant) {
        setPrimary(applicant);
        $state.go(baseState + '.filingStatus');
      };

      $scope.setStatus = function (filingStatus) {
        var primary = getPrimary();
        var householdSize = applicationModel.data.taxInfo.familySize;

        if (filingStatus === 'separately') {
          $state.go(baseState + '.filingStatus.invalid', {invalidStatus: 'nonJointMarriedOrSeparate'});
        }

        // Household size 1
        else if (householdSize === 1) {
          if (memberService.isMarried(primary) && filingStatus === 'single') {
            $state.go(baseState + '.filingStatus.invalid', {invalidStatus: 'nonJointMarriedOrSeparate'});
          }
          else if (filingStatus === 'jointly' || filingStatus === 'headOfHousehold') {
            $state.go(baseState + '.filingStatus.invalid', {invalidStatus: 'single' + filingStatus});
          } else {
            saveFilingStatus(filingStatus);
          }
        }

        //Household size greater than 1
        else if (householdSize > 1) {
          if (memberService.isMarried(primary) && filingStatus === 'single') {
            $state.go(baseState + '.filingStatus.invalid', {invalidStatus: 'nonJointMarriedOrSeparate'});
          }
          else {
            saveFilingStatus(filingStatus);
          }
        }

        // Catch all case
        else {
          saveFilingStatus(filingStatus);
        }
      };

      function saveFilingStatus(filingStatus) {
        stateExchange.filingStatus = filingStatus;
        applicationModel.save(userModel)
          .then(function () {
            if (applicationModel.getMembers().length === 1) {
              return $state.go('exchange.taxes.income.applicant', {index: 0});
            }
            return $state.go('exchange.taxes.income');
          });
      }

      function setPrimary(applicant) {
        _.each(stateExchange[property].applicants, function (app) {
          app[property] = app === applicant;
        });

        $scope.primary = getPrimary();
      }

      function getPrimary() {
        return _.findWhere(self.members, {type: 'primary'});
        //return _.findWhere(stateExchange[property].applicants, {primaryTaxFiler: true});
      }

      function ensurePrimary() {
        if (!getPrimary() && !isBaseState()) {
          $state.go(baseState);
        }
        else if (isBaseState() && _.get(stateExchange[property], 'applicants.length') === 1) {
          setPrimary(stateExchange[property].applicants[0]);
          $state.replace(baseState + '.filingStatus');
        }
      }

      function isBaseState() {
        return $state.current.name === baseState;
      }
    }
  ]);

  ///**
  // * @name routes.subsidy.exchange.taxes.source.applicant.controller
  // */
  //mod.controller(ctrlBase + 'source.applicant.controller', [
  //  scopeDep,
  //  stateDep,
  //  stateParamsDep,
  //  function ($scope, $state, $stateParams) {
  //    var index = parseInt($stateParams.index);
  //    var property = $state.current.data.property;
  //    var applicants = $scope.getSelected();
  //
  //    if (applicants.length < index) {
  //      return $scope.done();
  //    }
  //
  //    var applicant = applicants[index];
  //
  //    if (!applicant || !applicant[property]) {
  //      return $state.go('^');
  //    }
  //
  //    $scope.addSource = function () {
  //      applicant.sources.push({});
  //    };
  //
  //    $scope.removeSource = function (index) {
  //      applicant.sources.splice(index, 1);
  //    };
  //
  //    $scope.next = function () {
  //      if (applicants.length === index + 1) {
  //        $scope.done();
  //      }
  //      else {
  //        $state.go($state.current.name, {index: index + 1});
  //      }
  //    };
  //
  //    $scope.applicant = applicant;
  //
  //    if (!applicant.sources.length) {
  //      $scope.addSource();
  //    }
  //  }
  //]);

}());

(function(){
  /**
   * @name routes.visit.plan.completeCtrl
   * @param {ui.router.state.$state} $state
   * @param {visit.plan.builder} planBuilder
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl($state, planBuilder, trackingService){
    var self = this;
    var planId = planBuilder.getValue('id');
    var isCreate = _.isUndefined(planId);

    planBuilder.finish()
      .then(function(visitPlan){
        self.planId = visitPlan.id;

        if (isCreate){
          trackingService.mixpanel.people.increment('Visit Plans Created');
        }
      })
      .catch(function(){
        self.invalid = true;
      })
      .finally(function(){
        self.ready = true;
      });

    this.seePlan = function(){
      planBuilder.clear();
      $state.go('dashboard.care.visits.details', { id: self.planId });
    };
  }
  Ctrl.$inject = ['$state', 'visit.plan.builder', 'services.tracking'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.plan.completeCtrl', Ctrl);
}());
(function(){

  /**
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.scope} $scope
   * @param DoctorResultsModel
   * @param planBuilder
   * @param {services.tracking} trackingService
   * @param {ifp_app} ActiveHealth
   * @constructor
   */
  function Ctrl($state, $scope, DoctorResultsModel, planBuilder, trackingService, ActiveHealth){
    var settings = _.extend({ ifp_app: ActiveHealth }, $state.getData().settings);

    settings.onClick = function(result){
      planBuilder.setValue('provider_id', result.id);
      planBuilder.setValue('doctor', result);
      trackingService.mixpanelEvent('Visit Plans: Doctor Selection: Pick Doctor', {
        'Visit Type': planBuilder.getValue('type'),
        'Doctor Picked': true
      });

      $state.goNext();
    };

    this.model = new DoctorResultsModel(settings);
    this.model.updateResults($scope.doctorCtrl.doctors);
  }
  Ctrl.$inject = ['$state', '$scope', 'doctor.results.model', 'visit.plan.builder', 'services.tracking', 'ActiveHealth'];

  angular.module('visit')
    .controller('routes.visit.plan.doctor.resultsCtrl', Ctrl);
}());
(function(){

  /**
   * @name visit.doctor.searchCtrl
   *
   * @param {ui.router.state.$state} $state
   * @param {ng.$rootScope.Scope} $scope
   * @param {doctor.search.model} DoctorSearchModel
   * @param {doctor.service} doctorService
   * @param {VisitPlan} visitPlan
   * @param {user.model} userModel
   * @param {ifp_app} ActiveHealth
   */
  function Ctrl($state, $scope, DoctorSearchModel, doctorService, visitPlan, userModel, ActiveHealth){
    if (!visitPlan || !visitPlan.type){
      return;
    }

    var searchParams = {
      visitType: visitPlan.type,
      patientNetwork: _.get(ActiveHealth, 'app_json.plan.networkId'),
      inNetwork: true
    };

    /**
     * @type {doctor.search.model}
     */
    this.model = new DoctorSearchModel(_.extend({ searchParams: searchParams, forceSearch: true, trackingCategory: 'Visit Plans: Doctor Selection' }, $state.getData().settings || {}));
    this.model.init($scope, userModel)
      .then(_.bind(this.model.search, this.model));

    $scope.$on('$destroy', doctorService.clear);
  }
  Ctrl.$inject = ['$state', '$scope', 'doctor.search.model', 'doctor.service', 'visitPlan', 'baseUser', 'ActiveHealth'];

  angular.module('visit')
    .controller('visit.doctor.searchCtrl', Ctrl);
}());
(function(){
  /**
   * @name routes.visit.plan.illnessesCtrl
   * @param {ui.router.state.$state} $state
   * @param {visit.plan.builder} planBuilder
   * @param {Illness[]} illnesses
   * @constructor
   */
  function Ctrl($state, planBuilder, illnesses){

    var member = planBuilder.getValue('member');

    if (!member){
      return;
    }

    this.list = angular.copy(illnesses);

    // default to saved illnesses in the plan builder
    var savedList = planBuilder.getValue('illnesses');

    // then check for illnesses on the member
    if (!_.isArray(savedList) && _.isArray(member.illnesses)){
      savedList = member.illnesses;
    }

    if (_.isArray(savedList)){
      _.each(this.list, function(listIllness){
        if (_.contains(savedList, listIllness.name)){
          listIllness.selected = true;
        }
      });
    }

    this.next = function(){
      planBuilder.setValue('illnesses', _.pluck(_.where(this.list, { selected: true }), 'name'));
      $state.goNext();
    };
  }
  Ctrl.$inject = ['$state', 'visit.plan.builder', 'illnesses'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.plan.illnessesCtrl', Ctrl);
}());
//(function(){
//
//  /**
//   * @name routes.visit.plan.introCtrl
//   * @param {visit.plan.builder} planBuilder
//   * @param {member.service} memberService Remove this once we're allowing user to pick which member the visit is for
//   * @param {user.model} userModel Remove this once we're allowing user to pick which member the visit is for
//   * @param {health.app} activeHealthApp
//   * @param {logger} logger
//   * @constructor
//   */
//  function Ctrl(planBuilder, memberService, userModel, activeHealthApp, logger){
//    var self = this;
//    planBuilder.start();
//
//    // TODO: remove this once member select is enabled
//    memberService.getAll()
//      .then(function(members){
//        var member = _.findWhere(members, { id: activeHealthApp.getPrimaryId() || userModel.getPrimaryId() });
//
//        if (!member) {
//          logger.error({
//            message: 'Cannot find primary member',
//            user: userModel.get(),
//            healthApp: activeHealthApp.get()
//          });
//        }
//        else {
//          self.member = member;
//          planBuilder.setValues({
//            member: member
//          });
//        }
//      });
//  }
//  Ctrl.$inject = ['visit.plan.builder', 'services.member', 'baseUser', 'activeHealthApp', 'logger'];
//
//  angular.module('routes.visit.plan')
//    .controller('routes.visit.plan.introCtrl', Ctrl);
//}());
(function(){

  /**
   * @name routes.visit.plan.memberCtrl
   * @param {ui.router.state.$state} $state
   * @param {member.service} memberService
   * @param {visit.plan.builder} planBuilder
   * @param {user.model} userModel
   * @constructor
   */
  function Ctrl($state, memberService, planBuilder, userModel){
    var self = this;

    memberService.getAll(userModel)
      .then(function(members){
        self.members = members;

        console.log(members);

        // auto select if only 1 member in family
        if (members.length === 1){
          self.pickMember(members[0]);
        }

      })
      .catch(function(err){
        console.log(err);
      });

    /**
     *
     * @param {Member} member
     */
    this.pickMember = function(member){
      planBuilder.setValues({
        member: member,
        step: 'member'
      });

      $state.go($state.current.data.next);
    };
  }
  Ctrl.$inject = ['$state', 'member.service', 'visit.plan.builder', 'baseUser'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.plan.memberCtrl', Ctrl);

}());
(function(){

  /**
   * @name routes.visit.plan.questionCtrl
   * @param {visit.plan.builder} planBuilder
   * @param {Builder} questionBuilder
   * @constructor
   */
  function Ctrl(planBuilder, questionBuilder){
    var visitType = planBuilder.getValue('visitType');
    if (!visitType || !_.isArray(visitType.questionKeys) || !visitType.questionKeys.length){
      return;
    }

    this.questions = questionBuilder.getValue('questions');
  }
  Ctrl.$inject = ['visit.plan.builder', 'builder'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.plan.questionsCtrl', Ctrl);
}());
(function(){

  /**
   * @name routes.visit.plan.typeCtrl
   * @param {ui.router.state.$state} $state
   * @param {visit.service} visitService
   * @param {visit.plan.builder} planBuilder
   * @param {services.tracking} trackingService
   * @constructor
   */
  function Ctrl($state, visitService, planBuilder, trackingService){

    var self = this;
    var member = planBuilder.getValue('member');

    if (!member){
      return;
    }

    trackingService.setPeopleProps({
      'Age': member.age,
      'Gender': member.gender
    });

    this.typeKey = planBuilder.getValue('type');

    visitService.getPlanTypes(member)
      .then(function(types){
        self.types = types;

        if (types && types.length === 1){
          self.pickType(types[0]);
        }
      });

    this.pickType = function(type){
      planBuilder.setValues({
        type: type.key,
        visitType: type,
        step: 'type'
      });

      self.type = type;
      self.typeKey = type.key;
      $state.goNext();
    };
  }
  Ctrl.$inject = ['$state', 'visit.service', 'visit.plan.builder', 'services.tracking'];

  angular.module('routes.visit.plan')
    .controller('routes.visit.plan.typeCtrl', Ctrl);
}());
(function(){

  /**
   * @name visit.plan.benefit.allCtrl
   * @param {ng.$q} $q
   * @param {ui.router.state.$state} $state
   * @param {visit.service} visitService
   * @param {visit.plan.builder} planBuilder
   * @constructor
   */
  function Ctrl($q, $state, visitService, planBuilder){
    var self = this;
    var member              = planBuilder.getValue('member');
    var suggested           = planBuilder.getValue('suggested_benefits');
    var requested           = planBuilder.getValue('requested_benefits');
    var recommended         = planBuilder.getValue('recommended_benefits');
    var selectedServices    = planBuilder.getValue('additional_services') || [];
    var visitType           = planBuilder.getValue('type');
    self.benefitDetails     = [];
    self.services           = [];



    if (
      !member ||
      !visitType ||
      !_.isNumber(member.age) ||
      !_.isString(member.gender) ||
      !_.isArray(recommended) ||
      !_.isArray(suggested) ||
      !_.isArray(requested)
    ){
      return;
    }

    var pregnant = !!(member.risk_factors && member.risk_factors.pregnant);
    var allBenefits = _.uniq(recommended.concat(suggested));

    $q
      .all([
        visitService.getRecommendationsById(allBenefits),
        visitService.getServices(member.age, member.gender, visitType, pregnant)
      ])
      .then(function(responses){
        self.benefitDetails = responses[0];
        var services = responses[1];

        // overwrite the service text with personalized reco text
        _.each(services, function(service){
          service.text = getRecommendationText(service);
          service.selected = isServiceSelected(service);
        });

        //detailService.setSelectedBenefits(planBuilder.data, self.benefitDetails);
        //detailService.setSelectedServices(planBuilder.data, services, self.benefitDetails);

        self.services = services.sort(sortServices);
      });

    this.save = function(){
      var selectedServices = _.where(self.services, { selected: true });
      var selectedBenefits = _.filter(self.benefitDetails, function(benefit){
        return !!_.findWhere(selectedServices, { id: benefit.serviceId });
      });

      planBuilder.setValue('requested_benefits', _.pluck(selectedBenefits, 'id'));
      planBuilder.setValue('additional_services', _.without(_.pluck(selectedServices, 'id'), _.pluck(selectedBenefits, 'serviceId')));

      $state.go($state.current.data.next);
    };

    /**
     * @param {VisitBenefitService} service
     * @returns {string}
     */
    function getRecommendationText(service){
      var benefit = _.find(self.benefitDetails, function(b){
        return b.serviceId === service.id;
      });

      return benefit && benefit.text || service.text || '';
    }

    /**
     * @param {VisitBenefitService} service
     * @returns {boolean}
     */
    function isServiceSelected(service){
      if (_.contains(selectedServices, service.id)){
        return true;
      }

      return _.chain(self.benefitDetails)
        // get all recommendations that the user requested
        .filter(function(benefit){
          return _.contains(requested, benefit.id);
        })
        // get the service id from them
        .pluck('serviceId')
        // see if this service is in there
        .contains(service.id)
        .value();
    }

    // alphabetical by service name with selected on top
    function sortServices(a, b){
      if (a.selected && !b.selected) {
        return -1;
      }

      if (b.selected && !a.selected) {
        return 1;
      }

      return b.serviceName > a.serviceName ? -1 : 1;
    }
  }
  Ctrl.$inject = ['$q', '$state', 'visit.service', 'visit.plan.builder'];

  angular.module('visit')
    .controller('visit.plan.benefit.allCtrl', Ctrl);
}());
(function(){


  function Ctrl($state, $scope, DoctorResultsModel, planBuilder, trackingService){
    var stateData = $state.current.data || {};
    var settings = _.extend({}, stateData.settings);
    settings.onClick = function(result){
      planBuilder.setValue('provider_id', result.id);
      planBuilder.setValue('doctor', result);
      trackingService.mixpanelEvent('Visit Plans: Doctor Selection: Pick Doctor', {
        'Visit Type': planBuilder.getValue('type'),
        'Doctor Picked': true
      });

      $state.go(stateData.next);
    };

    this.model = new DoctorResultsModel(settings);
    this.model.watchResults($scope);
  }
  Ctrl.$inject = ['$state', '$scope', 'doctor.results.model', 'visit.plan.builder', 'services.tracking'];

  angular.module('visit')
    .controller('visit.plan.doctor.resultsCtrl', Ctrl);
}());
(function () {

  /**
   */
  function Ctrl($q, $scope, $state, applicationModel, memberService, userModel, financeService, trackingService) {
    var self = this;
    var financeType = $state.getData().financeType;

    $q.all([
        // members on app
        memberService.getAppMembers(userModel, applicationModel.getId()),
        // existing finances even ones thare are disassociated from the app
        financeService.getAllAsync(applicationModel.getId())
      ])
      .then(function (results) {
        self.setFinancesAndMembers(results[0], results[1]);
        $scope.render = true;
      });

    this.setFinancesAndMembers = function (members, finances) {
      self.members = members;
      var financesByType = self.setFinances(finances);
      self.setIncludedMembers(members, financesByType);
    };

    this.setFinances = function (finances) {
      self.allFinancesForType = _.filter(finances, function (finance) {
        return finance.type === financeType;
      });
      return self.allFinancesForType;
    };

    this.setIncludedMembers = function (members, finances) {
      $scope.includedMembers = _.reduce(members, function (acc, member) {
        if (!_.find(acc, {id: member.id}) && _.find(finances, function (finance) {
            return finance.member.id === member.id && finance.member_finance_applications;
          })) {
          acc.push(member);
        }
        return acc;
      }, []);
    };

    this.toggleMember = function (member) {
      var memberIndex = _.findIndex($scope.includedMembers, {id: member.id});
      var deleteObj = {};
      // If the member is in app members
      if (memberIndex > -1) {
        $scope.includedMembers.splice(memberIndex, 1);
        deleteObj = {delete: true};
      } else {
        // If the member is not in app members, add to app members
        $scope.includedMembers.push(member);
        deleteObj = {delete: false};
      }
      // disassociate finances on members not in the list of filteredMembers
      // reassociate finances where the member is included
      _.each(self.allFinancesForType, function (finance) {
        if (finance.member.id === member.id) {
          _.extend(finance, deleteObj, {dirty: !finance.dirty})
        }
      })
    };

    this.isAdded = function (member) {
      return !!_.findWhere($scope.includedMembers, {id: member.id});
    };

    this.goNext = function () {
      // Save list of members that have an income
      // financeService.saveMembersByType(self.filteredMembers, financeType);


      // financeService.getForAppAsync(applicationModel.getId())
      //   .then(function (finances) {
      // _.each(self.allFinances, function (finance) {
      //   if (finance.type === financeType && !_.find(self.$scope.includedMembers, {id: finance.member_id})) {
      //     finance.delete = true;
      //     finance.dirty = true;
      //   }
      // });
      // console.log(self.allFinancesForType.map(function(f){return [f.dirty, f.delete]}))
      financeService.update(self.allFinancesForType);
      financeService.saveAppAssociations(applicationModel.getId())
        .then(function (updatedFinances) {
          self.setFinances(updatedFinances);
          self.goToIndex(0);
        });
    };

    this.goToIndex = function (destinationIndex) {
      if ($scope.includedMembers.length === 0) {
        if (financeType === 'deduction') {
          return $state.go('^.eligibility');
        }
        return $state.go($state.getData().summaryState);
      }
      if (destinationIndex >= $scope.includedMembers.length) {
        return $state.go($state.getData().summaryState);
      }
      $state.go(destinationIndex ? '^.applicant' : '.applicant', {index: destinationIndex});
    }
  }

  Ctrl.$inject = ['$q', '$scope', '$state', 'baseHealthApp', 'member.service', 'baseUser', 'finance.service', 'services.tracking'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.taxes.source.controller', Ctrl);
}());
(function () {

  /**
   */
  function Ctrl($scope, $state, $stateParams, applicationModel, financeService) {
    var self = this;
    $scope.render = false;
    var index = parseInt($stateParams.index);

    var member = $scope.includedMembers[index];
    // reloads of this route go back to selection route
    if (!member) {
      return $state.go('^');
    }

    this.financeType = $state.getData().financeType;

    // var filteredMembers = financeService.getMembersByType($state.getData().financeType) || [];



    financeService.getByMemberAsync(applicationModel.getId(), member.id)
                  .then(function (finances) {
                    self.source = {
                      member: member,
                      memberType: member.type,
                      memberId: member.id,
                      appId: applicationModel.getId(),
                      finances: _.filter(finances, function(finance){
                        return finance.type === self.financeType;
                      })
                    };
                    $scope.render = true;
                  });

    this.goNext = function () {
      var parentScopeCtrl = self.financeType === 'income' ? 'incomeCtrl' : 'deductionsCtrl';
      $scope.$parent[parentScopeCtrl].goToIndex(index + 1);
    };

  }

  Ctrl.$inject = ['$scope', '$state', '$stateParams', 'baseHealthApp', 'finance.service'];

  angular.module('routes.subsidy')
    .controller('routes.subsidy.exchange.taxes.source.member.controller', Ctrl);
}());